<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Post-rsses on 董二千</title>
    <link>https://LinkRober.github.io/bookshelf/post/index.xml</link>
    <description>Recent content in Post-rsses on 董二千</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 08 Dec 2020 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://LinkRober.github.io/bookshelf/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Weak的实现-&amp;SideTables()[oldObj]</title>
      <link>https://linkrober.github.io/bookshelf/2020/12/weak%E7%9A%84%E5%AE%9E%E7%8E%B0-sidetablesoldobj/</link>
      <pubDate>Tue, 08 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linkrober.github.io/bookshelf/2020/12/weak%E7%9A%84%E5%AE%9E%E7%8E%B0-sidetablesoldobj/</guid>
      <description>&lt;p&gt;&lt;code&gt;&amp;amp;SideTables()[oldObj]&lt;/code&gt;这是什么？很多人看到这里都被这操作搞蒙了，下面分三步来理解，分别是&lt;code&gt;SideTables()&lt;/code&gt;、&lt;code&gt;[oldObj]&lt;/code&gt;、&lt;code&gt;&amp;amp;&lt;/code&gt;。先贴上入口的代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;id oldObj;
SideTable *oldTable;

oldObj = *location;
oldTable = &amp;amp;SideTables()[oldObj];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h4 id=&#34;1-理解-sidetables&#34;&gt;1. 理解&lt;code&gt;SideTables()&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;首先&lt;code&gt;SideTables()&lt;/code&gt;是一个静态函数，完全体是这样的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static StripedMap&amp;lt;SideTable&amp;gt;&amp;amp; SideTables() {
    return SideTablesMap.get();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;函数体里面调用了一个全局的静态变量&lt;code&gt;SideTablesMap&lt;/code&gt;的&lt;code&gt;get()&lt;/code&gt;方法，
静态变量里面保存了所有的&lt;code&gt;SideTable&lt;/code&gt;。的声明如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static objc::ExplicitInit&amp;lt;StripedMap&amp;lt;SideTable&amp;gt;&amp;gt; SideTablesMap;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出&lt;code&gt;SideTablesMap&lt;/code&gt;是在命名空间objc下面的一个&lt;code&gt;ExplicitInit&lt;/code&gt;类，它里面实现了&lt;code&gt;get()&lt;/code&gt;方法，如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Type &amp;amp;get() {
    return *reinterpret_cast&amp;lt;Type *&amp;gt;(_storage);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于不熟悉c++的理解下面这几点基本就能看懂：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;c++ 中的引用&lt;code&gt;&amp;amp;&lt;/code&gt;，在c++中&lt;code&gt;&amp;amp;&lt;/code&gt;除了有&lt;code&gt;取地址&lt;/code&gt;的作用还可以作为&lt;code&gt;引用&lt;/code&gt;。方法返回的是一个引用，如果没有c++基础的很容易误认为返回了一个指针。&lt;/li&gt;
&lt;li&gt;c++中的模板&lt;code&gt;template&lt;/code&gt;，泛型&lt;code&gt;Type&lt;/code&gt;是通过模板传入的，即&lt;code&gt;StripedMap&lt;/code&gt;。
从上面声明&lt;code&gt;SideTablesMap&lt;/code&gt;的地方可以看到，这里是个模板的嵌套，&lt;code&gt;StripedMap&lt;/code&gt;是&lt;code&gt;ExplicitInit&lt;/code&gt;模板的泛型；&lt;code&gt;SideTable&lt;/code&gt;是&lt;code&gt;StripedMap&lt;/code&gt;模板的泛型。&lt;/li&gt;
&lt;li&gt;c++中的&lt;code&gt;reinterpret_cast&amp;lt;new_type&amp;gt;(expression)
&lt;/code&gt;，它可以将两种任何类型进行转换，新值和旧值（expression）有相同的比特位。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;最后用&lt;code&gt;*&lt;/code&gt;取转换后得到的地址的所保存的值，返回，所以说这里返回的不是指针。
&lt;code&gt;Type *&lt;/code&gt;就相当于&lt;code&gt;StripedMap *&lt;/code&gt;，所以&lt;code&gt;get()&lt;/code&gt;方法返回的就是&lt;code&gt;StripedMap&lt;/code&gt;结构体实例。&lt;/p&gt;

&lt;h4 id=&#34;2-理解-oldobj&#34;&gt;2. 理解&lt;code&gt;[oldObj]&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;这里的&lt;code&gt;[]&lt;/code&gt;其实是对&lt;code&gt;[]&lt;/code&gt;进行了重载&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;T&amp;amp; operator[] (const void *p) { 
        return array[indexForPointer(p)].value; 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在&lt;code&gt;indexForPointer()&lt;/code&gt;方法里，先将结构体指针&lt;code&gt;oldObj&lt;/code&gt;转化成和其有相同比特位的地址，再进行位移、异或、去模操作得到一个从0-63位之间的&lt;code&gt;index&lt;/code&gt;，通过&lt;code&gt;index&lt;/code&gt;，拿到数组里面的&lt;code&gt;PaddedT&lt;/code&gt;结构体，返回该结构体的&lt;code&gt;value&lt;/code&gt;成员即结构体&lt;code&gt;SideTable&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static unsigned int indexForPointer(const void *p) {
        uintptr_t addr = reinterpret_cast&amp;lt;uintptr_t&amp;gt;(p);
        return ((addr &amp;gt;&amp;gt; 4) ^ (addr &amp;gt;&amp;gt; 9)) % StripeCount;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt; struct PaddedT {
        T value alignas(CacheLineSize);
    };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其实&lt;code&gt;StripedMap&lt;/code&gt;是一个以&lt;code&gt;void *p&lt;/code&gt;为&lt;code&gt;key&lt;/code&gt;，&lt;code&gt;PaddedT&lt;/code&gt;为&lt;code&gt;value&lt;/code&gt;的的表。&lt;/p&gt;

&lt;h4 id=&#34;3&#34;&gt;3. &lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;最后对&lt;code&gt;SideTables()[oldObj]&lt;/code&gt;即&lt;code&gt;SideTable&lt;/code&gt;取地址，这样就和&lt;code&gt;SideTable *newTable;&lt;/code&gt;对上了。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Weak的实现（一）</title>
      <link>https://linkrober.github.io/bookshelf/2020/12/weak%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%80/</link>
      <pubDate>Tue, 08 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linkrober.github.io/bookshelf/2020/12/weak%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%80/</guid>
      <description>&lt;p&gt;本文较长查分为三段按序阅读体验更佳，第四篇为辅助阅读按需看&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;[Weak的实现（一）]()&lt;/li&gt;
&lt;li&gt;[Weak的实现（二）]()&lt;/li&gt;
&lt;li&gt;[Weak的实现（三）]()&lt;/li&gt;
&lt;li&gt;[Weak的实现-&amp;amp;SideTables()[oldObj]]()&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;带着问题看源码：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;大家都知道weak的底层实现是一个散列表，那么散列表的结构是什么样的？&lt;/li&gt;
&lt;li&gt;散列表的key是什么，value是什么，散列函数是怎样的？&lt;/li&gt;
&lt;li&gt;通过几次查找才能找到对应的弱引用？&lt;/li&gt;
&lt;li&gt;如何查找弱引用对象的引用计数？&lt;/li&gt;
&lt;li&gt;一个对象对应一个&lt;code&gt;SideTable&lt;/code&gt;表而一个&lt;code&gt;SideTable&lt;/code&gt;对应多个对象，为什么这样设计&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;散列表：散列表（Hash table），根据键直接方法在内存存储位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做散列表。&lt;/p&gt;

&lt;p&gt;散列函数：它是一个函数，如果把它定义成hash(key)，其中key表示元素的键值，在hash(key)的值表示经过散列函数计算得到的散列值&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;从代码开始&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    NSObject *obj = [[NSObject alloc] init];
    id __weak obj1 = obj;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建&lt;code&gt;weak&lt;/code&gt;引用的时候会走到&lt;code&gt;runtime&lt;/code&gt;的&lt;code&gt;objc_initWeak&lt;/code&gt;这个方法里面。通过符号断点可以验证。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;runtime&lt;/code&gt;里的入口&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;id objc_initWeak(id *location, id newObj)
{
    if (!newObj) {
        *location = nil;
        return nil;
    }

    return storeWeak&amp;lt;DontHaveOld, DoHaveNew, DoCrashIfDeallocating&amp;gt;
        (location, (objc_object*)newObj);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到是走到了&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/*
@param `*location`:weak的指针地址
@param `objc_object`:被引用的对象
*/
template &amp;lt;HaveOld haveOld, HaveNew haveNew,
          CrashIfDeallocating crashIfDeallocating&amp;gt; 
storeWeak(id *location, objc_object *newObj)

{
    //校验旧对象和新对象必须存其一
    ASSERT(haveOld  ||  haveNew);
    //校验如果haveNew=true，newObj不能为nil
    if (!haveNew) ASSERT(newObj == nil);

    Class previouslyInitializedClass = nil;
    id oldObj;
    SideTable *oldTable;
    SideTable *newTable;

    // Acquire locks for old and new values.
    // Order by lock address to prevent lock ordering problems. 
    // Retry if the old value changes underneath us.
 retry:
    if (haveOld) {
    //如果weak ptr存在旧值，就取出旧值
        oldObj = *location;
        //以旧对象为析构函数的入参取出旧的SideTable
        oldTable = &amp;amp;SideTables()[oldObj];
    } else {
        oldTable = nil;
    }
    if (haveNew) {
     //如果weak ptr是新值，以新对象为析构函数的入参取出对应的SideTable
        newTable = &amp;amp;SideTables()[newObj];
    } else {
        newTable = nil;
    }
    
    //将oldTable和newTable都上锁
    SideTable::lockTwo&amp;lt;haveOld, haveNew&amp;gt;(oldTable, newTable);
    //校验，如果旧值对不上 goto retry
    if (haveOld  &amp;amp;&amp;amp;  *location != oldObj) {
        SideTable::unlockTwo&amp;lt;haveOld, haveNew&amp;gt;(oldTable, newTable);
        goto retry;
    }

    // Prevent a deadlock between the weak reference machinery
    // and the +initialize machinery by ensuring that no 
    // weakly-referenced object has an un-+initialized isa.
    //保证弱引用对象的isa非空，防止弱引用机制和+initialize 发生死锁
    if (haveNew  &amp;amp;&amp;amp;  newObj) {
        Class cls = newObj-&amp;gt;getIsa();
        if (cls != previouslyInitializedClass  &amp;amp;&amp;amp;  
            !((objc_class *)cls)-&amp;gt;isInitialized()) 
        {
            SideTable::unlockTwo&amp;lt;haveOld, haveNew&amp;gt;(oldTable, newTable);
            //如果class没有初始化发送+initialized消息
            class_initialize(cls, (id)newObj);

            // If this class is finished with +initialize then we&#39;re good.
            // If this class is still running +initialize on this thread 
            // (i.e. +initialize called storeWeak on an instance of itself)
            // then we may proceed but it will appear initializing and 
            // not yet initialized to the check above.
            // Instead set previouslyInitializedClass to recognize it on retry.
            previouslyInitializedClass = cls;
            //到这里class肯定已经初始化了，在走一遍
            goto retry;
        }
    }

    // Clean up old value, if any.
    // 如果weak ptr之前引用了其他对象，在这里清空
    if (haveOld) {
    //&amp;lt;&amp;lt;1&amp;gt;&amp;gt;
        weak_unregister_no_lock(&amp;amp;oldTable-&amp;gt;weak_table, oldObj, location);
    }

    // Assign new value, if any.
    if (haveNew) {
    //通过newObj和location生成一个新的weak_entry_t并插入到newObj的弱引用数组中（weak_entries）
    //&amp;lt;&amp;lt;2&amp;gt;&amp;gt;
        newObj = (objc_object *)
            weak_register_no_lock(&amp;amp;newTable-&amp;gt;weak_table, (id)newObj, location, 
                                  crashIfDeallocating);
        // weak_register_no_lock returns nil if weak store should be rejected

        // Set is-weakly-referenced bit in refcount table.
        if (newObj  &amp;amp;&amp;amp;  !newObj-&amp;gt;isTaggedPointer()) {
           //&amp;lt;&amp;lt;3&amp;gt;&amp;gt; 
           newObj-&amp;gt;setWeaklyReferenced_nolock();
        }

        // Do not set *location anywhere else. That would introduce a race.
        *location = (id)newObj;
    }
    else {
        // No new value. The storage is not changed.
    }
    
    SideTable::unlockTwo&amp;lt;haveOld, haveNew&amp;gt;(oldTable, newTable);

    return (id)newObj;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;获取对象所在的&lt;code&gt;SideTable&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;isa&lt;/code&gt;非空校验，如果&lt;code&gt;isa&lt;/code&gt;没有初始化执行&lt;code&gt;class_initialize(cls, (id)newObj);&lt;/code&gt;方法&lt;/li&gt;
&lt;li&gt;如果地址&lt;code&gt;location&lt;/code&gt;的引用对象已经存在，删除其在&lt;code&gt;weak_table_t&lt;/code&gt;表中的所有引用&lt;/li&gt;
&lt;li&gt;注册新对象的弱引用到&lt;code&gt;weak_table_t&lt;/code&gt;表中&lt;/li&gt;
&lt;li&gt;设置新对象的弱引用标志符为&lt;code&gt;YES&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果对&lt;code&gt;&amp;amp;SideTables()[oldObj]&lt;/code&gt;不太理解的可以先移步&lt;a href=&#34;http://note.youdao.com/s/dIRTiheA&#34;&gt;这篇文章&lt;/a&gt;
&amp;gt;阅读提醒：每一个&amp;lt;&amp;lt;&amp;gt;&amp;gt;中的序号后面都会扩展开讲&lt;/p&gt;

&lt;h4 id=&#34;1-清除老对象的弱引表&#34;&gt;1.清除老对象的弱引表&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;/** 
 * @param weak_table 某个对象的全局weak_table.
 * @param referent 当前对象
 * @param referrer 当前对象的弱引用地址
 */
void
weak_unregister_no_lock(weak_table_t *weak_table, id referent_id, 
                        id *referrer_id)
    objc_object *referent = (objc_object *)referent_id;
    objc_object **referrer = (objc_object **)referrer_id;//二级指针 weak_ptr的地址

    weak_entry_t *entry;

    if (!referent) return;
    //&amp;lt;&amp;lt;1.1&amp;gt;&amp;gt;查找referent对应的weak_entry_t
    if ((entry = weak_entry_for_referent(weak_table, referent))) {
        //&amp;lt;&amp;lt;1.2&amp;gt;&amp;gt;如果entry存在，删除entry
        remove_referrer(entry, referrer);
        bool empty = true;
        //判断entry的动态数组referrers中是否有值
        if (entry-&amp;gt;out_of_line()  &amp;amp;&amp;amp;  entry-&amp;gt;num_refs != 0) {
            empty = false;
        }
        else {
            //判断entry的定长数组inline_referrers中是否有值
            for (size_t i = 0; i &amp;lt; WEAK_INLINE_COUNT; i++) {
                if (entry-&amp;gt;inline_referrers[i]) {
                    empty = false; 
                    break;
                }
            }
        }
        //如果都是空的将entry从weak_table移除
        if (empty) {
            //&amp;lt;&amp;lt;1.3&amp;gt;&amp;gt;
            weak_entry_remove(weak_table, entry);
        }
    }

    // Do not set *referrer = nil. objc_storeWeak() requires that the 
    // value not change.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该方法的主要目的是清除存储在&lt;code&gt;entry&lt;/code&gt;中的&lt;code&gt;weak_referrer_t&lt;/code&gt;，如果发现&lt;code&gt;entry&lt;/code&gt;中一个&lt;code&gt;weak_referrer_t&lt;/code&gt;也没有，就将整个&lt;code&gt;entry&lt;/code&gt;从&lt;code&gt;weak_table&lt;/code&gt;中移除。&lt;/p&gt;

&lt;h5 id=&#34;1-1查找-referent-对应的-entry&#34;&gt;1.1查找&lt;code&gt;referent&lt;/code&gt;对应的&lt;code&gt;entry&lt;/code&gt;&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;* @param weak_table 对象的weak_table 
* @param referent 当前对象
static weak_entry_t *
weak_entry_for_referent(weak_table_t *weak_table, objc_object *referent)
{
    ASSERT(referent);

    weak_entry_t *weak_entries = weak_table-&amp;gt;weak_entries;

    if (!weak_entries) return nil;

    size_t begin = hash_pointer(referent) &amp;amp; weak_table-&amp;gt;mask;
    size_t index = begin;
    size_t hash_displacement = 0;
    while (weak_table-&amp;gt;weak_entries[index].referent != referent) {
        index = (index+1) &amp;amp; weak_table-&amp;gt;mask;
        if (index == begin) bad_weak_table(weak_table-&amp;gt;weak_entries);
        hash_displacement++;
        if (hash_displacement &amp;gt; weak_table-&amp;gt;max_hash_displacement) {
            return nil;
        }
    }
    
    return &amp;amp;weak_table-&amp;gt;weak_entries[index];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;size_t begin = hash_pointer(referent) &amp;amp; weak_table-&amp;gt;mask;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;通过指针的哈希方法生成的值与&lt;code&gt;weak_table-&amp;gt;mask&lt;/code&gt;进行&lt;a href=&#34;https://en.wikipedia.org/wiki/Mask_(computing)&#34;&gt;BITMASK&lt;/a&gt;操作得到一个起始值，这个等下会提一下。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;#if __LP64__
static inline uint32_t ptr_hash(uint64_t key)
{
    key ^= key &amp;gt;&amp;gt; 4;
    key *= 0x8a970be7488fda55;
    key ^= __builtin_bswap64(key);
    return (uint32_t)key;
}
#else
static inline uint32_t ptr_hash(uint32_t key)
{
    key ^= key &amp;gt;&amp;gt; 4;
    key *= 0x5052acdb;
    key ^= __builtin_bswap32(key);
    return key;
}
#endif

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;每次遍历如果没在&lt;code&gt;weak_entries&lt;/code&gt;中找到&lt;code&gt;referent&lt;/code&gt;就对index加1再进行BITMASK操作。遍历一次就认为是哈希冲突一次并记录在遍历&lt;code&gt;hash_displacement&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果哈希冲突超过了最大值返回nil，当前对象在&lt;code&gt;weak_table&lt;/code&gt;中不存在弱引用&lt;/li&gt;
&lt;li&gt;成功找到对应的&lt;code&gt;referent&lt;/code&gt;就返回相应的&lt;code&gt;weak_entry_t&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;简单说一下&lt;strong&gt;BITMASK&lt;/strong&gt;技术:&lt;/br&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;weak&lt;/code&gt;的实现中在对&lt;code&gt;weak_entry_t&lt;/code&gt;和&lt;code&gt;weak_referrer_t&lt;/code&gt;的遍历查找都是通过&lt;code&gt;BITMASK&lt;/code&gt;来实现的。个人猜测先经过一系列运算得到底位是表示数量的二进制数，在进行BITMASK操作。&lt;/p&gt;

&lt;p&gt;在日常开发中用的不多，主要是用于对二进制位进行操作。能快速的得到我们只关心位的值。&lt;/p&gt;

&lt;p&gt;|value|位操作|mask|结果|
|-|:-:|-|:-:|
|0x00000000|&amp;amp;|0x000000011|0|
|0x00000001|&amp;amp;|0x000000011|1|
|0x00000010|&amp;amp;|0x000000011|2|
|0x00000011|&amp;amp;|0x000000011|3|
|0x00000100|&amp;amp;|0x000000011|0|&lt;/p&gt;

&lt;p&gt;可以看到如果我们只关心低两位地址，进行BITMASK就能屏蔽其他位。所以上文中的&lt;code&gt;weak_table-&amp;gt;mask&lt;/code&gt;就是&lt;code&gt;weak_table_t&lt;/code&gt;中&lt;code&gt;weak_entry_t&lt;/code&gt;的最大容量减1（从0开始算）。从&lt;code&gt;static void weak_resize(weak_table_t *weak_table, size_t new_size)&lt;/code&gt;方法中可以看出&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...
weak_table-&amp;gt;mask = new_size - 1;
...
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;理解结构体-weak-entry-t&#34;&gt;理解结构体&lt;code&gt;weak_entry_t&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;在继续下去之前先看下这个结构体，要注意的是它里面有个联合体，联合体里面的两个结构体共享内存。而他们的区别在于，如果弱引用的数量不大于4个就有定长数组&lt;code&gt;inline_referrers&lt;/code&gt;，否则使用动态数组&lt;code&gt;referrers&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct weak_entry_t {
    DisguisedPtr&amp;lt;objc_object&amp;gt; referent;//弱引用对象
    union {//联合体，两种结构体共占有一块内存
        //弱引用数量大于4个用到的结构体
        struct {
            weak_referrer_t *referrers;
            uintptr_t        out_of_line_ness : 2;
            uintptr_t        num_refs : PTR_MINUS_2;
            uintptr_t        mask;
            uintptr_t        max_hash_displacement;
        };
        //弱引用数量不大于4个用到的结构体
        struct {
            // out_of_line_ness field is low bits of inline_referrers[1]
            weak_referrer_t  inline_referrers[WEAK_INLINE_COUNT];
        };
    };
    
    //判断是否是用的referrers来存储弱引用指针
    bool out_of_line() {
        return (out_of_line_ness == REFERRERS_OUT_OF_LINE);
    }
    //覆盖老数据
    weak_entry_t&amp;amp; operator=(const weak_entry_t&amp;amp; other) {
        memcpy(this, &amp;amp;other, sizeof(other));
        return *this;
    }
    //构造方法
    weak_entry_t(objc_object *newReferent, objc_object **newReferrer)
        : referent(newReferent)
    {
        inline_referrers[0] = newReferrer;
        for (int i = 1; i &amp;lt; WEAK_INLINE_COUNT; i++) {
            inline_referrers[i] = nil;
        }
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个里面存放了某个对象的所有弱引用指针，如果弱引用对象数量不超过四个就报错在结构体数组&lt;code&gt;inline_referrers&lt;/code&gt;，否则保存在&lt;code&gt;referrers&lt;/code&gt;&lt;/p&gt;

&lt;h5 id=&#34;1-2删除-entry-中的-referrer&#34;&gt;1.2删除 &lt;code&gt;entry&lt;/code&gt;中的&lt;code&gt;referrer&lt;/code&gt;&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;/** 
 * @param entry 当前对象对应的weak_entry_t
 * @param old_referrer 弱引用指针地址
 */
static void remove_referrer(weak_entry_t *entry, objc_object **old_referrer)
{
    if (! entry-&amp;gt;out_of_line()) {
        for (size_t i = 0; i &amp;lt; WEAK_INLINE_COUNT; i++) {
            if (entry-&amp;gt;inline_referrers[i] == old_referrer) {
                entry-&amp;gt;inline_referrers[i] = nil;
                return;
            }
        }
        _objc_inform(&amp;quot;Attempted to unregister unknown __weak variable &amp;quot;
                     &amp;quot;at %p. This is probably incorrect use of &amp;quot;
                     &amp;quot;objc_storeWeak() and objc_loadWeak(). &amp;quot;
                     &amp;quot;Break on objc_weak_error to debug.\n&amp;quot;, 
                     old_referrer);
        objc_weak_error();
        return;
    }

    size_t begin = w_hash_pointer(old_referrer) &amp;amp; (entry-&amp;gt;mask);
    size_t index = begin;
    size_t hash_displacement = 0;
    while (entry-&amp;gt;referrers[index] != old_referrer) {
        index = (index+1) &amp;amp; entry-&amp;gt;mask;
        if (index == begin) bad_weak_table(entry);
        hash_displacement++;
        if (hash_displacement &amp;gt; entry-&amp;gt;max_hash_displacement) {
            _objc_inform(&amp;quot;Attempted to unregister unknown __weak variable &amp;quot;
                         &amp;quot;at %p. This is probably incorrect use of &amp;quot;
                         &amp;quot;objc_storeWeak() and objc_loadWeak(). &amp;quot;
                         &amp;quot;Break on objc_weak_error to debug.\n&amp;quot;, 
                         old_referrer);
            objc_weak_error();
            return;
        }
    }
    entry-&amp;gt;referrers[index] = nil;
    entry-&amp;gt;num_refs--;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;如果定长数组&lt;code&gt;inline_referrers&lt;/code&gt;中有值且存在弱引用指针&lt;code&gt;old_referrer&lt;/code&gt;，设为nil&lt;/li&gt;
&lt;li&gt;如果动态数组&lt;code&gt;referrers&lt;/code&gt;中有值且存在弱引用指针&lt;code&gt;old_referrer&lt;/code&gt;，设为nil,并将引用数量-1&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;1-3-如果有必要删除对象的整个弱引用表&#34;&gt;1.3 如果有必要删除对象的整个弱引用表&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;**
 * Remove entry from the zone&#39;s table of weak references.
 */
static void weak_entry_remove(weak_table_t *weak_table, weak_entry_t *entry)
{
    // remove entry
    if (entry-&amp;gt;out_of_line()) free(entry-&amp;gt;referrers);
    bzero(entry, sizeof(*entry));

    weak_table-&amp;gt;num_entries--;

    weak_compact_maybe(weak_table);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;如果使用的是动态数组，释放动态数组的内存&lt;/li&gt;
&lt;li&gt;以&lt;code&gt;entry&lt;/code&gt;为起始地址的前&lt;code&gt;sizeof(*entry)&lt;/code&gt;个字节区域清零&lt;/li&gt;
&lt;li&gt;全局&lt;code&gt;weak_table&lt;/code&gt;中，弱引用对象数量-1&lt;/li&gt;

&lt;li&gt;&lt;p&gt;收缩表大小&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Shrink the table if it is mostly empty.
static void weak_compact_maybe(weak_table_t *weak_table)
{
size_t old_size = TABLE_SIZE(weak_table);

// Shrink if larger than 1024 buckets and at most 1/16 full.
if (old_size &amp;gt;= 1024  &amp;amp;&amp;amp; old_size / 16 &amp;gt;= weak_table-&amp;gt;num_entries) {
    weak_resize(weak_table, old_size / 8);
    // leaves new table no more than 1/2 full
}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果&lt;code&gt;weak_table&lt;/code&gt;内存占用超过&lt;strong&gt;1024&lt;/strong&gt;字节且内存的1/16比弱引用对象的数量还多就收缩表大小，使其不大于原来的&lt;strong&gt;&lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2&lt;/sub&gt;&lt;/strong&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Weak的实现（三）</title>
      <link>https://linkrober.github.io/bookshelf/2020/12/weak%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%89/</link>
      <pubDate>Tue, 08 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linkrober.github.io/bookshelf/2020/12/weak%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%89/</guid>
      <description>&lt;h4 id=&#34;3-设置弱引用标志位&#34;&gt;3 设置弱引用标志位&lt;/h4&gt;

&lt;p&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;inline void
objc_object::setWeaklyReferenced_nolock()
{
 retry:
    //去对象的isa指针
    isa_t oldisa = LoadExclusive(&amp;amp;isa.bits);
    isa_t newisa = oldisa;
    //如果不是non-pointer
    if (slowpath(!newisa.nonpointer)) {
        ClearExclusive(&amp;amp;isa.bits);
        //&amp;lt;&amp;lt;3.1&amp;gt;&amp;gt;
        sidetable_setWeaklyReferenced_nolock();
        return;
    }
    if (newisa.weakly_referenced) {
        ClearExclusive(&amp;amp;isa.bits);
        return;
    }
    //弱引用标志位设为1
    newisa.weakly_referenced = true;
    //如果oldisa.bits和newisa.bits不相等返回NO，继续tery里面的内容，这时候newisa.weakly_referenced已经是true了，所以return
    if (!StoreExclusive(&amp;amp;isa.bits, oldisa.bits, newisa.bits)) goto retry;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;设置nonpointer类型的isa和非nonpointer类型的isa的弱引用位为1&lt;/p&gt;

&lt;h5 id=&#34;3-1-设置nonpointer的isa指针的弱引用标志位&#34;&gt;3.1 设置nonpointer的isa指针的弱引用标志位&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;void 
objc_object::sidetable_setWeaklyReferenced_nolock()
{
#if SUPPORT_NONPOINTER_ISA
    ASSERT(!isa.nonpointer);
#endif

    SideTable&amp;amp; table = SideTables()[this];
    table.refcnts[this] |= SIDE_TABLE_WEAKLY_REFERENCED;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;RefcountMap&lt;/code&gt;，也是哈希表&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typedef objc::DenseMap&amp;lt;DisguisedPtr&amp;lt;objc_object&amp;gt;,size_t,RefcountMapValuePurgeable&amp;gt; RefcountMap;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;key是&lt;code&gt;DisguisedPtr&amp;lt;objc_object&amp;gt;&lt;/code&gt;即&lt;code&gt;weak_referrer_t&lt;/code&gt;，弱引用对象，value是&lt;code&gt;size_t&lt;/code&gt;，弱引用数量&lt;/p&gt;

&lt;p&gt;这里将&lt;code&gt;table.refcnts[this]&lt;/code&gt;即最后一位与SIDE_TABLE_WEAKLY_REFERENCED进行位或操作，这时候弱引用标志位变成&lt;strong&gt;1&lt;/strong&gt;。&lt;/p&gt;

&lt;h4 id=&#34;答题&#34;&gt;答题&lt;/h4&gt;

&lt;p&gt;问题1、2、3、5我们放在一起回答&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;大家都知道weak的底层实现是一个散列表，那么散列表的结构是什么样的？&lt;/li&gt;
&lt;li&gt;散列表的key是什么，value是什么，散列函数是怎样的？&lt;/li&gt;
&lt;li&gt;通过几次查找才能找到对应的弱引用？&lt;/li&gt;
&lt;li&gt;一个对象对应一个&lt;code&gt;SideTable&lt;/code&gt;表而一个&lt;code&gt;SideTable&lt;/code&gt;对应多个对象，为什么这样设计&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;大概的讲是一个散列表&lt;code&gt;SideTablesMap&lt;/code&gt;，以对象为&lt;code&gt;key&lt;/code&gt;,&lt;code&gt;SideTable&lt;/code&gt;为&lt;code&gt;value&lt;/code&gt;。散列函数是&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static unsigned int indexForPointer(const void *p) {
        uintptr_t addr = reinterpret_cast&amp;lt;uintptr_t&amp;gt;(p);
        return ((addr &amp;gt;&amp;gt; 4) ^ (addr &amp;gt;&amp;gt; 9)) % StripeCount;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但这只是开始，它取到的是很多对象弱引用表的集合。要想准确的找到某个对象的弱引位置用还要经过两步。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;以对象为key，经过一系列运算（位运算，算数运算），最后通过BITMASK找到&lt;code&gt;weak_entries&lt;/code&gt;的入口&lt;code&gt;index&lt;/code&gt;开始变量，判断对象是否相等。最后才能找到对象所在的&lt;code&gt;weak_entry_t&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;因为&lt;code&gt;weak_entry_t&lt;/code&gt;这里面保存了对象的所有有弱引用，要找到指定的，还要经历和上述类似的操作对比&lt;code&gt;old_referrer&lt;/code&gt;才能找到正真的弱引用&lt;code&gt;weak_referrer_t&lt;/code&gt;位置。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以经过3次查找才能找到正真的弱引用。&lt;/p&gt;

&lt;p&gt;为什么苹果要创建64个&lt;code&gt;SideTable&lt;/code&gt;（在iphone上是8个，其他上面是64个），而不是用一个SideTable解决呢。简单的类比，大家都在火车站或者飞机场打过出租车吧，当你前面的队伍黑压压的一片看不到头你是不是希望多开几个出租车上车点。使用多个&lt;code&gt;SideTable&lt;/code&gt;也是这个原理提高弱引用的索引速度。&lt;/p&gt;

&lt;p&gt;还有一点，我想提下，在整个过程中有两次扩容，一次收缩容量。它们都是动态的。分别是在
- &lt;code&gt;weak_unregister_no_lock&lt;/code&gt;的时候，收缩&lt;code&gt;weak_table_t&lt;/code&gt;的容量&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Shrink the table if it is mostly empty.
static void weak_compact_maybe(weak_table_t *weak_table)
{
    size_t old_size = TABLE_SIZE(weak_table);

    // Shrink if larger than 1024 buckets and at most 1/16 full.
    if (old_size &amp;gt;= 1024  &amp;amp;&amp;amp; old_size / 16 &amp;gt;= weak_table-&amp;gt;num_entries) {
        weak_resize(weak_table, old_size / 8);
        // leaves new table no more than 1/2 full
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;append_referrer&lt;/code&gt;的时候增加&lt;code&gt;weak_entry_t&lt;/code&gt;中动态数组&lt;code&gt;*referrers&lt;/code&gt;的容量&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;__attribute__((noinline, used))
static void grow_refs_and_insert(weak_entry_t *entry, 
                             objc_object **new_referrer)
{
ASSERT(entry-&amp;gt;out_of_line());

size_t old_size = TABLE_SIZE(entry);
size_t new_size = old_size ? old_size * 2 : 8;

size_t num_refs = entry-&amp;gt;num_refs;
weak_referrer_t *old_refs = entry-&amp;gt;referrers;
entry-&amp;gt;mask = new_size - 1;
    
entry-&amp;gt;referrers = (weak_referrer_t *)
    calloc(TABLE_SIZE(entry), sizeof(weak_referrer_t));
entry-&amp;gt;num_refs = 0;
entry-&amp;gt;max_hash_displacement = 0;
    
for (size_t i = 0; i &amp;lt; old_size &amp;amp;&amp;amp; num_refs &amp;gt; 0; i++) {
    if (old_refs[i] != nil) {
        append_referrer(entry, old_refs[i]);
        num_refs--;
    }
}
// Insert
append_referrer(entry, new_referrer);
if (old_refs) free(old_refs);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;weak_grow_maybe&lt;/code&gt;的时候,增加&lt;code&gt;weak_table_t&lt;/code&gt;的容量&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static void weak_grow_maybe(weak_table_t *weak_table)
{
size_t old_size = TABLE_SIZE(weak_table);

// Grow if at least 3/4 full.
if (weak_table-&amp;gt;num_entries &amp;gt;= old_size * 3 / 4) {
    weak_resize(weak_table, old_size ? old_size*2 : 64);
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;问题4&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;如何查找弱引用对象的引用计数？&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;uintptr_t
_objc_rootRetainCount(id obj)
{
    ASSERT(obj);

    return obj-&amp;gt;rootRetainCount();
}

inline uintptr_t 
objc_object::rootRetainCount()
{
    if (isTaggedPointer()) return (uintptr_t)this;

    sidetable_lock();
    //获取isa的比特位
    isa_t bits = LoadExclusive(&amp;amp;isa.bits);
    ClearExclusive(&amp;amp;isa.bits);
    //是不是non-pointer
    if (bits.nonpointer) {
        //引用比特位上的引用数加1
        uintptr_t rc = 1 + bits.extra_rc;
        if (bits.has_sidetable_rc) {
            //判断sidetable是否存在引用计数，如果存在继续相加
            rc += sidetable_getExtraRC_nolock();
        }
        sidetable_unlock();
        return rc;
    }

    sidetable_unlock();
    return sidetable_retainCount();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从&lt;code&gt;rootRetainCount&lt;/code&gt;源码可以看出，弱引用的引用计数分布在两个地方，一个是&lt;code&gt;isa&lt;/code&gt;的比特位中，还有一个在&lt;code&gt;SideTable&lt;/code&gt;中。它们相加才是对象的引用计数的数量。&lt;/p&gt;

&lt;p&gt;最后祭上Weak的类图和四层存储结构图，结构图中有获取对应层级所用到的算法
&lt;img src=&#34;https://note.youdao.com/yws/api/personal/file/WEBe05b83f81e4040473f0385979441c881?method=download&amp;amp;shareKey=028270cc018dcad1590865e61eb2624c&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;https://note.youdao.com/yws/api/personal/file/WEB97fdb40aae006524c1682b57022200cd?method=download&amp;amp;shareKey=ec82da0a1b701817110cc4a24494437a&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.jianshu.com/p/ef6d9bf8fe59&#34;&gt;iOS管理对象内存的数据结构以及操作算法&amp;ndash;SideTables、RefcountMap、weak_table_t-一
&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.leewong.cn/2020/08/16/sidetablestructure/&#34;&gt;SideTable结构
&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Weak的实现（二）</title>
      <link>https://linkrober.github.io/bookshelf/2020/12/weak%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%BA%8C/</link>
      <pubDate>Tue, 08 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linkrober.github.io/bookshelf/2020/12/weak%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%BA%8C/</guid>
      <description>&lt;h4 id=&#34;2-生成新的-weak-entry-t-插入到-weak-entries-中&#34;&gt;2 生成新的&lt;code&gt;weak_entry_t&lt;/code&gt;插入到&lt;code&gt;weak_entries&lt;/code&gt;中&lt;/h4&gt;

&lt;p&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/** 
 * Registers a new (object, weak pointer) pair. Creates a new weak
 * object entry if it does not exist.
 * 
 * @param weak_table The global weak table.弱引用全局表
 * @param referent The object pointed to by the weak reference. 弱引用对象
 * @param referrer The weak pointer address. 弱引用指针地址
 */
id 
weak_register_no_lock(weak_table_t *weak_table, id referent_id, 
                      id *referrer_id, bool crashIfDeallocating)
{
    objc_object *referent = (objc_object *)referent_id;
    objc_object **referrer = (objc_object **)referrer_id;

    if (!referent  ||  referent-&amp;gt;isTaggedPointer()) return referent_id;

    // ensure that the referenced object is viable
    // 判断对象是否正在释放或者是否支持弱引用
    bool deallocating;
    if (!referent-&amp;gt;ISA()-&amp;gt;hasCustomRR()) {
        deallocating = referent-&amp;gt;rootIsDeallocating();
    }
    else {
        BOOL (*allowsWeakReference)(objc_object *, SEL) = 
            (BOOL(*)(objc_object *, SEL))
            object_getMethodImplementation((id)referent, 
                                           @selector(allowsWeakReference));
        if ((IMP)allowsWeakReference == _objc_msgForward) {
            return nil;
        }
        deallocating =
            ! (*allowsWeakReference)(referent, @selector(allowsWeakReference));
    }

    if (deallocating) {
        if (crashIfDeallocating) {
            _objc_fatal(&amp;quot;Cannot form weak reference to instance (%p) of &amp;quot;
                        &amp;quot;class %s. It is possible that this object was &amp;quot;
                        &amp;quot;over-released, or is in the process of deallocation.&amp;quot;,
                        (void*)referent, object_getClassName((id)referent));
        } else {
            return nil;
        }
    }

    // now remember it and where it is being stored
    // 如果对象已经在weak_table中存在弱引用记录，就原来的entry上面追加
    weak_entry_t *entry;
    //&amp;lt;&amp;lt;1.1&amp;gt;&amp;gt;
    if ((entry = weak_entry_for_referent(weak_table, referent))) {
    //&amp;lt;&amp;lt;2.1&amp;gt;&amp;gt;
        append_referrer(entry, referrer);
    } 
    else {
        //创建新的entry，添加到weak_table中
        //&amp;lt;&amp;lt;2.2&amp;gt;&amp;gt;
        weak_entry_t new_entry(referent, referrer);
        //&amp;lt;&amp;lt;2.3&amp;gt;&amp;gt;
        weak_grow_maybe(weak_table);
        //&amp;lt;&amp;lt;2.4&amp;gt;&amp;gt;
        weak_entry_insert(weak_table, &amp;amp;new_entry);
    }

    // Do not set *referrer. objc_storeWeak() requires that the 
    // value not change.

    return referent_id;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;2-1-在-weak-entry-t-添加新的弱引用-weak-referrer-t&#34;&gt;2.1 在&lt;code&gt;weak_entry_t&lt;/code&gt;添加新的弱引用&lt;code&gt;weak_referrer_t&lt;/code&gt;&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;/** 
 * Add the given referrer to set of weak pointers in this entry.
 * Does not perform duplicate checking (b/c weak pointers are never
 * added to a set twice). 
 *
 * @param entry The entry holding the set of weak pointers. 某个类的弱引用表
 * @param new_referrer The new weak pointer to be added.新的弱引用
 */
static void append_referrer(weak_entry_t *entry, objc_object **new_referrer)
{
    //如果inline_referrers中还能存放weak_referrer_t就放在inline_referrers里面
    if (! entry-&amp;gt;out_of_line()) {
        // Try to insert inline.
        for (size_t i = 0; i &amp;lt; WEAK_INLINE_COUNT; i++) {
            if (entry-&amp;gt;inline_referrers[i] == nil) {
                entry-&amp;gt;inline_referrers[i] = new_referrer;
                return;
            }
        }

        // Couldn&#39;t insert inline. Allocate out of line.
        // 如果放不下了，就创建把所有的weak_referrer_t挪到referrers中
        weak_referrer_t *new_referrers = (weak_referrer_t *)
            calloc(WEAK_INLINE_COUNT, sizeof(weak_referrer_t));
        // This constructed table is invalid, but grow_refs_and_insert
        // will fix it and rehash it.
        for (size_t i = 0; i &amp;lt; WEAK_INLINE_COUNT; i++) {
            new_referrers[i] = entry-&amp;gt;inline_referrers[i];
        }
        entry-&amp;gt;referrers = new_referrers;
        entry-&amp;gt;num_refs = WEAK_INLINE_COUNT;
        entry-&amp;gt;out_of_line_ness = REFERRERS_OUT_OF_LINE;
        entry-&amp;gt;mask = WEAK_INLINE_COUNT-1;
        entry-&amp;gt;max_hash_displacement = 0;
    }

    ASSERT(entry-&amp;gt;out_of_line());
    // 如果引用数量超过表内存的3/4就自动扩容
    if (entry-&amp;gt;num_refs &amp;gt;= TABLE_SIZE(entry) * 3/4) {
        //&amp;lt;&amp;lt;2.1.1&amp;gt;&amp;gt;
        return grow_refs_and_insert(entry, new_referrer);
    }
    //在referrers中找到一个值为nil的weak_referrer_t对象，用新的弱引用对其赋值，并自增数量
    size_t begin = w_hash_pointer(new_referrer) &amp;amp; (entry-&amp;gt;mask);
    size_t index = begin;
    size_t hash_displacement = 0;
    while (entry-&amp;gt;referrers[index] != nil) {
        hash_displacement++;
        index = (index+1) &amp;amp; entry-&amp;gt;mask;
        if (index == begin) bad_weak_table(entry);
    }
    if (hash_displacement &amp;gt; entry-&amp;gt;max_hash_displacement) {
        entry-&amp;gt;max_hash_displacement = hash_displacement;
    }
    weak_referrer_t &amp;amp;ref = entry-&amp;gt;referrers[index];
    ref = new_referrer;
    entry-&amp;gt;num_refs++;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果&lt;code&gt;weak_table_t&lt;/code&gt;中存在当前对象的弱引用记录&lt;code&gt;weak_entry_t&lt;/code&gt;，使用该方法在&lt;code&gt;weak_entry_t&lt;/code&gt;添加新的&lt;code&gt;weak_referrer_t&lt;/code&gt;。
- 如果&lt;code&gt;weak_entry_t&lt;/code&gt;中的&lt;code&gt;weak_referrer_t&lt;/code&gt;数量不超过4个，即&lt;code&gt;weak_referrer_t&lt;/code&gt;用还保存在&lt;code&gt;inline_referrers&lt;/code&gt;中，就将其添加到&lt;code&gt;inline_referrers&lt;/code&gt;中；
- 如果刚好满4个，就将所有的&lt;code&gt;weak_referrer_t&lt;/code&gt;从定长数组&lt;code&gt;inline_referrers&lt;/code&gt;中取出，开辟新的空间，存储到动态数组&lt;code&gt;referrers&lt;/code&gt;中来记录引用
- 如果&lt;code&gt;weak_referrer_t&lt;/code&gt;的数量大于表内存大小的3/4，自动扩容&amp;lt;&lt;2.2.1&gt;&amp;gt;
- 在&lt;code&gt;referrers&lt;/code&gt;找到第一个为nil的&lt;code&gt;weak_referrer_t&lt;/code&gt;指针，新的&lt;code&gt;weak_referrer_t&lt;/code&gt;赋值给它，引用计数自增。&lt;/p&gt;

&lt;h5 id=&#34;2-1-1-增加某个对象弱引用表的容量&#34;&gt;2.1.1 增加某个对象弱引用表的容量&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;/** 
 * Grow the entry&#39;s hash table of referrers. Rehashes each
 * of the referrers.
 * 
 * @param entry Weak pointer hash set for a particular object.某个对象的弱引用表
 */
__attribute__((noinline, used))
static void grow_refs_and_insert(weak_entry_t *entry, 
                                 objc_object **new_referrer)
{
    ASSERT(entry-&amp;gt;out_of_line());
    //原来表大小
    size_t old_size = TABLE_SIZE(entry);
    //新表大小，old_size大于0，新size就变成原来大小的两倍，否则就8个字节大小
    size_t new_size = old_size ? old_size * 2 : 8;

    //原来的弱引用数量
    size_t num_refs = entry-&amp;gt;num_refs;
    //原来的弱引用数组
    weak_referrer_t *old_refs = entry-&amp;gt;referrers;
    //新的mask
    entry-&amp;gt;mask = new_size - 1;
    
    //重新分配entry的内存
    entry-&amp;gt;referrers = (weak_referrer_t *)
        calloc(TABLE_SIZE(entry), sizeof(weak_referrer_t));
    entry-&amp;gt;num_refs = 0;
    entry-&amp;gt;max_hash_displacement = 0;
    
    //先将老的引用全部插入到新的数组里面
    for (size_t i = 0; i &amp;lt; old_size &amp;amp;&amp;amp; num_refs &amp;gt; 0; i++) {
        if (old_refs[i] != nil) {
            //递归调用 插入weak_referrer_t
            append_referrer(entry, old_refs[i]);
            num_refs--;
        }
    }
    // Insert
    // 最后插入新加入的弱引用
    append_referrer(entry, new_referrer);
    if (old_refs) free(old_refs);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此方法重新定义了对象弱引用表&lt;code&gt;weak_entry_t&lt;/code&gt;的大小
1. 原来的表大小等于0，就分配8个字节
2. 如果原来表大小大于0，就分配原来大小2倍的字节
3. 然后为&lt;code&gt;referrers&lt;/code&gt;重新分配内存，先将老的&lt;code&gt;weak_entry_t&lt;/code&gt;迁移过去，再插入新的&lt;code&gt;weak_entry_t&lt;/code&gt;。通过递归调用&lt;code&gt;append_referrer&lt;/code&gt;实现插入数据&lt;/p&gt;

&lt;h5 id=&#34;2-2-创建新的-weak-entry-t&#34;&gt;2.2 创建新的&lt;code&gt;weak_entry_t&lt;/code&gt;&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;    weak_entry_t(objc_object *newReferent, objc_object **newReferrer)
        : referent(newReferent)
    {
        inline_referrers[0] = newReferrer;
        for (int i = 1; i &amp;lt; WEAK_INLINE_COUNT; i++) {
            inline_referrers[i] = nil;
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果对象还没有弱引用表&lt;code&gt;weak_entry_t&lt;/code&gt;就该对象建一个新的，从源码可看出&lt;code&gt;newReferrer&lt;/code&gt;先保存在&lt;code&gt;inline_referrers&lt;/code&gt;中&lt;/p&gt;

&lt;h5 id=&#34;2-3-weak-table-t-的扩容&#34;&gt;2.3 &lt;code&gt;weak_table_t&lt;/code&gt;的扩容&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;// Grow the given zone&#39;s table of weak references if it is full.
static void weak_grow_maybe(weak_table_t *weak_table)
{
    size_t old_size = TABLE_SIZE(weak_table);

    // Grow if at least 3/4 full.
    if (weak_table-&amp;gt;num_entries &amp;gt;= old_size * 3 / 4) {
        //&amp;lt;&amp;lt;2.3.1&amp;gt;&amp;gt;
        weak_resize(weak_table, old_size ? old_size*2 : 64);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果&lt;code&gt;weak_table&lt;/code&gt;中&lt;code&gt;num_entries&lt;/code&gt;数组的数量大于其内存大小的3/4就开始为&lt;code&gt;weak_table&lt;/code&gt;扩容
 - oldsize大于0，扩容为原来大小的两倍
 - 否则分配64字节&lt;/p&gt;

&lt;h5 id=&#34;2-3-1-weak-resize&#34;&gt;2.3.1 weak_resize&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;static void weak_resize(weak_table_t *weak_table, size_t new_size)
{
    size_t old_size = TABLE_SIZE(weak_table);

    weak_entry_t *old_entries = weak_table-&amp;gt;weak_entries;
    weak_entry_t *new_entries = (weak_entry_t *)
        calloc(new_size, sizeof(weak_entry_t));

    weak_table-&amp;gt;mask = new_size - 1;
    weak_table-&amp;gt;weak_entries = new_entries;
    weak_table-&amp;gt;max_hash_displacement = 0;
    weak_table-&amp;gt;num_entries = 0;  // restored by weak_entry_insert below
    
    if (old_entries) {
        weak_entry_t *entry;
        weak_entry_t *end = old_entries + old_size;
        for (entry = old_entries; entry &amp;lt; end; entry++) {
            if (entry-&amp;gt;referent) {
                //&amp;lt;&amp;lt;2.3.1.1&amp;gt;&amp;gt;
                weak_entry_insert(weak_table, entry);
            }
        }
        free(old_entries);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;创建新的指针数组&lt;code&gt;new_entries&lt;/code&gt;，分配新的大小&lt;/li&gt;
&lt;li&gt;遍历将老的数据迁移到新的数组中&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;2-3-1-1-向-weak-table-t-中插入-weak-entry-t&#34;&gt;2.3.1.1 向&lt;code&gt;weak_table_t&lt;/code&gt;中插入&lt;code&gt;weak_entry_t&lt;/code&gt;&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;/** 
 * Add new_entry to the object&#39;s table of weak references.
 * Does not check whether the referent is already in the table.
 */
static void weak_entry_insert(weak_table_t *weak_table, weak_entry_t *new_entry)
{
    weak_entry_t *weak_entries = weak_table-&amp;gt;weak_entries;
    ASSERT(weak_entries != nil);

    size_t begin = hash_pointer(new_entry-&amp;gt;referent) &amp;amp; (weak_table-&amp;gt;mask);
    size_t index = begin;
    size_t hash_displacement = 0;
    while (weak_entries[index].referent != nil) {
        index = (index+1) &amp;amp; weak_table-&amp;gt;mask;
        if (index == begin) bad_weak_table(weak_entries);
        hash_displacement++;
    }

    weak_entries[index] = *new_entry;
    weak_table-&amp;gt;num_entries++;

    if (hash_displacement &amp;gt; weak_table-&amp;gt;max_hash_displacement) {
        weak_table-&amp;gt;max_hash_displacement = hash_displacement;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还是通过BITMASK来遍历所有的&lt;code&gt;weak_entry_t&lt;/code&gt;，直到有一个&lt;code&gt;referent&lt;/code&gt;为nil,就将新的&lt;code&gt;weak_entry_t&lt;/code&gt;赋值给它。&lt;/p&gt;

&lt;h5 id=&#34;2-4-将对象的新-weak-entry-t-插入到-weak-table-t-中&#34;&gt;2.4 将对象的新&lt;code&gt;weak_entry_t&lt;/code&gt;插入到&lt;code&gt;weak_table_t&lt;/code&gt;中&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;/** 
 * Add new_entry to the object&#39;s table of weak references.
 * Does not check whether the referent is already in the table.
 */
static void weak_entry_insert(weak_table_t *weak_table, weak_entry_t *new_entry)
{
    weak_entry_t *weak_entries = weak_table-&amp;gt;weak_entries;
    ASSERT(weak_entries != nil);
    //遍历weak_entries，直到weak_entries[index].referent为nil
    size_t begin = hash_pointer(new_entry-&amp;gt;referent) &amp;amp; (weak_table-&amp;gt;mask);
    size_t index = begin;
    size_t hash_displacement = 0;
    while (weak_entries[index].referent != nil) {
        index = (index+1) &amp;amp; weak_table-&amp;gt;mask;
        if (index == begin) bad_weak_table(weak_entries);
        hash_displacement++;
    }
    //将新的数据赋值给referent为nil的指针
    weak_entries[index] = *new_entry;
    //weak_entry_t数量+1
    weak_table-&amp;gt;num_entries++;
    //更新max_hash_displacement
    if (hash_displacement &amp;gt; weak_table-&amp;gt;max_hash_displacement) {
        weak_table-&amp;gt;max_hash_displacement = hash_displacement;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;遍历&lt;code&gt;weak_table_t&lt;/code&gt;中的&lt;code&gt;weak_entries&lt;/code&gt;，直到有一个&lt;code&gt;weak_entry_t&lt;/code&gt;的为&lt;code&gt;referent&lt;/code&gt;为&lt;code&gt;nil&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;将新的&lt;code&gt;weak_entry_t&lt;/code&gt;赋值给&lt;code&gt;referent&lt;/code&gt;为&lt;code&gt;nil&lt;/code&gt;的&lt;code&gt;weak_entry_t&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;更新&lt;code&gt;num_entries&lt;/code&gt;和&lt;code&gt;max_hash_displacement&lt;/code&gt;的数量&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>CombineLatest、Zip和Merge的区别</title>
      <link>https://linkrober.github.io/bookshelf/2020/11/combinelatestzip%E5%92%8Cmerge%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Fri, 27 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linkrober.github.io/bookshelf/2020/11/combinelatestzip%E5%92%8Cmerge%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>&lt;h4 id=&#34;信号触发方式&#34;&gt;信号触发方式&lt;/h4&gt;

&lt;h5 id=&#34;merge&#34;&gt;merge&lt;/h5&gt;

&lt;p&gt;只要&lt;code&gt;merge&lt;/code&gt;之后生成的信号被订阅就会&lt;strong&gt;自动&lt;/strong&gt;触发所有压缩信号的订阅回调，如果靠前的信号出现了&lt;code&gt;error&lt;/code&gt;后面的信号不再发送。&lt;/p&gt;

&lt;p&gt;核心方法：&lt;code&gt;- (instancetype)flatten&lt;/code&gt;&lt;/br&gt;
值：多次收到，分开的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; 1
 2
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;RACSignal *s1 = [RACSignal createSignal:^RACDisposable *(id&amp;lt;RACSubscriber&amp;gt; subscriber) {
  [subscriber sendNext:@&amp;quot;1&amp;quot;];
    return nil;
}];

RACSignal *s2 = [RACSignal createSignal:^RACDisposable *(id&amp;lt;RACSubscriber&amp;gt; subscriber) {
    [subscriber sendNext:@&amp;quot;2&amp;quot;];
    return nil;
}];

[[RACSignal merge:@[s1,s2]] subscribeNext:^(id x) {
    NSLog(@&amp;quot;%@&amp;quot;,x);
}];

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h5 id=&#34;combinelatest&#34;&gt;combineLatest&lt;/h5&gt;

&lt;p&gt;必须等到&lt;strong&gt;所有&lt;/strong&gt;的信号都成功发送才能触发&lt;code&gt;combineLatest&lt;/code&gt;生成的新信号的订阅回调。如果中间出现有信号error或者complete，新信号将收不到回调。&lt;/p&gt;

&lt;p&gt;核心方法：
&lt;code&gt;+ (instancetype)join:(id&amp;lt;NSFastEnumeration&amp;gt;)streams block:(RACStream * (^)(id, id))block&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;- (RACSignal *)combineLatestWith:(RACSignal *)signal&lt;/code&gt;
&lt;/br&gt;&lt;/p&gt;

&lt;p&gt;值：一次收到，通过&lt;code&gt;RACTuple&lt;/code&gt;聚合的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;RACTuple: 0x60000318c780&amp;gt; (
    1,
    2
)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;RACSubject *s1 = [RACSubject subject];
[s1 subscribeNext:^(id x) {
    NSLog(@&amp;quot;%@&amp;quot;,x);
}];

RACSubject *s2 = [RACSubject subject];
[s2 subscribeNext:^(id x) {
    NSLog(@&amp;quot;%@&amp;quot;,x);
}];

[[RACSignal combineLatest:@[s1,s2]] subscribeNext:^(id x) {
    NSLog(@&amp;quot;%@&amp;quot;,x);
}];

[s1 sendNext:@&amp;quot;1&amp;quot;];
[s2 sendNext:@&amp;quot;2&amp;quot;];

&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;zip&#34;&gt;zip&lt;/h5&gt;

&lt;p&gt;必须等到&lt;strong&gt;所有&lt;/strong&gt;的信号都成功发送才能触发&lt;code&gt;zip&lt;/code&gt;生成的新信号的订阅回调(和&lt;code&gt;combineLatest&lt;/code&gt;类似)。如果中间出现有信号error或者complete，新信号将收不到回，和&lt;code&gt;combineLatest&lt;/code&gt;不同的是，同一时间返回多个信号的值只取第一个，而&lt;code&gt;combineLatest&lt;/code&gt;是取最新的值&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//zip
....
void (^sendNext)(void) = ^{
			@synchronized (selfValues) {
				if (selfValues.count == 0) return;
				if (otherValues.count == 0) return;
				//去数组第一个值
				RACTuple *tuple = [RACTuple tupleWithObjects:selfValues[0], otherValues[0], nil];
				[selfValues removeObjectAtIndex:0];
				[otherValues removeObjectAtIndex:0];

				[subscriber sendNext:tuple];
				sendCompletedIfNecessary();
			}
		};
....
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;//combineLatestWith
...
void (^sendNext)(void) = ^{
			@synchronized (disposable) {
				if (lastSelfValue == nil || lastOtherValue == nil) return;
				[subscriber sendNext:[RACTuple tupleWithObjects:lastSelfValue, lastOtherValue, nil]];
			}
		};
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;核心方法：
1. &lt;code&gt;+ (instancetype)join:(id&amp;lt;NSFastEnumeration&amp;gt;)streams block:(RACStream * (^)(id, id))block&lt;/code&gt;
2. &lt;code&gt;- (RACSignal *)zipWith:(RACSignal *)signal&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;值：一次收到，通过&lt;code&gt;RACTuple&lt;/code&gt;聚合的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; &amp;lt;RACTuple: 0x600002668e20&amp;gt; (
    1,
    2,
    3
)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;RACSignal *s1 = [RACSignal createSignal:^RACDisposable *(id&amp;lt;RACSubscriber&amp;gt; subscriber) {
   [subscriber sendNext:@&amp;quot;1&amp;quot;];
    return nil;
}];
RACSignal *s2 = [RACSignal createSignal:^RACDisposable *(id&amp;lt;RACSubscriber&amp;gt; subscriber) {
    [subscriber sendNext:@&amp;quot;2&amp;quot;];
    return nil;
}];
RACSignal *s3 = [RACSignal createSignal:^RACDisposable *(id&amp;lt;RACSubscriber&amp;gt; subscriber) {
    [subscriber sendNext:@&amp;quot;3&amp;quot;];
    return nil;
}];

RACSignal *zs = [RACSignal zip:@[s1,s2,s3]];

[zs subscribeNext:^(id x) {
    NSLog(@&amp;quot;%@&amp;quot;,x);
}];
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Connect、AutoConnect、RACReplaySubject、Replay</title>
      <link>https://linkrober.github.io/bookshelf/2020/11/connectautoconnectracreplaysubjectreplay/</link>
      <pubDate>Fri, 27 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linkrober.github.io/bookshelf/2020/11/connectautoconnectracreplaysubjectreplay/</guid>
      <description>&lt;h4 id=&#34;connect&#34;&gt;Connect&lt;/h4&gt;

&lt;p&gt;将冷信号包装成热信号，初始化冷信号，调用&lt;code&gt;publish&lt;/code&gt;方法会自动生成一个&lt;code&gt;RACMulticastConnection&lt;/code&gt;，该对象持有了原始信号和一个热信号。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (RACMulticastConnection *)publish {
	RACSubject *subject = [[RACSubject subject] setNameWithFormat:@&amp;quot;[%@] -publish&amp;quot;, self.name];
	RACMulticastConnection *connection = [self multicast:subject];
	return connection;
}
- (RACMulticastConnection *)multicast:(RACSubject *)subject {
	[subject setNameWithFormat:@&amp;quot;[%@] -multicast: %@&amp;quot;, self.name, subject.name];
	RACMulticastConnection *connection = [[RACMulticastConnection alloc] initWithSourceSignal:self subject:subject];
	return connection;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用&lt;code&gt;connect&lt;/code&gt;方法来触发订阅，注意调用一次触发一次。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (RACDisposable *)connect {
	BOOL shouldConnect = OSAtomicCompareAndSwap32Barrier(0, 1, &amp;amp;_hasConnected);

	if (shouldConnect) {
		self.serialDisposable.disposable = [self.sourceSignal subscribe:_signal];
	}

	return self.serialDisposable;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://note.youdao.com/yws/api/personal/file/WEB322c067dfd25b07390b5016979f95684?method=download&amp;amp;shareKey=18be9a0156c074ce3ed310a30cf3d782&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;autoconnect&#34;&gt;Autoconnect&lt;/h4&gt;

&lt;p&gt;在&lt;code&gt;publish&lt;/code&gt;之后，&lt;code&gt;RACMulticastConnection&lt;/code&gt;调用&lt;code&gt;autoconnect&lt;/code&gt;，生成一个信号，只有当生成的信号订阅之后才会触发其他订阅者开始接受订阅消息。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (RACSignal *)autoconnect {
	__block volatile int32_t subscriberCount = 0;

	return [[RACSignal
		createSignal:^(id&amp;lt;RACSubscriber&amp;gt; subscriber) {
			OSAtomicIncrement32Barrier(&amp;amp;subscriberCount);

			RACDisposable *subscriptionDisposable = [self.signal subscribe:subscriber];
			RACDisposable *connectionDisposable = [self connect];

			return [RACDisposable disposableWithBlock:^{
				[subscriptionDisposable dispose];

				if (OSAtomicDecrement32Barrier(&amp;amp;subscriberCount) == 0) {
					[connectionDisposable dispose];
				}
			}];
		}]
		setNameWithFormat:@&amp;quot;[%@] -autoconnect&amp;quot;, self.signal.name];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://note.youdao.com/yws/api/personal/file/WEBfd22a762ef7800a5d21b2fd823b26905?method=download&amp;amp;shareKey=0d72e57669a7945987449fb7dd3179f3&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;racmulticastconnection-racreplaysubject&#34;&gt;RACMulticastConnection &amp;amp; RACReplaySubject&lt;/h4&gt;

&lt;p&gt;上面在&lt;code&gt;connect&lt;/code&gt;之后的订阅者都不到订阅值，使用&lt;code&gt;RACReplaySubject&lt;/code&gt;可以让后面的订阅者也能收到订阅值。&lt;/p&gt;

&lt;p&gt;例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;RACSignal *sourceSignal = [RACSignal createSignal:^RACDisposable * _Nullable(id&amp;lt;RACSubscriber&amp;gt;  _Nonnull subscriber) {
    [subscriber sendNext:@{@&amp;quot;id&amp;quot;:@&amp;quot;1&amp;quot;}];
    return nil;
}];

RACMulticastConnection *connection = [sourceSignal multicast:[RACReplaySubject subject]];

[connection.signal subscribeNext:^(id  _Nullable x) {
    NSLog(@&amp;quot;product: %@&amp;quot;, x);
}];

[connection connect];

[connection.signal subscribeNext:^(id  _Nullable x) {
    NSNumber *productId = [x objectForKey:@&amp;quot;id&amp;quot;];
    NSLog(@&amp;quot;productId: %@&amp;quot;, productId);
}];

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://note.youdao.com/yws/api/personal/file/WEBeaf769304dcdeb50aedaf81ef877ce54?method=download&amp;amp;shareKey=825769b6f66cab9528c1aa2337763104&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;replay&#34;&gt;Replay&lt;/h4&gt;

&lt;p&gt;快速生成一个基于&lt;code&gt;RACReplaySubject&lt;/code&gt;创建的热信号。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (RACSignal *)replay {
	RACReplaySubject *subject = [[RACReplaySubject subject] setNameWithFormat:@&amp;quot;[%@] -replay&amp;quot;, self.name];

	RACMulticastConnection *connection = [self multicast:subject];
	[connection connect];

	return connection.signal;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;RACSignal *sourceSignal = [[RACSignal createSignal:^RACDisposable * _Nullable(id&amp;lt;RACSubscriber&amp;gt;  _Nonnull subscriber) {
        [subscriber sendNext:@{@&amp;quot;id&amp;quot;:@&amp;quot;1&amp;quot;}];
        return nil;
    }] replay];

    [sourceSignal subscribeNext:^(id  _Nullable x) {
        NSLog(@&amp;quot;product: %@&amp;quot;, x);
    }];

    [sourceSignal subscribeNext:^(id  _Nullable x) {
        NSNumber *productId = [x objectForKey:@&amp;quot;id&amp;quot;];
        NSLog(@&amp;quot;productId: %@&amp;quot;, productId);
    }];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://note.youdao.com/yws/api/personal/file/WEBdddd77c6ae072d234b09b7b5e6e3e17c?method=download&amp;amp;shareKey=35c80261e0e41092892c011b92cbb488&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>RACSignal</title>
      <link>https://linkrober.github.io/bookshelf/2020/11/racsignal/</link>
      <pubDate>Fri, 27 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linkrober.github.io/bookshelf/2020/11/racsignal/</guid>
      <description>&lt;h4 id=&#34;创建信号&#34;&gt;创建信号&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;
RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id&amp;lt;RACSubscriber&amp;gt; subscriber) {
        [subscriber sendNext:@&amp;quot;1&amp;quot;];
        return nil;
    }];

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分析&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//RACSignal.m
+ (RACSignal *)createSignal:(RACDisposable * (^)(id&amp;lt;RACSubscriber&amp;gt; subscriber))didSubscribe {
	return [RACDynamicSignal createSignal:didSubscribe];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;通过子类创建信号&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//RACDynamicSignal.m
+ (RACSignal *)createSignal:(RACDisposable * (^)(id&amp;lt;RACSubscriber&amp;gt; subscriber))didSubscribe {
	RACDynamicSignal *signal = [[self alloc] init];
	signal-&amp;gt;_didSubscribe = [didSubscribe copy];
	return [signal setNameWithFormat:@&amp;quot;+createSignal:&amp;quot;];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建一个RACDynamicSignal，将回调&lt;code&gt;didSubscribe&lt;/code&gt;保存在&lt;code&gt;_didSubscribe&lt;/code&gt;中。&lt;/p&gt;

&lt;h4 id=&#34;订阅信号&#34;&gt;订阅信号&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;[signal subscribeNext:^(id x) {
        
}];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分析&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock {
	NSCParameterAssert(nextBlock != NULL);
	
	RACSubscriber *o = [RACSubscriber subscriberWithNext:nextBlock error:NULL completed:NULL];
	return [self subscribe:o];
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建一个订阅者&lt;code&gt;RACSubscriber&lt;/code&gt;，将回调&lt;code&gt;nextBlock&lt;/code&gt;作为订阅者的初始入参，最后订阅RACSubscriber。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (RACDisposable *)subscribe:(id&amp;lt;RACSubscriber&amp;gt;)subscriber {
	NSCParameterAssert(subscriber != nil);
	//创建销毁对象，负责销毁信号
	RACCompoundDisposable *disposable = [RACCompoundDisposable compoundDisposable];
	//将RACSubscriber类型的订阅者转换成RACPassthroughSubscriber，为什么呢
	subscriber = [[RACPassthroughSubscriber alloc] initWithSubscriber:subscriber signal:self disposable:disposable];
	
	//创建自旋锁，防止资源竞争，懒加载订阅者集合(_subscribers),
	OSSpinLockLock(&amp;amp;_subscribersLock);
	if (_subscribers == nil) {
		_subscribers = [NSMutableArray arrayWithObject:subscriber];
	} else {
		[_subscribers addObject:subscriber];
	}
	OSSpinLockUnlock(&amp;amp;_subscribersLock);
	
	@weakify(self);
	//创建销毁对象（和上面的有什么不同？？？，看下面），当信号被销毁，从订阅者集合里面移除subscriber
	RACDisposable *defaultDisposable = [RACDisposable disposableWithBlock:^{
		@strongify(self);
		if (self == nil) return;

		BOOL stillHasSubscribers = YES;

		OSSpinLockLock(&amp;amp;_subscribersLock);
		{
			// Since newer subscribers are generally shorter-lived, search
			// starting from the end of the list.
			NSUInteger index = [_subscribers indexOfObjectWithOptions:NSEnumerationReverse passingTest:^ BOOL (id&amp;lt;RACSubscriber&amp;gt; obj, NSUInteger index, BOOL *stop) {
				return obj == subscriber;
			}];

			if (index != NSNotFound) {
				[_subscribers removeObjectAtIndex:index];
				stillHasSubscribers = _subscribers.count &amp;gt; 0;
			}
		}
		OSSpinLockUnlock(&amp;amp;_subscribersLock);
		
		if (!stillHasSubscribers) {
			[self invalidateGlobalRefIfNoNewSubscribersShowUp];
		}
	}];
	
	//将创建的销毁对象添加到一个管理类中
	[disposable addDisposable:defaultDisposable];

    //通过`didSubscribe`拿到订阅者对应的innerDisposable，添加到disposable中，
    //最后将schedulingDisposabl也添加到disposable中
	if (self.didSubscribe != NULL) {
		RACDisposable *schedulingDisposable = [RACScheduler.subscriptionScheduler schedule:^{
			RACDisposable *innerDisposable = self.didSubscribe(subscriber);
			[disposable addDisposable:innerDisposable];
		}];

		[disposable addDisposable:schedulingDisposable];
	}
	
	return disposable;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;信号被订阅之后的销毁流程。首先创建了一个销毁者管理类&lt;code&gt;disposable&lt;/code&gt;，以subscriber为入参生成一个新的subscriber（RACPassthroughSubscriber），老的订阅者和销毁者管理类都在这里面管理。
然后将&lt;code&gt;defaultDisposable&lt;/code&gt;、&lt;code&gt;innerDisposable&lt;/code&gt;、 &lt;code&gt;schedulingDisposable&lt;/code&gt;都放到管理类中进行管理&lt;/p&gt;

&lt;h4 id=&#34;问题&#34;&gt;问题&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;如何做到一订阅，就开始执行&lt;code&gt;[subscriber sendNext:xxx];&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;本质是调用了block。在创建的时候，block会被属性引用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;signal-&amp;gt;_didSubscribe = [didSubscribe copy];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在订阅方法的最后，调用代码块&lt;code&gt;didSubscribe&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	if (self.didSubscribe != NULL) {
		RACDisposable *schedulingDisposable = [RACScheduler.subscriptionScheduler schedule:^{
			RACDisposable *innerDisposable = self.didSubscribe(subscriber);
			[disposable addDisposable:innerDisposable];
		}];

		[disposable addDisposable:schedulingDisposable];
	}

&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>SwitchToLatest</title>
      <link>https://linkrober.github.io/bookshelf/2020/11/switchtolatest/</link>
      <pubDate>Fri, 27 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linkrober.github.io/bookshelf/2020/11/switchtolatest/</guid>
      <description>&lt;p&gt;&lt;code&gt;- (RACSignal *)switchToLatest&lt;/code&gt;和&lt;code&gt;- (RACSignal *)flatten&lt;/code&gt;的功能类似，都可以将信号中的信号的值取出来。不同的是，前者如果订阅者处理多个信号，只有最后一个信号的值能收到，之前的信号会被销毁。而后者则都能收到所有值。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;RACSignal *signal1 = [RACSignal createSignal:^RACDisposable *(id&amp;lt;RACSubscriber&amp;gt; subscriber) {
   
   
    [subscriber sendNext:@&amp;quot;nancy&amp;quot;];
    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
        
         [subscriber sendNext:@&amp;quot;botwen&amp;quot;];
    });
    return nil;
}];
    
RACSignal *signal2 = [RACSignal createSignal:^RACDisposable *(id&amp;lt;RACSubscriber&amp;gt; subscriber) {
    [subscriber sendNext:@&amp;quot;jiang&amp;quot;];
    
    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
         [subscriber sendNext:@&amp;quot;longjian&amp;quot;];
    });
    return nil;
}];
    
RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id&amp;lt;RACSubscriber&amp;gt;  _Nonnull subscriber) {
    [subscriber sendNext: signal1];
    [subscriber sendNext: signal2];
    [subscriber sendCompleted];
    
    return nil;
}];

RACSignal *newSignal = [signal switchToLatest];
[newSignal subscribeNext:^(id  _Nullable x) {
    NSLog(@&amp;quot;-=-=======-=%@&amp;quot;, x);
}];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-=-=======-=nancy
-=-=======-=jiang
-=-=======-=longjian
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;botwen&lt;/code&gt;没有输出，因为&lt;code&gt;signal1&lt;/code&gt;已经被销毁。
这里有一个难点，&lt;strong&gt;为什么&lt;code&gt;nancy&lt;/code&gt;输出了&lt;/strong&gt;。要知道原因，我们必须要清楚的理解整个信号的创建和销毁时机。&lt;/p&gt;

&lt;p&gt;原信号O通过&lt;code&gt;- (RACSignal *)switchToLatest&lt;/code&gt;方法生成了一个新信号A，当A被订阅时，O信号通过&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;RACMulticastConnection *connection = [self publish];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;生成了一个热信号，然后调用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (__kindof RACStream *)flattenMap:(__kindof RACStream * (^)(id value))block
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;来实现信号中信号的压平，这里和&lt;code&gt;- (__kindof RACStream *)flatten&lt;/code&gt;一样，最大的不同是&lt;code&gt;block&lt;/code&gt;的实现，在&lt;code&gt;- (RACSignal *)switchToLatest&lt;/code&gt;中，&lt;code&gt;block&lt;/code&gt;里面调用了&lt;code&gt;takeUntil&lt;/code&gt;方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;RACSignal *s = [connection.signal
flattenMap:^(RACSignal *x) {
    NSCAssert(x == nil || [x isKindOfClass:RACSignal.class], @&amp;quot;-switchToLatest requires that the source signal (%@) send signals. Instead we got: %@&amp;quot;, self, x);
    return [x takeUntil:[connection.signal concat:[RACSignal never]]];
}];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当信号&lt;code&gt;[connection.signal concat:[RACSignal never]]&lt;/code&gt;被&lt;strong&gt;订阅&lt;/strong&gt;的时候，通过&lt;code&gt;takeUntil&lt;/code&gt;生成的信号B会被销毁。这也是上面销毁&lt;code&gt;signal1&lt;/code&gt;的地方。&lt;/p&gt;

&lt;p&gt;那么在什么时机触发销毁动作呢？这里涉及到热信号。每个热信号都有一个订阅者的数组，当热信号受到订阅者发送的消息时，会遍历这个数组，一一调用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (void)enumerateSubscribersUsingBlock:(void (^)(id&amp;lt;RACSubscriber&amp;gt; subscriber))block {
	NSArray *subscribers;
	@synchronized (self.subscribers) {
		subscribers = [self.subscribers copy];
	}

	for (id&amp;lt;RACSubscriber&amp;gt; subscriber in subscribers) {
		block(subscriber);
	}
}

- (void)sendNext:(id)value {
	[self enumerateSubscribersUsingBlock:^(id&amp;lt;RACSubscriber&amp;gt; subscriber) {
		[subscriber sendNext:value];
	}];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实例代码里热信号的订阅者数组里面最多的时候一个有3个订阅者，下面列出添加订阅者数组的地方：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//[self subscribeNext:^(id x)...调用1次
RACDisposable *bindingDisposable = [self subscribeNext:^(id x) {
    // Manually check disposal to handle synchronous errors.
    if (compoundDisposable.disposed) return;

    BOOL stop = NO;
    id signal = bindingBlock(x, &amp;amp;stop);

    @autoreleasepool {
        if (signal != nil) addSignal(signal);
        if (signal == nil || stop) {
            [selfDisposable dispose];
            completeSignal(selfDisposable);
        }
    }
} error:^(NSError *error) {
    [compoundDisposable dispose];
    [subscriber sendError:error];
} completed:^{
    @autoreleasepool {
        completeSignal(selfDisposable);
    }
}];
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;//这里的[self subscribeNext:^(id x)...调用了2次，对应两次订阅者发送信号
- (RACSignal *)concat:(RACSignal *)signal {
	return [[RACSignal createSignal:^(id&amp;lt;RACSubscriber&amp;gt; subscriber) {
		RACCompoundDisposable *compoundDisposable = [[RACCompoundDisposable alloc] init];

		RACDisposable *sourceDisposable = [self subscribeNext:^(id x) {
			[subscriber sendNext:x];
		} error:^(NSError *error) {
			[subscriber sendError:error];
		} completed:^{
			RACDisposable *concattedDisposable = [signal subscribe:subscriber];
			[compoundDisposable addDisposable:concattedDisposable];
		}];

		[compoundDisposable addDisposable:sourceDisposable];
		return compoundDisposable;
	}] setNameWithFormat:@&amp;quot;[%@] -concat: %@&amp;quot;, self.name, signal];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一次为了压平信号调&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;subscribers = [subscriber1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第二次在&lt;code&gt;[subscriber sendNext: signal1];&lt;/code&gt;后调用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;subscribers = [subscriber1,subscriber2]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第三次在&lt;code&gt;[subscriber sendNext: signal2];&lt;/code&gt;后调用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;subscribers = [subscriber1,subscriber2,subscriber3]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在第三次调用&lt;code&gt;sendNext&lt;/code&gt;的时候会遍历订阅者数组（这时候数组里面还只有两个订阅者）发送信号从而走到&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...
RACCompoundDisposable *disposable = [RACCompoundDisposable compoundDisposable];
		void (^triggerCompletion)(void) = ^{
			[disposable dispose];
			[subscriber sendCompleted];
		};

		RACDisposable *triggerDisposable = [signalTrigger subscribeNext:^(id _) {
		    //走到这里
			triggerCompletion();
		} completed:^{
			triggerCompletion();
		}];
...

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将&lt;code&gt;signal1&lt;/code&gt;的订阅者销毁，以此类推。这也是为什么第一次两个信号的值都能收到的原因。&lt;/p&gt;

&lt;p&gt;到这里就是&lt;code&gt;SwitchToLatest&lt;/code&gt;的功能实现。&lt;/p&gt;

&lt;p&gt;难点；&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;理解&lt;code&gt;- (RACSignal *)takeUntil:(RACSignal *)signalTrigger&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;冷信号转换成热信号的实现&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>concat、catchTo、never、takeUntil</title>
      <link>https://linkrober.github.io/bookshelf/2020/11/concatcatchtonevertakeuntil/</link>
      <pubDate>Fri, 27 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linkrober.github.io/bookshelf/2020/11/concatcatchtonevertakeuntil/</guid>
      <description>&lt;ol&gt;
&lt;li&gt;&lt;code&gt;- (RACSignal *)concat:(RACSignal *)signal&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;//源码
- (RACSignal *)concat:(RACSignal *)signal {
	return [[RACSignal createSignal:^(id&amp;lt;RACSubscriber&amp;gt; subscriber) {
		RACSerialDisposable *serialDisposable = [[RACSerialDisposable alloc] init];

		RACDisposable *sourceDisposable = [self subscribeNext:^(id x) {
			[subscriber sendNext:x];
		} error:^(NSError *error) {
			[subscriber sendError:error];
		} completed:^{
			RACDisposable *concattedDisposable = [signal subscribe:subscriber];
			serialDisposable.disposable = concattedDisposable;
		}];

		serialDisposable.disposable = sourceDisposable;
		return serialDisposable;
	}] setNameWithFormat:@&amp;quot;[%@] -concat: %@&amp;quot;, self.name, signal];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;多个信号顺序输出，只有当前一个信号&lt;code&gt;sendCompleted&lt;/code&gt;后一个信号才会执行。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//eg.
RACSignal *s1 = [RACSignal createSignal:^RACDisposable *(id&amp;lt;RACSubscriber&amp;gt; subscriber) {
    [subscriber sendNext:@&amp;quot;1&amp;quot;];
    [subscriber sendCompleted];
    return nil;
}];

RACSignal *s2 = [RACSignal createSignal:^RACDisposable *(id&amp;lt;RACSubscriber&amp;gt; subscriber) {
    [subscriber sendNext:@&amp;quot;2&amp;quot;];
    return nil;
}];

[[s1 concat:s2] subscribeNext:^(id x) {
    NSLog(@&amp;quot;%@&amp;quot;,x);
}];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出：&lt;/p&gt;

&lt;p&gt;2020-07-06 17:39:06.542592+0800 C-41[3323:243230] 1 &lt;/br&gt;
2020-07-06 17:39:06.542817+0800 C-41[3323:243230] 2&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;- (RACSignal *)catchTo:(RACSignal *)signal&lt;/code&gt;
```
//源码&lt;/li&gt;
&lt;li&gt;(RACSignal *)catch:(RACSignal * (^)(NSError *error))catchBlock {
	NSCParameterAssert(catchBlock != NULL);&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;	return [[RACSignal createSignal:^(id&lt;RACSubscriber&gt; subscriber) {
		RACSerialDisposable *catchDisposable = [[RACSerialDisposable alloc] init];&lt;/p&gt;

&lt;p&gt;		RACDisposable *subscriptionDisposable = [self subscribeNext:^(id x) {
			[subscriber sendNext:x];
		} error:^(NSError *error) {
			RACSignal *signal = catchBlock(error);
			NSCAssert(signal != nil, @&amp;ldquo;Expected non-nil signal from catch block on %@&amp;rdquo;, self);
			catchDisposable.disposable = [signal subscribe:subscriber];
		} completed:^{
			[subscriber sendCompleted];
		}];&lt;/p&gt;

&lt;p&gt;		return [RACDisposable disposableWithBlock:^{
			[catchDisposable dispose];
			[subscriptionDisposable dispose];
		}];
	}] setNameWithFormat:@&amp;rdquo;[%@] -catch:&amp;ldquo;, self.name];
}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;当某个信号发生错误时`senderError`，将替补信号的值作为备选值。

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;//eg.
RACSignal *s1 = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {
    [subscriber sendError:nil];
    return nil;
}];&lt;/p&gt;

&lt;p&gt;RACSignal *s2 = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {
    [subscriber sendNext:@&amp;ldquo;替补队员跟上&amp;rdquo;];
    return nil;
}];&lt;/p&gt;

&lt;p&gt;[[s1 catchTo:s2] subscribeNext:^(id x) {
    NSLog(@&amp;ldquo;%@&amp;rdquo;,x);
}];&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;输出：

2020-07-06 17:48:06.347187+0800 C-41[3418:248921] 替补队员跟上


3. `+ (RACSignal *)never`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;//源码
+ (RACSignal *)never {
	return [[self createSignal:^ RACDisposable * (id&lt;RACSubscriber&gt; subscriber) {
		return nil;
	}] setNameWithFormat:@&amp;ldquo;+never&amp;rdquo;];
}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;订阅者永远收不到订阅值；没有错误；没有完成。



4. `- (RACSignal *)takeUntil:(RACSignal *)signalTrigger`

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;//源码
- (RACSignal *)takeUntil:(RACSignal *)signalTrigger {
	return [[RACSignal createSignal:^(id&lt;RACSubscriber&gt; subscriber) {
		RACCompoundDisposable *disposable = [RACCompoundDisposable compoundDisposable];
		void (^triggerCompletion)(void) = ^{
			[disposable dispose];
			[subscriber sendCompleted];
		};&lt;/p&gt;

&lt;p&gt;		RACDisposable *triggerDisposable = [signalTrigger subscribeNext:^(id _) {
			triggerCompletion();
		} completed:^{
			triggerCompletion();
		}];&lt;/p&gt;

&lt;p&gt;		[disposable addDisposable:triggerDisposable];&lt;/p&gt;

&lt;p&gt;		RACDisposable *selfDisposable = [self subscribeNext:^(id x) {
			[subscriber sendNext:x];
		} error:^(NSError *error) {
			[subscriber sendError:error];
		} completed:^{
			[disposable dispose];
			[subscriber sendCompleted];
		}];&lt;/p&gt;

&lt;p&gt;		[disposable addDisposable:selfDisposable];&lt;/p&gt;

&lt;p&gt;		return disposable;
	}] setNameWithFormat:@&amp;rdquo;[%@] -takeUntil: %@&amp;ldquo;, self.name, signalTrigger];
}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;正在进行的信号叫做A信号，遇到信号B被订阅就停止。
首先，通过A信号创建了一个中间信号A1。开始时对A信号进行了了订阅，并将值作为A1信号的输出。当B信号被订阅时，会触发A1信号的`sendCompleted`操作。这样无理A怎么发消息，A1都不会转发。

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;//eg.
RACSubject *untilSignal = [RACSubject subject];
RACSubject *afterUntilSignal = [RACSubject subject];&lt;/p&gt;

&lt;p&gt;[[afterUntilSignal takeUntil:untilSignal] subscribeNext:^(id x) {
    NSLog(@&amp;ldquo;%@&amp;rdquo;,x);
}];&lt;/p&gt;

&lt;p&gt;[untilSignal subscribeNext:^(id x) {
    NSLog(@&amp;ldquo;%@&amp;rdquo;,x);
}];&lt;/p&gt;

&lt;p&gt;[afterUntilSignal sendNext:@&amp;ldquo;1&amp;rdquo;];
[afterUntilSignal sendNext:@&amp;ldquo;2&amp;rdquo;];
[untilSignal sendNext:@&amp;ldquo;stop&amp;rdquo;];
[afterUntilSignal sendNext:@&amp;ldquo;3&amp;rdquo;];
```
输出&lt;/p&gt;

&lt;p&gt;2020-07-06 17:42:51.878488+0800 C-41[3354:245702] 1&lt;/br&gt;
2020-07-06 17:42:51.878642+0800 C-41[3354:245702] 2&lt;/br&gt;
2020-07-06 17:42:51.878854+0800 C-41[3354:245702] stop&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>zip</title>
      <link>https://linkrober.github.io/bookshelf/2020/11/zip/</link>
      <pubDate>Fri, 27 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linkrober.github.io/bookshelf/2020/11/zip/</guid>
      <description>&lt;pre&gt;&lt;code&gt;RACSignal *s1 = [RACSignal createSignal:^RACDisposable *(id&amp;lt;RACSubscriber&amp;gt; subscriber) {
       [subscriber sendNext:@&amp;quot;1&amp;quot;];
    return nil;
}];
RACSignal *s2 = [RACSignal createSignal:^RACDisposable *(id&amp;lt;RACSubscriber&amp;gt; subscriber) {
    [subscriber sendNext:@&amp;quot;2&amp;quot;];
    return nil;
}];
RACSignal *s3 = [RACSignal createSignal:^RACDisposable *(id&amp;lt;RACSubscriber&amp;gt; subscriber) {
    [subscriber sendNext:@&amp;quot;3&amp;quot;];
    return nil;
}];

RACSignal *zs = [RACSignal zip:@[s1,s2,s3]];

[zs subscribeNext:^(id x) {
    NSLog(@&amp;quot;%@&amp;quot;,x);
}];

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同&lt;code&gt;zip&lt;/code&gt;压缩的信号只有等所有的自信号都&lt;code&gt;sendNext&lt;/code&gt;之后才会执行订阅回调。&lt;/p&gt;

&lt;p&gt;问题：
1. 如何确保每个信号都发送完，才执行后压缩信号的订阅回调&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;答：
+ (instancetype)join:(id&amp;lt;NSFastEnumeration&amp;gt;)streams block:(RACStream * (^)(id, id))block {
    RACStream *current = nil;
	// Creates streams of successively larger tuples by combining the input
	// streams one-by-one.
	for (RACStream *stream in streams) {
		// For the first stream, just wrap its values in a RACTuple. That way,
		// if only one stream is given, the result is still a stream of tuples.
		if (current == nil) {
			current = [stream map:^(id x) {
				return RACTuplePack(x);
			}];

			continue;
		}

		current = block(current, stream);
	}
	    ....
	    ....
	    ....
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一次&lt;code&gt;map&lt;/code&gt;操作信号1会生成一个新信号new1，new1和信号2经过&lt;code&gt;block(current,stream)&lt;/code&gt;又生成一个新信号new2，以此类推。
这两种操作都会对原始信号进行订阅，如果接受不到请求就不会继续下去。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;信号是如何被压平的&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在发生zs的订阅之后，通过&lt;code&gt;RACTuplePack(x)&lt;/code&gt;，生成一个元组，然后不断循环，形成元组套值(元组+值)的形式&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;RACTuple: 0x60000236c720&amp;gt; (
    &amp;lt;RACTuple: 0x600002375d00&amp;gt; (1),
    2
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后通过递归算法将值从元组套元组的组合里一一提取出来，这样信号就压平了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NSMutableArray *values = [[NSMutableArray alloc] init];
while (xs != nil) {
    [values insertObject:xs.last ?: RACTupleNil.tupleNil atIndex:0];
	xs = (xs.count &amp;gt; 1 ? xs.first : nil);
}
return [RACTuple tupleWithObjectsFromArray:values];
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>信号中的信号-flatten</title>
      <link>https://linkrober.github.io/bookshelf/2020/11/%E4%BF%A1%E5%8F%B7%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7-flatten/</link>
      <pubDate>Fri, 27 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linkrober.github.io/bookshelf/2020/11/%E4%BF%A1%E5%8F%B7%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7-flatten/</guid>
      <description>&lt;pre&gt;&lt;code&gt;    RACSignal *targetSignal = [RACSignal createSignal:^RACDisposable *(id&amp;lt;RACSubscriber&amp;gt; subscriber) {
        [subscriber sendNext:@&amp;quot;1&amp;quot;];
        return nil;
    }];
    
    RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id&amp;lt;RACSubscriber&amp;gt; subscriber) {
    //发送一个信号
        [subscriber sendNext:targetSignal];
        return nil;
    }];
    
    RACSignal *flattenSignal = [signal flatten];
    [flattenSignal subscribeNext:^(id x) {
        NSLog(@&amp;quot;%@&amp;quot;,x);//1
    }];

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;[signal flatten]&lt;/code&gt;做了什么，可以看出最终返回的是一个信号，深入方法里面，进行了如下的方法调用&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;- (instancetype)flatten&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;- (instancetype)flattenMap:(RACStream * (^)(id value))block&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;- (RACSignal *)bind:(RACStreamBindBlock (^)(void))block&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最终：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;return [[RACSignal createSignal:^(id&amp;lt;RACSubscriber&amp;gt; subscriber) {....}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这个方法里面，首先对自己就行了订阅，于是执行了&lt;code&gt;[subscriber sendNext:targetSignal];&lt;/code&gt;然后两层回调，&lt;code&gt;bindingBlock(x,&amp;amp;stop)&lt;/code&gt;和&lt;code&gt;block(value)&lt;/code&gt;。返回信号&lt;code&gt;targetSignal&lt;/code&gt;。将信号作为&lt;code&gt;void (^addSignal)(RACSignal *) = ^(RACSignal *signal){}&lt;/code&gt;的入参，其实是在这里面执行&lt;code&gt;targetSignal&lt;/code&gt;订阅，得到了值&lt;strong&gt;1&lt;/strong&gt;，最后通过原来的&lt;code&gt;[subscriber sendNext:x];&lt;/code&gt;将值返回。&lt;/p&gt;

&lt;p&gt;这时候你可能想，这里只嵌套了一层信号，如果嵌套两层怎么处理。你可以类比成递归，将&lt;code&gt;RACSignal *flattenSignal = [signal flatten]&lt;/code&gt;作为递归中的一步，然后对层层信号进行&lt;code&gt;flatten&lt;/code&gt;操作，最后就能得到你想要的结果。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//三个信号
    RACSignal *signal1 = [RACSignal createSignal:^RACDisposable *(id&amp;lt;RACSubscriber&amp;gt; subscriber) {
        [subscriber sendNext:@&amp;quot;1&amp;quot;];
        return nil;
    }];
    
    RACSignal *signal2 = [RACSignal createSignal:^RACDisposable *(id&amp;lt;RACSubscriber&amp;gt; subscriber) {
        [subscriber sendNext:signal1];
        return nil;
    }];
    
    RACSignal *faltSignal2 = [signal2 flattenMap:^RACStream *(id value) {
        NSLog(@&amp;quot;&amp;quot;);
        return value;
    }];
    
    
    RACSignal *param3 = [RACSignal createSignal:^RACDisposable *(id&amp;lt;RACSubscriber&amp;gt; subscriber) {
        [subscriber sendNext:faltSignal2];
        return nil;
    }];
    
    RACSignal *flatSignal3 = [param3 flattenMap:^RACStream *(id value) {
        NSLog(@&amp;quot;&amp;quot;);
        return value;
    }];
    
    [flatSignal3 subscribeNext:^(id x) {
        NSLog(@&amp;quot;&amp;quot;);
    }];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后输出了1&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>冷信号和热信号构建触发流程</title>
      <link>https://linkrober.github.io/bookshelf/2020/11/%E5%86%B7%E4%BF%A1%E5%8F%B7%E5%92%8C%E7%83%AD%E4%BF%A1%E5%8F%B7%E6%9E%84%E5%BB%BA%E8%A7%A6%E5%8F%91%E6%B5%81%E7%A8%8B/</link>
      <pubDate>Fri, 27 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linkrober.github.io/bookshelf/2020/11/%E5%86%B7%E4%BF%A1%E5%8F%B7%E5%92%8C%E7%83%AD%E4%BF%A1%E5%8F%B7%E6%9E%84%E5%BB%BA%E8%A7%A6%E5%8F%91%E6%B5%81%E7%A8%8B/</guid>
      <description>&lt;p&gt;提到RAC就离不开冷热信号。在实际的开发中如果不理清两者的用法就会出问题。&lt;/p&gt;

&lt;p&gt;冷信号像专车，从你打车（订阅）开始，从出发地点（sendNext）发往你在的地方。它是一对一的，不会错过。&lt;/p&gt;

&lt;p&gt;热信号像公交车，在你等车（订阅）之前可能已经发车了（sendNext）；不仅你可以上，其他人也能上，它是一对多的；错过了这班车（假设只有一班）就没了。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//冷信号
    RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id&amp;lt;RACSubscriber&amp;gt; subscriber) {
        [subscriber sendNext:@1];
        return nil;
    }];

    [[RACScheduler mainThreadScheduler] afterDelay:1.1 schedule:^{
        [signal subscribeNext:^(id x) {
            NSLog(@&amp;quot;cold signal  recveive: %@&amp;quot;, x);
        }];
    }];
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;输出: cold signal  recveive: 1&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;//热信号
        RACMulticastConnection *connection =  [[RACSignal createSignal:^RACDisposable *(id&amp;lt;RACSubscriber&amp;gt; subscriber) {
            [subscriber sendNext:@1];
            return nil;
        }] publish];
        [connection connect];

        RACSignal *signal = connection.signal;

        [[RACScheduler mainThreadScheduler] afterDelay:1.1 schedule:^{
            [signal subscribeNext:^(id x) {
                NSLog(@&amp;quot;hot signal recveive: %@&amp;quot;, x);
            }];
        }];
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;没有输出，公交车比你早到了1.1s&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;冷信号转换成热信号经过了两步&lt;code&gt;[RACSignal publish]&lt;/code&gt;和&lt;code&gt;[RACMulticastConnection connect]&lt;/code&gt;，
第一步将信号&lt;code&gt;signal&lt;/code&gt;和&lt;code&gt;subject&lt;/code&gt;进行绑定，返回一个&lt;code&gt;RACMulticastConnection&lt;/code&gt;对象。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (RACMulticastConnection *)multicast:(RACSubject *)subject {
	[subject setNameWithFormat:@&amp;quot;[%@] -multicast: %@&amp;quot;, self.name, subject.name];
	RACMulticastConnection *connection = [[RACMulticastConnection alloc] initWithSourceSignal:self subject:subject];
	return connection;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第二步立即触发信号的订阅，公交车开始发车了&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (RACDisposable *)connect {
	BOOL shouldConnect = OSAtomicCompareAndSwap32Barrier(0, 1, &amp;amp;_hasConnected);

	if (shouldConnect) {
		self.serialDisposable.disposable = [self.sourceSignal subscribe:_signal];
	}

	return self.serialDisposable;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么&lt;code&gt;RACMulticastConnection&lt;/code&gt;是做什么的呢?
它将信号（Signal）和订阅（subject）包装，为一个或多个订阅者提供服务（一对多）。当信号存在潜在的副作用或者接受事件不超过1次（eg.&lt;code&gt;[subscriber sendNext:@1]&lt;/code&gt;）的时候使用它。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://note.youdao.com/yws/api/personal/file/WEBb47d084e7444069fc09c784160fa22be?method=download&amp;amp;shareKey=44e2ac121991c7bfe127a3f1b3539762&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>方法替换和Aspects</title>
      <link>https://linkrober.github.io/bookshelf/2020/11/%E6%96%B9%E6%B3%95%E6%9B%BF%E6%8D%A2%E5%92%8Caspects/</link>
      <pubDate>Thu, 26 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linkrober.github.io/bookshelf/2020/11/%E6%96%B9%E6%B3%95%E6%9B%BF%E6%8D%A2%E5%92%8Caspects/</guid>
      <description>&lt;h4 id=&#34;带着问题看文章&#34;&gt;带着问题看文章：&lt;/h4&gt;

&lt;p&gt;1.常规姿势的方法替换原理是什么&lt;/p&gt;

&lt;p&gt;2.&lt;code&gt;Aspects&lt;/code&gt;的方法替换原理是什么&lt;/p&gt;

&lt;p&gt;3.为什么这样下面的代码这样hook之后，所有的实例的&lt;code&gt;viewWillAppear:&lt;/code&gt;也被hook了&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[[UIViewController class] aspect_hookSelector:@selector(viewWillAppear:) withOptions:AspectPositionBefore usingBlock:^(){
        
} error:nil];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4.为什么&lt;code&gt;Aspect&lt;/code&gt;不能hook静态方法&lt;/p&gt;

&lt;p&gt;5.如果用先用Aspects hook了方法A，接着又用MethodSwizzle方法（下文有）对A进行了hook，两个hook都能执行吗？
&lt;/p&gt;

&lt;blockquote&gt;
&lt;h3 id=&#34;正文&#34;&gt;正文&lt;/h3&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;runtime&#34;&gt;&lt;code&gt;Runtime&lt;/code&gt;&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;void MethodSwizzle(Class c,SEL origSEL,SEL overrideSEL)
   {
       Method origMethod = class_getInstanceMethod(c, origSEL);
       Method overrideMethod= class_getInstanceMethod(c, overrideSEL);
       if(class_addMethod(c, origSEL, method_getImplementation(overrideMethod),method_getTypeEncoding(overrideMethod)))
       {
            //当前类不存在`origSEL`
            class_replaceMethod(c,overrideSEL, method_getImplementation(origMethod), method_getTypeEncoding(origMethod));
       } else  {
            method_exchangeImplementations(origMethod,overrideMethod);
       }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;1-method-class-getinstancemethod-class-cls-sel-sel&#34;&gt;1. &lt;code&gt;Method class_getInstanceMethod(Class cls, SEL sel)&lt;/code&gt;&lt;/h5&gt;

&lt;p&gt;从子类往父类递归查找Method&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static method_t *
getMethod_nolock(Class cls, SEL sel)
{
    method_t *m = nil;

    runtimeLock.assertLocked();

    // fixme nil cls?
    // fixme nil sel?

    assert(cls-&amp;gt;isRealized());

    while (cls  &amp;amp;&amp;amp;  ((m = getMethodNoSuper_nolock(cls, sel))) == nil) {
        cls = cls-&amp;gt;superclass;
    }

    return m;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;2-bool-class-addmethod-class-cls-sel-name-imp-imp-const-char-types&#34;&gt;2. &lt;code&gt;BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types)&lt;/code&gt;&lt;/h5&gt;

&lt;p&gt;为类添加新方法&lt;/p&gt;

&lt;p&gt;如果当前类已经有这个&lt;code&gt;selector&lt;/code&gt;，拿到该&lt;code&gt;selector&lt;/code&gt;的&lt;code&gt;IMP&lt;/code&gt;返回False；如果没有，或父类存在，会将这个方法的IMP指向新的IMP，返回True。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types)
{
    if (!cls) return NO;

    mutex_locker_t lock(runtimeLock);
    return ! addMethod(cls, name, imp, types ?: &amp;quot;&amp;quot;, NO);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;static IMP 
addMethod(Class cls, SEL name, IMP imp, const char *types, bool replace)
{
    IMP result = nil;

    runtimeLock.assertLocked();

    checkIsKnownClass(cls);
    
    assert(types);
    assert(cls-&amp;gt;isRealized());

    method_t *m;
    if ((m = getMethodNoSuper_nolock(cls, name))) {
        // already exists
        if (!replace) {
            result = m-&amp;gt;imp;
        } else {
            result = _method_setImplementation(cls, m, imp);
        }
    } else {
        // fixme optimize
        method_list_t *newlist;
        newlist = (method_list_t *)calloc(sizeof(*newlist), 1);
        newlist-&amp;gt;entsizeAndFlags = 
            (uint32_t)sizeof(method_t) | fixed_up_method_list;
        newlist-&amp;gt;count = 1;
        newlist-&amp;gt;first.name = name;
        newlist-&amp;gt;first.types = strdupIfMutable(types);
        newlist-&amp;gt;first.imp = imp;

        prepareMethodLists(cls, &amp;amp;newlist, 1, NO, NO);
        cls-&amp;gt;data()-&amp;gt;methods.attachLists(&amp;amp;newlist, 1);
        flushCaches(cls);

        result = nil;
    }

    return result;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;3-imp-class-replacemethod-class-cls-sel-name-imp-imp-const-char-types&#34;&gt;3. &lt;code&gt;IMP class_replaceMethod(Class cls, SEL name, IMP imp, const char *types)&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;改变当前类中某个&lt;code&gt;selector&lt;/code&gt;的&lt;code&gt;IMP&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;IMP 
class_replaceMethod(Class cls, SEL name, IMP imp, const char *types)
{
    if (!cls) return nil;

    mutex_locker_t lock(runtimeLock);
    return addMethod(cls, name, imp, types ?: &amp;quot;&amp;quot;, YES);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;static IMP _method_setImplementation(Class cls, method_t *m, IMP imp)
{
    runtimeLock.assertLocked();

    if (!m) return nil;
    if (!imp) return nil;

    IMP old = m-&amp;gt;imp;
    m-&amp;gt;imp = imp;

    // Cache updates are slow if cls is nil (i.e. unknown)
    // RR/AWZ updates are slow if cls is nil (i.e. unknown)
    // fixme build list of classes whose Methods are known externally?

    flushCaches(cls);

    updateCustomRR_AWZ(cls, m);

    return old;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;4-void-method-exchangeimplementations-method-m1-method-m2&#34;&gt;4. &lt;code&gt;void method_exchangeImplementations(Method m1, Method m2)&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;交换两个&lt;code&gt;Method&lt;/code&gt;的&lt;code&gt;IMP&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void method_exchangeImplementations(Method m1, Method m2)
{
    if (!m1  ||  !m2) return;

    mutex_locker_t lock(runtimeLock);

    IMP m1_imp = m1-&amp;gt;imp;
    m1-&amp;gt;imp = m2-&amp;gt;imp;
    m2-&amp;gt;imp = m1_imp;


    // RR/AWZ updates are slow because class is unknown
    // Cache updates are slow because class is unknown
    // fixme build list of classes whose Methods are known externally?

    flushCaches(nil);

    updateCustomRR_AWZ(nil, m1);
    updateCustomRR_AWZ(nil, m2);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;总结：&lt;/br&gt;
上面包含了方法交互的两种方式：
- 已经存在的要交换的方法，直接交换方法的&lt;code&gt;IMP&lt;/code&gt;指针
- 要交换的方法不存在，动态创建方法再交换方法的&lt;code&gt;IMP&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Tips:交换&lt;code&gt;Method&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;method_exchangeImplementations(class_getInstanceMethod(self, @selector(viewDidAppear:)),
                                   class_getInstanceMethod(self, @selector(ex_viewDidAppear:
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;aspects&#34;&gt;&lt;code&gt;Aspects&lt;/code&gt;&lt;/h4&gt;

&lt;h5 id=&#34;一-消息转发&#34;&gt;（一）消息转发&lt;/h5&gt;

&lt;p&gt;消息转发有3个阶段：
1. 当前对象动态添加方法来响应
2. 有备用对象能够响应该方法
3. 通过forwardInvocation方法来处理该方法&lt;/p&gt;

&lt;p&gt;阶段3最灵活，和原来的类耦合最少。&lt;code&gt;Aspects&lt;/code&gt;就是在这个阶段来做方法替换。它替换的是什么呢，就是&lt;code&gt;forwardInvocation&lt;/code&gt;的&lt;code&gt;IMP&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://note.youdao.com/yws/api/personal/file/WEB95b6876b75aa452319fef5a997016d55?method=download&amp;amp;shareKey=809104bf2daedc6e202304bd2e45d2e8&#34; alt=&#34;&#34; /&gt;
经过讨论应该是下面这样的流程
&lt;img src=&#34;https://note.youdao.com/yws/api/personal/file/WEB84716c5dcfa90f82f31dca71e6baf268?method=download&amp;amp;shareKey=476d1e7dc88416af4d492f8d9e541243&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Aspects会强制将你要hook的方法的&lt;code&gt;IMP&lt;/code&gt;指向&lt;code&gt;_objc_msgForward&lt;/code&gt;的&lt;code&gt;IMP&lt;/code&gt;，也就意味着你&lt;strong&gt;直接&lt;/strong&gt;走到了消息转发的最后一步。接着在新的&lt;code&gt;IMP&lt;/code&gt;： &lt;code&gt;__ASPECTS_ARE_BEING_CALLED__&lt;/code&gt; 里面做各种切面的hook，before、instead、after。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typedef NS_OPTIONS(NSUInteger, AspectOptions) {
    AspectPositionAfter   = 0,            /// Called after the original implementation (default)
    AspectPositionInstead = 1,            /// Will replace the original implementation.
    AspectPositionBefore  = 2,            /// Called before the original implementation.
    
    AspectOptionAutomaticRemoval = 1 &amp;lt;&amp;lt; 3 /// Will remove the hook after the first execution.
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;二-实例对象和类对象的hook&#34;&gt;（二）实例对象和类对象的Hook&lt;/h5&gt;

&lt;p&gt;类对象：&lt;br&gt;
直接将当前类对象&lt;code&gt;forwardInvocation&lt;/code&gt;的&lt;code&gt;IMP&lt;/code&gt;替换。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static void aspect_swizzleForwardInvocation(Class klass) {
    NSCParameterAssert(klass);
    // If there is no method, replace will act like class_addMethod.
    IMP originalImplementation = class_replaceMethod(klass, @selector(forwardInvocation:), (IMP)__ASPECTS_ARE_BEING_CALLED__, &amp;quot;v@:@&amp;quot;);
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实例对象：&lt;/br&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://note.youdao.com/yws/api/personal/file/WEBaab254928096c6f3850e8c5d74175e90?method=download&amp;amp;shareKey=f9ddd204eb6c299ad61feb797005dca4&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;1.动态创建当前类的子类，2.再将子类的&lt;code&gt;forwardInvocation&lt;/code&gt;进行替换，3.最后将类对象和原类&lt;code&gt;class&lt;/code&gt;方法的&lt;code&gt;IMP&lt;/code&gt;指向当前类的&lt;code&gt;class&lt;/code&gt;方法的&lt;code&gt;IMP&lt;/code&gt;,4.将当前类的&lt;code&gt;isa&lt;/code&gt;指向动态创建的类&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const char *subclassName = [className stringByAppendingString:AspectsSubclassSuffix].UTF8String;
Class subclass = objc_getClass(subclassName);
if (subclass == nil) {
		subclass = objc_allocateClassPair(baseClass, subclassName, 0);
		if (subclass == nil) {
            NSString *errrorDesc = [NSString stringWithFormat:@&amp;quot;objc_allocateClassPair failed to allocate class %s.&amp;quot;, subclassName];
            AspectError(AspectErrorFailedToAllocateClassPair, errrorDesc);
            return nil;
        }

		aspect_swizzleForwardInvocation(subclass);
		aspect_hookedGetClass(subclass, statedClass);
		aspect_hookedGetClass(object_getClass(subclass), statedClass);
		objc_registerClassPair(subclass);
	}
	//将self的isa指向动态创建的类
object_setClass(self, subclass);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样做能保证现有的方法能正常执行；对当前类结构的改动最小。在&lt;code&gt;remove&lt;/code&gt;的时候&lt;code&gt;isa&lt;/code&gt;指针指回来就好了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...
NSString *className = NSStringFromClass(klass);
        if ([className hasSuffix:AspectsSubclassSuffix]) {
            Class originalClass = NSClassFromString([className stringByReplacingOccurrencesOfString:AspectsSubclassSuffix withString:@&amp;quot;&amp;quot;]);
            NSCAssert(originalClass != nil, @&amp;quot;Original class must exist&amp;quot;);
            //将self的isa指向原来的类
            object_setClass(self, originalClass);
            AspectLog(@&amp;quot;Aspects: %@ has been restored.&amp;quot;, NSStringFromClass(originalClass));
            ...
        }
...
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;三-源码&#34;&gt;（三）源码&lt;/h5&gt;

&lt;h6 id=&#34;配置&#34;&gt;配置&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;static id aspect_add(id self, SEL selector, AspectOptions options, id block, NSError **error) {
    NSCParameterAssert(self);
    NSCParameterAssert(selector);
    NSCParameterAssert(block);

    __block AspectIdentifier *identifier = nil;
    
    ①aspect_performLocked(^{
        if (②aspect_isSelectorAllowedAndTrack(self, selector, options, error)) {
            ③AspectsContainer *aspectContainer = aspect_getContainerForObject(self, selector);
            identifier = [AspectIdentifier identifierWithSelector:selector object:self options:options block:block error:error];
            if (identifier) {
                ④[aspectContainer addAspect:identifier withOptions:options];

                // Modify the class to allow message interception.
                ⑤aspect_prepareClassAndHookSelector(self, selector, error);
            }
        }
    });
    return identifier;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;①-br&#34;&gt;①&lt;/br&gt;&lt;/h3&gt;

&lt;p&gt;对代码块加自旋锁&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static void aspect_performLocked(dispatch_block_t block) {
    static OSSpinLock aspect_lock = OS_SPINLOCK_INIT;
    OSSpinLockLock(&amp;amp;aspect_lock);
    block();
    OSSpinLockUnlock(&amp;amp;aspect_lock);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;②-br&#34;&gt;②&lt;/br&gt;&lt;/h3&gt;

&lt;p&gt;selector校验和tracker设置&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;黑名单校验，这些方法是无法被hook的，有&lt;code&gt;retain&lt;/code&gt;、&lt;code&gt;release&lt;/code&gt;、&lt;code&gt;autorelease&lt;/code&gt;、&lt;code&gt;forwardInvocation:&lt;/code&gt;、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Check against the blacklist.
NSString *selectorName = NSStringFromSelector(selector);
if ([disallowedSelectorList containsObject:selectorName]) {
    NSString *errorDescription = [NSString stringWithFormat:@&amp;quot;Selector %@ is blacklisted.&amp;quot;, selectorName];
    AspectError(AspectErrorSelectorBlacklisted, errorDescription);
    return NO;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;dealloc&lt;/code&gt;无法在&lt;code&gt;AspectPositionBefore&lt;/code&gt;情况下被hook；当前实例和类必须要都能响应要hook的方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;AspectOptions position = options&amp;amp;AspectPositionFilter;
if ([selectorName isEqualToString:@&amp;quot;dealloc&amp;quot;] &amp;amp;&amp;amp; position != AspectPositionBefore) {
    NSString *errorDesc = @&amp;quot;AspectPositionBefore is the only valid position when hooking dealloc.&amp;quot;;
    AspectError(AspectErrorSelectorDeallocPosition, errorDesc);
    return NO;
}
if (![self respondsToSelector:selector] &amp;amp;&amp;amp; ![self.class instancesRespondToSelector:selector]) {
    NSString *errorDesc = [NSString stringWithFormat:@&amp;quot;Unable to find selector -[%@ %@].&amp;quot;, NSStringFromClass(self.class), selectorName];
    AspectError(AspectErrorDoesNotRespondToSelector, errorDesc);
    return NO;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果是类对象，为该类及其继承体系上的所有类创建一个&lt;code&gt;AspectTracker&lt;/code&gt;，并保存到一个全局单例的可变字典中。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    currentClass = klass;
    AspectTracker *parentTracker = nil;
    do {
        AspectTracker *tracker = swizzledClassesDict[currentClass];
        if (!tracker) {
            tracker = [[AspectTracker alloc] initWithTrackedClass:currentClass parent:parentTracker];
            swizzledClassesDict[(id&amp;lt;NSCopying&amp;gt;)currentClass] = tracker;
        }
        [tracker.selectorNames addObject:selectorName];
        // All superclasses get marked as having a subclass that is modified.
        parentTracker = tracker;
    }while ((currentClass = class_getSuperclass(currentClass)));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;AspectTracker结构&lt;/code&gt;
&lt;img src=&#34;https://note.youdao.com/yws/api/personal/file/WEB715024449547b00293407b3d99066c57?method=download&amp;amp;shareKey=d84e9dd7fe1949030441cea5e1156e96&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;③-br&#34;&gt;③&lt;/br&gt;&lt;/h3&gt;

&lt;p&gt;通过runtime为当前类关联一个&lt;code&gt;AspectsContainer&lt;/code&gt;类型的属性。命名方式是&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//aspects__ + 方法名
eg:aspects__eat:andWater:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;AspectsContainer&lt;/code&gt;保存了被hook方法的三种切面数组
&lt;img src=&#34;https://note.youdao.com/yws/api/personal/file/WEB970471b0e4303ce3e0f095a4a2c92d93?method=download&amp;amp;shareKey=014892c4716701c7a5ed9026b33e33d1&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;数组里面的对象&lt;code&gt;AspectIdentifier&lt;/code&gt;包含了在进行所有切面操作所需的信息，原方法、切面block、切面block的签名、如何切以及原方法所属的类。
&lt;img src=&#34;https://note.youdao.com/yws/api/personal/file/WEB78a33ecad4ae519b1113d730103d4def?method=download&amp;amp;shareKey=49e5bfc2a4f7297a29964987ea9fa873&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在创建&lt;code&gt;AspectIdentifier&lt;/code&gt;对象的初始化方法里有两个校验逻辑，1. 方法签名的校验 2. 方法签名兼容性判断。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Aspects&lt;/code&gt;定义了一个结构和&lt;code&gt;NSGlobalBlock&lt;/code&gt;类似的结构体&lt;code&gt;_AspectBlock&lt;/code&gt;。我们的切面block(&lt;code&gt;NSGlobalBlock&lt;/code&gt;)会被强转为&lt;code&gt;_AspectBlock&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Block internals.
typedef NS_OPTIONS(int, AspectBlockFlags) {
	AspectBlockFlagsHasCopyDisposeHelpers = (1 &amp;lt;&amp;lt; 25),
	AspectBlockFlagsHasSignature          = (1 &amp;lt;&amp;lt; 30)
};
typedef struct _AspectBlock {
	__unused Class isa;
	AspectBlockFlags flags;
	__unused int reserved;
	void (__unused *invoke)(struct _AspectBlock *block, ...);
	struct {
		unsigned long int reserved;
		unsigned long int size;
		// requires AspectBlockFlagsHasCopyDisposeHelpers
		void (*copy)(void *dst, const void *src);
		void (*dispose)(const void *);
		// requires AspectBlockFlagsHasSignature
		const char *signature;
		const char *layout;
	} *descriptor;
	// imported variables
} *AspectBlockRef;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Block方法签名的校验有两步：
1. &lt;code&gt;!(layout-&amp;gt;flags &amp;amp; AspectBlockFlagsHasSignature)&lt;/code&gt;(这应该是flags的一个规则)，如果&lt;code&gt;layout-&amp;gt;flags&lt;/code&gt;的值是0，返回nil&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;AspectBlockRef layout = (__bridge void *)block;
	if (!(layout-&amp;gt;flags &amp;amp; AspectBlockFlagsHasSignature)) {
        NSString *description = [NSString stringWithFormat:@&amp;quot;The block %@ doesn&#39;t contain a type signature.&amp;quot;, block];
        AspectError(AspectErrorMissingBlockSignature, description);
        return nil;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;在&lt;code&gt;layout-&amp;gt;descriptor&lt;/code&gt;中是否存在&lt;code&gt;signature&lt;/code&gt;。&lt;code&gt;desc&lt;/code&gt;先向下偏移2个&lt;code&gt;unsigned long int&lt;/code&gt;大小，如果存在copy和dispose函数继续向下偏移2个&lt;code&gt;unsigned long int&lt;/code&gt;大小。这时候检查签名是否为空。
&lt;code&gt;
void *desc = layout-&amp;gt;descriptor;
	desc += 2 * sizeof(unsigned long int);
	if (layout-&amp;gt;flags &amp;amp; AspectBlockFlagsHasCopyDisposeHelpers) {
		desc += 2 * sizeof(void *);
}
	if (!desc) {
    NSString *description = [NSString stringWithFormat:@&amp;quot;The block %@ doesn&#39;t has a type signature.&amp;quot;, block];
    AspectError(AspectErrorMissingBlockSignature, description);
    return nil;
}
	const char *signature = (*(const char **)desc);
	return [NSMethodSignature signatureWithObjCTypes:signature];
&lt;/code&gt;
&lt;img src=&#34;https://lc-api-gold-cdn.xitu.io/3293f66aeb756e10eba7&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;方法签名兼容性判断，通过对比方法签名来实现。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static BOOL aspect_isCompatibleBlockSignature(NSMethodSignature *blockSignature, id object, SEL selector, NSError **error) {
    NSCParameterAssert(blockSignature);
    NSCParameterAssert(object);
    NSCParameterAssert(selector);

    BOOL signaturesMatch = YES;
    NSMethodSignature *methodSignature = [[object class] instanceMethodSignatureForSelector:selector];
    if (blockSignature.numberOfArguments &amp;gt; methodSignature.numberOfArguments) {
        signaturesMatch = NO;
    }else {
        if (blockSignature.numberOfArguments &amp;gt; 1) {
            const char *blockType = [blockSignature getArgumentTypeAtIndex:1];
            if (blockType[0] != &#39;@&#39;) {
                signaturesMatch = NO;
            }
        }
        // Argument 0 is self/block, argument 1 is SEL or id&amp;lt;AspectInfo&amp;gt;. We start comparing at argument 2.
        // The block can have less arguments than the method, that&#39;s ok.
        if (signaturesMatch) {
            for (NSUInteger idx = 2; idx &amp;lt; blockSignature.numberOfArguments; idx++) {
                const char *methodType = [methodSignature getArgumentTypeAtIndex:idx];
                const char *blockType = [blockSignature getArgumentTypeAtIndex:idx];
                // Only compare parameter, not the optional type data.
                if (!methodType || !blockType || methodType[0] != blockType[0]) {
                    signaturesMatch = NO; break;
                }
            }
        }
    }

    if (!signaturesMatch) {
        NSString *description = [NSString stringWithFormat:@&amp;quot;Blog signature %@ doesn&#39;t match %@.&amp;quot;, blockSignature, methodSignature];
        AspectError(AspectErrorIncompatibleBlockSignature, description);
        return NO;
    }
    return YES;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果方法签名个数不等返回NO；如果切面block的方法签名第1个参数（从第0个开始）的字符不是&lt;code&gt;@&lt;/code&gt;返回NO；如果切面block的方法签名和要替换方法的方法签名从第2个开始不能一一匹配返回NO。&lt;/p&gt;

&lt;h3 id=&#34;④-br&#34;&gt;④&lt;/br&gt;&lt;/h3&gt;

&lt;p&gt;将构建好的&lt;code&gt;AspectIdentifier&lt;/code&gt;，添加到类对应的&lt;code&gt;AspectsContainer&lt;/code&gt;中，调用Hook方法时要用。&lt;/p&gt;

&lt;h3 id=&#34;⑤-br&#34;&gt;⑤&lt;/br&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;static void aspect_prepareClassAndHookSelector(NSObject *self, SEL selector, NSError **error) {
    NSCParameterAssert(selector);
    Class klass = aspect_hookClass(self, error);
    Method targetMethod = class_getInstanceMethod(klass, selector);
    IMP targetMethodIMP = method_getImplementation(targetMethod);
    if (!aspect_isMsgForwardIMP(targetMethodIMP)) {
        // Make a method alias for the existing method implementation, it not already copied.
        const char *typeEncoding = method_getTypeEncoding(targetMethod);
        SEL aliasSelector = aspect_aliasForSelector(selector);
        if (![klass instancesRespondToSelector:aliasSelector]) {
            __unused BOOL addedAlias = class_addMethod(klass, aliasSelector, method_getImplementation(targetMethod), typeEncoding);
            NSCAssert(addedAlias, @&amp;quot;Original implementation for %@ is already copied to %@ on %@&amp;quot;, NSStringFromSelector(selector), NSStringFromSelector(aliasSelector), klass);
        }

        // We use forwardInvocation to hook in.
        class_replaceMethod(klass, selector, aspect_getMsgForwardIMP(self, selector), typeEncoding);
        AspectLog(@&amp;quot;Aspects: Installed hook for -[%@ %@].&amp;quot;, klass, NSStringFromSelector(selector));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里就是调整&lt;code&gt;IMP&lt;/code&gt;指针。下面这段代码主要有两个功能。
1. 将类的&lt;code&gt;forwardInvocation&lt;/code&gt;的&lt;code&gt;IMP&lt;/code&gt;指向自定义的&lt;code&gt;IMP&lt;/code&gt;。这里分四种情况，（一）已经hook过的类，指实例对象，当前类的前缀是&lt;code&gt;_Aspects_&lt;/code&gt;，直接返回。（二）类对象，上文已讨论过。（三）类对象和元类不是同一个类。（四）动态添加方法，上文也已讨论过。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//交换forwardInvocation IMP的代码
static NSString *const AspectsForwardInvocationSelectorName = @&amp;quot;__aspects_forwardInvocation:&amp;quot;;
static void aspect_swizzleForwardInvocation(Class klass) {
    NSCParameterAssert(klass);
    // If there is no method, replace will act like class_addMethod.
    IMP originalImplementation = class_replaceMethod(klass, @selector(forwardInvocation:), (IMP)__ASPECTS_ARE_BEING_CALLED__, &amp;quot;v@:@&amp;quot;);
    if (originalImplementation) {
        class_addMethod(klass, NSSelectorFromString(AspectsForwardInvocationSelectorName), originalImplementation, &amp;quot;v@:@&amp;quot;);
    }
    AspectLog(@&amp;quot;Aspects: %@ is now aspect aware.&amp;quot;, NSStringFromClass(klass));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.将要hook方法的&lt;code&gt;IMP&lt;/code&gt;指向&lt;code&gt;_objc_msgForward&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;到这里完成了所有的配置工作&lt;/p&gt;

&lt;h6 id=&#34;运行时&#34;&gt;运行时&lt;/h6&gt;

&lt;p&gt;直接上源码。&lt;/br&gt;
先拿实例对象和类对象的&lt;code&gt;AspectsContainer&lt;/code&gt;，可以为空。组装&lt;code&gt;AspectInfo&lt;/code&gt;。先执行所有的&lt;code&gt;beforeAspects&lt;/code&gt;切;接着如果存在&lt;code&gt;insteadAspects&lt;/code&gt;，执行install切面，否则执行原方法；最后执行&lt;code&gt;afterAspects&lt;/code&gt;切面。在每个切面执行的时候，实例对象和类对象的都要执行。如果有需要remove的切面都会加到&lt;code&gt;aspectsToRemove&lt;/code&gt;这个数组里面，最后以remove掉。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#pragma mark - Aspect Invoke Point

// This is a macro so we get a cleaner stack trace.
#define aspect_invoke(aspects, info) \
for (AspectIdentifier *aspect in aspects) {\
    [aspect invokeWithInfo:info];\
    if (aspect.options &amp;amp; AspectOptionAutomaticRemoval) { \
        aspectsToRemove = [aspectsToRemove?:@[] arrayByAddingObject:aspect]; \
    } \
}

// This is the swizzled forwardInvocation: method.
static void __ASPECTS_ARE_BEING_CALLED__(__unsafe_unretained NSObject *self, SEL selector, NSInvocation *invocation) {
    NSCParameterAssert(self);
    NSCParameterAssert(invocation);
    SEL originalSelector = invocation.selector;
	SEL aliasSelector = aspect_aliasForSelector(invocation.selector);
    invocation.selector = aliasSelector;
    AspectsContainer *objectContainer = objc_getAssociatedObject(self, aliasSelector);
    AspectsContainer *classContainer = aspect_getContainerForClass(object_getClass(self), aliasSelector);
    AspectInfo *info = [[AspectInfo alloc] initWithInstance:self invocation:invocation];
    NSArray *aspectsToRemove = nil;

    // Before hooks.
    aspect_invoke(classContainer.beforeAspects, info);
    aspect_invoke(objectContainer.beforeAspects, info);

    // Instead hooks.
    BOOL respondsToAlias = YES;
    if (objectContainer.insteadAspects.count || classContainer.insteadAspects.count) {
        aspect_invoke(classContainer.insteadAspects, info);
        aspect_invoke(objectContainer.insteadAspects, info);
    }else {
        Class klass = object_getClass(invocation.target);
        do {
            if ((respondsToAlias = [klass instancesRespondToSelector:aliasSelector])) {
                [invocation invoke];
                break;
            }
        }while (!respondsToAlias &amp;amp;&amp;amp; (klass = class_getSuperclass(klass)));
    }

    // After hooks.
    aspect_invoke(classContainer.afterAspects, info);
    aspect_invoke(objectContainer.afterAspects, info);

    // If no hooks are installed, call original implementation (usually to throw an exception)
    if (!respondsToAlias) {
        invocation.selector = originalSelector;
        SEL originalForwardInvocationSEL = NSSelectorFromString(AspectsForwardInvocationSelectorName);
        if ([self respondsToSelector:originalForwardInvocationSEL]) {
            ((void( *)(id, SEL, NSInvocation *))objc_msgSend)(self, originalForwardInvocationSEL, invocation);
        }else {
            [self doesNotRecognizeSelector:invocation.selector];
        }
    }

    // Remove any hooks that are queued for deregistration.
    [aspectsToRemove makeObjectsPerformSelector:@selector(remove)];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;到这里基本差不多了，还有两个地方没讲，切面Block调用实现&lt;code&gt;[aspect invokeWithInfo:info]&lt;/code&gt;和移除切面，有兴趣的可以看看。&lt;/p&gt;

&lt;p&gt;最后附上一张整体流程图
&lt;img src=&#34;https://note.youdao.com/yws/api/personal/file/WEB24a1a6c4e7c65ed963c9c65099042c69?method=download&amp;amp;shareKey=c4ea75a79f085b53d9d848ebd1b8543b&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h5 id=&#34;四-答题&#34;&gt;（四）答题&lt;/h5&gt;

&lt;p&gt;1、2上面基本都已经说清楚了，我们从3看起：&lt;/p&gt;

&lt;p&gt;3.为什么这样hook之后所有的实例方法也被hook了&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[[UIViewController class] aspect_hookSelector:@selector(viewWillAppear:) withOptions:AspectPositionBefore usingBlock:^(){
        
} error:nil];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;答：这里考察的是&lt;code&gt;isa&lt;/code&gt;的概念。实例对象调用方法的时候是在&lt;strong&gt;isa指针指向的对象&lt;/strong&gt;里的方法列表去找，而&lt;strong&gt;isa指针指向的对象&lt;/strong&gt;就是类对象，&lt;code&gt;Aspects&lt;/code&gt;改变的是类对象方法列表里方法的&lt;code&gt;IMP&lt;/code&gt;，所以无论那是实例调用了&lt;code&gt;viewWillAppear:&lt;/code&gt;都会被hook&lt;/p&gt;

&lt;p&gt;4.为什么&lt;code&gt;Aspect&lt;/code&gt;不能hook静态方法
答：这里考察的也是&lt;code&gt;isa&lt;/code&gt;的概念，可见&lt;code&gt;isa&lt;/code&gt;在runtime中的地位非常重要。因为类对象调用方法的时候是到元类中去查找，而我们并没有对元类的方法进行hook。&lt;/p&gt;

&lt;p&gt;5.如果用先用Aspects hook了方法A，接着又用MethodSwizzle对A进行了hook，两个hook都能执行吗？
答：先看这张图，以&lt;code&gt;viewDidAppear:&lt;/code&gt;为列&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://note.youdao.com/yws/api/personal/file/WEBbd552a8d0fd08c81bddf036c20023229?method=download&amp;amp;shareKey=c8ab8006d377bd96f97cd3bc38ca9d1b&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;viewDidAppear:&lt;/code&gt;的IMP先被指向了&lt;code&gt;forwardInvocatoin:&lt;/code&gt;，当用MethodSwizzle进行第二次hook的时候，原来想指向&lt;code&gt;viewDidAppear:&lt;/code&gt;正真的&lt;code&gt;IMP&lt;/code&gt;的指针其实指向了&lt;code&gt;forwardInvocatoin:&lt;/code&gt;，而&lt;code&gt;forwardInvocatoin:&lt;/code&gt;被&lt;code&gt;Aspects&lt;/code&gt;指向了自定义的&lt;code&gt;__ASPECTS_ARE_BEING_CALLED__&lt;/code&gt;。这时候当调用&lt;code&gt;km_viewDidAppear:&lt;/code&gt;的时候调用了&lt;code&gt;Aspects&lt;/code&gt;的消息转发。在执行原方法的时候执行的是&lt;code&gt;aspects__t_viewDidAppear:&lt;/code&gt;而不是当初动态添加的&lt;code&gt;aspects__viewDidAppear:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[self doesNotRecognizeSelector:invocation.selector];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以答案是用&lt;code&gt;MethodSwizzle&lt;/code&gt;hook的方法可以执行。&lt;code&gt;Aspects&lt;/code&gt;Hook的方法无法执行，已经无法拿到正确的&lt;code&gt;AspectsContainer&lt;/code&gt;，动态添加的属性名称class_getSuperclass不对（是基于&lt;code&gt;viewDidAppear&lt;/code&gt;创建的属性，而不是&lt;code&gt;km_viewDidAppear&lt;/code&gt;）了，最后崩溃了。&lt;/p&gt;

&lt;p&gt;但是&lt;code&gt;Aspects&lt;/code&gt;还给了你最后一次机会如果被hook的类里面实现了方法&lt;code&gt;__aspects_forwardInvocation&lt;/code&gt;还能挽救下崩溃的局面。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...
invocation.selector = originalSelector;
SEL originalForwardInvocationSEL = NSSelectorFromString(AspectsForwardInvocationSelectorName);
if ([self respondsToSelector:originalForwardInvocationSEL]) {
    ((void( *)(id, SEL, NSInvocation *))objc_msgSend)(self, originalForwardInvocationSEL, invocation);
}else {
    [self doesNotRecognizeSelector:invocation.selector];
}
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上的推断建立在当前类没有实现&lt;code&gt;viewDidAppear:&lt;/code&gt;的前提下。如果当前类实现了&lt;code&gt;viewDidAppear:&lt;/code&gt;MethodSwizzle拿到的就不是被交换过的IMP。这时候就可以形成闭环：&lt;code&gt;km_viewDidAppear:&lt;/code&gt;-&amp;gt;&lt;code&gt;viewDidAppear:(调用了[super viewDidAppear])&lt;/code&gt;-&amp;gt;&lt;code&gt;__ASPECTS_ARE_BEING_CALLED__&lt;/code&gt;-&amp;gt;&lt;code&gt;Aspects的hook方法&lt;/code&gt;&lt;/br&gt;
&lt;img src=&#34;https://note.youdao.com/yws/api/personal/file/WEBb7863bbb0e16ab705af8d7443bfead85?method=download&amp;amp;shareKey=3b736c680f87c3c52f724c4845dca10b&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h5 id=&#34;四-知识点&#34;&gt;（四）知识点：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;消息转发&lt;/li&gt;
&lt;li&gt;runtime的各种方法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;object_getClass(id _Nullable obj)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;class_isMetaClass(Class _Nullable cls)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;class_getSuperclass(Class _Nullable cls)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;class_getInstanceMethod(Class _Nullable cls, SEL _Nonnull name)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;class_addMethod(Class _Nullable cls, SEL _Nonnull name, IMP _Nonnull imp, const char * _Nullable types)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;method_getImplementation(Method _Nonnull m)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;method_getTypeEncoding(Method _Nonnull m)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;class_replaceMethod(Class _Nullable cls, SEL _Nonnull name, IMP _Nonnull imp, const char * _Nullable types)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;method_exchangeImplementations(Method _Nonnull m1, Method _Nonnull m2)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;object_setClass(id _Nullable obj, Class _Nonnull cls)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;isa指针&lt;/li&gt;
&lt;li&gt;block结构&lt;/li&gt;
&lt;li&gt;NSMethodSignature方法签名&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Object-C多线程总结</title>
      <link>https://linkrober.github.io/bookshelf/2018/05/object-c%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sun, 27 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://linkrober.github.io/bookshelf/2018/05/object-c%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93/</guid>
      <description>&lt;h3 id=&#34;目录&#34;&gt;目录&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;多线程概念&lt;/li&gt;
&lt;li&gt;NSOperation&lt;/li&gt;
&lt;li&gt;GCD(Grand Central Dispatch)&lt;/li&gt;
&lt;li&gt;NSThread&lt;/li&gt;
&lt;li&gt;资源竞争&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;多线程概念&#34;&gt;多线程概念&lt;/h3&gt;

&lt;p&gt;线程也叫轻量级进程，是程序执行流的最小单元。
线程组成：&lt;strong&gt;线程ID&lt;/strong&gt;、&lt;strong&gt;指令指针&lt;/strong&gt;、&lt;strong&gt;寄存器集合&lt;/strong&gt;、&lt;strong&gt;堆栈&lt;/strong&gt;。
线程是进程中的一个实体，是被系统独立调度和分派的基本单位。&lt;/p&gt;

&lt;p&gt;线程自己不拥有系统资源，只拥有一点在运行中必不可少的资源，但它可与同属于一个进程的其他线程共享进程所拥有的全部资源。一个线程可以创建和撤销另一个线程，同一进程中的多个线程之间可以并发执行。&lt;/p&gt;

&lt;p&gt;线程有就绪、阻塞和运行三种基本状态。&lt;br&gt;
&lt;strong&gt;就绪&lt;/strong&gt;：是指线程具备运行的所有条件，逻辑上可运行，在等待处理机。&lt;br&gt;
&lt;strong&gt;运行&lt;/strong&gt;：线程占有处理机正在运行&lt;br&gt;
&lt;strong&gt;阻塞&lt;/strong&gt;：线程在等一个事件（如信号量），逻辑上不可执行&lt;/p&gt;

&lt;p&gt;每一个程序都至少有一个线程，若程序只有一个线程，那就是程序本身。在单个程序中同时运行多个线程完成不同的工作，称为&lt;strong&gt;多线程&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;nsoperation&#34;&gt;NSOperation&lt;/h3&gt;

&lt;p&gt;因为&lt;code&gt;NSOperation&lt;/code&gt;是一个抽象类，我们不能直接使用它，我们一般使用系统定义好了的两个子类&lt;code&gt;NSInvocationOperation&lt;/code&gt;和&lt;code&gt;NSBlockOperation&lt;/code&gt;。尽管&lt;code&gt;NSOperation&lt;/code&gt;很抽象，但是它的实现很优雅，能让你安全的执行任务。&lt;/p&gt;

&lt;p&gt;它是一次性对象（single-shot object），一个任务执行结束了，就不能再次执行。我们通常将它添加到&lt;code&gt;NSOperationQueue&lt;/code&gt;来执行任务。&lt;code&gt;NSOperationQueue&lt;/code&gt;将任务放到其他线程或者直接调动&lt;code&gt;GCD&lt;/code&gt;来执行任务。如果你不想使用&lt;code&gt;NSOperationQueue&lt;/code&gt;可以直接通过&lt;code&gt;NSOperation&lt;/code&gt;的&lt;code&gt;start&lt;/code&gt;方法来执行。但是这样会给你的code带来更多的负担。如果执行的时候线程不在一个就绪状态就会引起异常(&lt;code&gt;NSOperation&lt;/code&gt;存在依赖)。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h4 id=&#34;nsblockoperation-nsinvocationoperation&#34;&gt;NSBlockOperation&amp;amp;NSInvocationOperation&lt;/h4&gt;

&lt;p&gt;添加任务&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//selector
- (nullable instancetype)initWithTarget:(id)target selector:(SEL)sel object:(nullable id)arg;
//block
+ (instancetype)blockOperationWithBlock:(void (^)(void))block;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;操作&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//开始执行任务
- (void)start
//可以取消线程操作对应方法
- (void)cancel
//添加依赖
- (void)addDependency:(NSOperation *)op
//移除依赖
- (void)removeDependency:(NSOperation *)op
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h4 id=&#34;nsoperationqueue&#34;&gt;NSOperationQueue&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;NSOperation&lt;/code&gt;的队列，通过设置并发数量来控制异步还是同步，属性为&lt;code&gt;maxConcurrentOperationCount&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;添加任务&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (void)addOperation:(NSOperation *)op;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;- (void)addOperations:(NSArray&amp;lt;NSOperation *&amp;gt; *)ops waitUntilFinished:(BOOL)wait API_AVAILABLE(macos(10.6), ios(4.0), watchos(2.0), tvos(9.0));
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;- (void)addOperationWithBlock:(void (^)(void))block API_AVAILABLE(macos(10.6), ios(4.0), watchos(2.0), tvos(9.0));

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;添加完之后会立即执行&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;取消任务&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (void)cancelAllOperations;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;等待&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (void)waitUntilAllOperationsAreFinished;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;会使当前线程（例如，主线程）忙等，直到所有任务完成&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;gcd-grand-central-dispatch&#34;&gt;GCD (Grand Central Dispatch)&lt;/h3&gt;

&lt;p&gt;GCD将语言特性、OC运行时和系统提供的优化结合在一起，充分发挥系统的多核特性。BSD子系统，Core Foundation和Cocoa API都是用了CGD来帮助iOS系统和App跑的更快、更高效、响应更及时。GCD在系统层面更好的协调了所有在run的App，使它们在系统资源的利用上达到了一个平衡。&lt;br&gt;&lt;/p&gt;

&lt;p&gt;当你使用Object-C的编译器编译你的App，所有的GCD对象都是Object-C对象。在RAC环境下，引用和释放也是自动管理的。在非ARC环境下需要手动管理。（dispatch_retain和 dispatch_release）&lt;/p&gt;

&lt;p&gt;&lt;code&gt;CGD&lt;/code&gt;每个任务都要放到一个队列中去执行，队列分两种串行队列和并行队列。任务也分两种同步和异步。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;串行队列&lt;/th&gt;
&lt;th&gt;并行队列&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;同步线程&lt;/td&gt;
&lt;td&gt;会阻塞当前线程；不会开辟新的线程；任务在当前的线程串行执行&lt;/td&gt;
&lt;td&gt;会阻塞当前线程；不会开辟新的线程；任务在当前的线程同步执行&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;异步线程&lt;/td&gt;
&lt;td&gt;不会阻塞当前线程；会开辟新的线程；任务在新的线程串行执行&lt;/td&gt;
&lt;td&gt;不会阻塞当前线程；会开辟新的线程；任务在新的线程异步执行&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h4 id=&#34;死锁&#34;&gt;死锁&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;dispatch_sync(dispatch_get_main_queue(), ^{
    NSLog(@&amp;quot;sync - %@&amp;quot;, [NSThread currentThread]);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为是同步任务，主线程停下，等待队列里的任务完成，因为队列是主队列，跑的是主线程，这时候主线程处于等待状态，就出现了互相等待的情况。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h4 id=&#34;dispatch-group&#34;&gt;dispatch_group&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;dispatch_group&lt;/code&gt;能够在一个&lt;code&gt;Queue&lt;/code&gt;的所有任务结束之后得到通知，执行相关代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    dispatch_group_t anchorGroup = dispatch_group_create();

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;dispatch_group_notify(anchorGroup, anchorQueue, ^{
        //刷新第一个cell
        @strongify(self);
        [self.tableView reloadRowsAtIndexPaths:@[[NSIndexPath indexPathForRow:0 inSection:0]] withRowAnimation:UITableViewRowAnimationFade];
    });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h4 id=&#34;dispatch-group-enter-dispatch-group-leave&#34;&gt;dispatch_group_enter&amp;amp;&amp;amp;dispatch_group_leave&lt;/h4&gt;

&lt;p&gt;当GCD的任务是异步的时候，如果想要在所有任务结束之后得到通知，就要在各个任务的前后加上&lt;code&gt;dispatch_group_enter&lt;/code&gt;和&lt;code&gt;dispatch_group_leave&lt;/code&gt;。他们需要传入&lt;code&gt;group&lt;/code&gt;作为参数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dispatch_group_enter(anchorGroup);
    dispatch_async(anchorQueue, ^{
        [[XYLeaderboardService share] anchorCharmLeaderboard:XYLeaderboardCharmMonthType succeed:^(NSArray&amp;lt;XYLeaderboardItem *&amp;gt; *items) {
            @strongify(self);
            [self.datasource firstObject].secondLeaderboard = items;
            dispatch_group_leave(anchorGroup);
        } failure:^(XYNetError *error) {
            //
            dispatch_group_leave(anchorGroup);
        }];
    });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h4 id=&#34;dispatch-barrier-async-dispatch-queue-t-queue-dispatch-block-t-block&#34;&gt;dispatch_barrier_async(dispatch_queue_t queue, dispatch_block_t block);&lt;/h4&gt;

&lt;p&gt;等待queue中的任务全部结束，异步执行block中的任务&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h4 id=&#34;dispatch-barrier-sync-dispatch-queue-t-queue-dispatch-noescape-dispatch-block-t-block&#34;&gt;dispatch_barrier_sync(dispatch_queue_t queue,DISPATCH_NOESCAPE dispatch_block_t block);&lt;/h4&gt;

&lt;p&gt;等待queue中的任务全部结束，同步执行block中的任务&lt;/p&gt;

&lt;h3 id=&#34;nsthread&#34;&gt;NSThread&lt;/h3&gt;

&lt;p&gt;在执行一个长任务的时候比较有优势，其他的和&lt;code&gt;NSOperation&lt;/code&gt;比较像。&lt;/p&gt;

&lt;h4 id=&#34;创建nsthread&#34;&gt;创建NSThread&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;NSThread *thread = [[NSThread alloc] initWithBlock:^{

    }];
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;NSThread *thread = [[NSThread alloc] initWithTarget:&amp;lt;#(nonnull id)#&amp;gt; selector:&amp;lt;#(nonnull SEL)#&amp;gt; object:&amp;lt;#(nullable id)#&amp;gt;];

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;运行nsthread&#34;&gt;运行NSThread&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;NSThread *thread = [[NSThread alloc] initWithBlock:^{
        NSLog(@&amp;quot;thread测试%@&amp;quot;,[NSThread currentThread]);
    }];
    [thread start];

//直接运行
[NSThread detachNewThreadWithBlock:^{
        NSLog(@&amp;quot;thrad直接执行%@&amp;quot;,[NSThread currentThread]);
    }];
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;停止nsthread&#34;&gt;停止NSThread&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;//退出当前线程
[NSThread exit];
//取消该线程
NSThread *thread = [[NSThread alloc] initWithBlock:^{
        NSLog(@&amp;quot;thread测试%@&amp;quot;,[NSThread currentThread]);
    }];
[thread cancel];

//阻塞当前线程直到某个时间
[NSThread sleepUntilDate:&amp;lt;#(nonnull NSDate *)#&amp;gt;];

//使当前线程沉睡多少时间
NSLog(@&amp;quot;===============start sleep================&amp;quot;);
[NSThread sleepForTimeInterval:5];
NSLog(@&amp;quot;==============end sleep=================&amp;quot;);

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;检测当前nsthread的状态&#34;&gt;检测当前NSThread的状态&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;//是否正在执行
[thread isExecuting];
//是否完成
[thread isFinished];
//是否被取消
[thread isCancelled];
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;priority&#34;&gt;Priority&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;//设置当前线程的优先级
[NSThread setThreadPriority:&amp;lt;#(double)#&amp;gt;];
//查看当前线程的优先级
[NSThread threadPriority];
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;资源竞争&#34;&gt;资源竞争&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://linkrober.github.io/bookshelf/2017/12/ios%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD%E7%9A%84%E9%94%81/&#34;&gt;iOS多线程中的锁&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>入坑小程序</title>
      <link>https://linkrober.github.io/bookshelf/2018/03/%E5%85%A5%E5%9D%91%E5%B0%8F%E7%A8%8B%E5%BA%8F/</link>
      <pubDate>Sun, 25 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://linkrober.github.io/bookshelf/2018/03/%E5%85%A5%E5%9D%91%E5%B0%8F%E7%A8%8B%E5%BA%8F/</guid>
      <description>&lt;h3 id=&#34;描述&#34;&gt;描述&lt;/h3&gt;

&lt;p&gt;去年各大平台纷纷开始占领微信上的又一流量入口——小程序。因为小程序的门槛低，这里指，技术上和前端大同小异，审核刚开始也比较松。除了大厂，很多个人开发这都投入进去。想在小程序上打响自己的个人品牌。在筹备了三个月之久，我的第一款小程序，终于快要完成了。在这里我会总结一下整体的过程，从idea到一个完整的小程序、期间遇到的坑、和觉得挺有意思的地方。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;流程&#34;&gt;流程&lt;/h3&gt;

&lt;p&gt;&lt;br /&gt;
1. 购买服务器
    本人购买的服务器是阿里云服务器，因为经历的几家公司都是用的它，感觉还是比较靠谱的（我一同事也用过腾讯的服务，一直在吐槽不稳定，后来也换到阿里云了)&lt;/p&gt;

&lt;p&gt;&lt;/br&gt;
2. 购买域名
    小程序的是无法直接通过IP访问，必须申请一个域名，同样的阿里云上买就行了。这里要提醒大家的是，因为国家政策原因域名需要备案，整个过程大概需要一个月时间。阿里云还是比较良心的，备案成功之后会再赠送你一个月的服务器时间。因为整个备案时间大概是一个月。所有绑定域名一定要提前。&lt;/p&gt;

&lt;p&gt;&lt;/br&gt;
3. 申请CA证书绑定到域名。在小程序里的API都需要Htps服务，如果你有CA证书可以直接使用，我也是通过阿里云申请的免费CA证书，时间是一年，到期看可以续的。&lt;/p&gt;

&lt;p&gt;&lt;/br&gt;
4. 根据idea设计产品&lt;/p&gt;

&lt;p&gt;&lt;/br&gt;
5. 开发小程序和server&lt;/p&gt;

&lt;p&gt;&lt;/br&gt;
6.发布&lt;/p&gt;

&lt;h3 id=&#34;小程序&#34;&gt;小程序&lt;/h3&gt;

&lt;p&gt;因为是我的第一个小程序，先试试手，所以选了一个比较简单的东西，音乐欣赏。数据是从其他网站爬过来插到数据库的。
本人是移动端出生，对前端和后端的东西都不是很熟，不过刚好去年写了不少RN的东西，前端的东西也算是半只脚入门了。在小程序里面文件分为下面几种&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;js文件，和前端的一样，&lt;/li&gt;
&lt;li&gt;wxml文件，类似于html文件&lt;/li&gt;
&lt;li&gt;wxss文件，类似于css文件&lt;/li&gt;
&lt;li&gt;wxs文件，这是小程序的一套脚本语言，语法看似和JavaScript语法一样，其实他们是不同的语言，有自己的语法，并不和 javascript 一致    。我们可以把它当做方法类在wxml中来使用。在wxml中是无法调用js中的非事件方法的，如果从js文件里拿到的数据你希望再做一步处理然后展示，这样的处理需要放到wxs文件里。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;开发前花半天浏览下微信小程序的API差不多就可以了，套路都差不多MVC。&lt;/p&gt;

&lt;h3 id=&#34;数据库&#34;&gt;数据库&lt;/h3&gt;

&lt;p&gt;服务器是用Node.js+MongoDB+Express搭建的，全套搭建起来还是很快的。Node.js是一个基于事件驱动I/O的服务端JavaScript环境，它在高并发的服务上有很好的体验。同样是js所以语法基本没门槛了。
MongoDB数据库和一般的关系型数据库不同，它是非关系型数据库。关系型数据库对数据操作都是:&lt;code&gt;SELECT&lt;/code&gt;、&lt;code&gt;FROM&lt;/code&gt;、&lt;code&gt;WHERE&lt;/code&gt;、&lt;code&gt;BY&lt;/code&gt;等。来感受一下MongoDB怎么操作数据：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//插入一个数据
var user = {
    &amp;quot;name&amp;quot;:&amp;quot;小芳&amp;quot;，
    &amp;quot;age&amp;quot;:18,
    &amp;quot;gender&amp;quot;:1,
    &amp;quot;country&amp;quot;:&amp;quot;中国&amp;quot;
};
db.user.insert(user)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;//查询姓名是：张三、李四、王五的信息
db.user.find({&amp;quot;name&amp;quot;:  {&amp;quot;\$in&amp;quot; : [&amp;quot;张三&amp;quot;,&amp;quot;李四&amp;quot;,&amp;quot;王五&amp;quot;] }})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;给我最大的感觉，它是一个面向对象面向集合的存储过程，对于经常做面向对象开发人来说是比较容易入手的。&lt;/p&gt;

&lt;h3 id=&#34;express&#34;&gt;Express&lt;/h3&gt;

&lt;p&gt;基于Node.js的极其简洁灵活的web应用开发框架，它有丰富的HTTP快捷方法，非常快捷的创建node服务.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;首页模块入口设置&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...
...
...
var home = require(&#39;./routes/home&#39;);//首页接口
...
...
...
app.use(&#39;/home&#39;, home);//将home绑定到首页接口path
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;详细的首页模块&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var express = require(&#39;express&#39;);
var router = express.Router();
var URL = require(&#39;url&#39;);
var MusicModel = require(&#39;./model.js&#39;);
const mongoose = require(&#39;mongoose&#39;);
//连接数据库并打开
mongoose.connect(&#39;mongodb://localhost:27017/funmusic&#39;)
var db = mongoose.connection;

db.on(&#39;open&#39;,function(){
	console.log(&#39;MongoDB Connect Successed&#39;);
});
db.on(&#39;error&#39;,function(){
	console.log(&#39;MongoDB Connect Error&#39;);
});
//定义card模型
const cardSchema = new mongoose.Schema({
 	vol_id:String,
 	vol_number:String,
 	number:Number,
 	title:String,
 	summary:String,
 	covers:[{
 		origin:String,
 		large:String,
 		large_low:String,
 		small:String,
 	}],
 	create_time:Number,
 	is_free:Number,
 	is_trial:Number,
 	tags:[{
 		tag_id:String,
 		name:String,
 		alias:String,
 		cover:String,
 	}],
 	comments_count:String,
 	favs_count:Number,
 	url:String,
 	detail_desc:String
 }, { collection: &#39;card&#39; });
const cardModel = mongoose.model(&#39;card&#39;,cardSchema);

//list接口
router.get(&#39;/list&#39;,function(req,res,next){
	var params = URL.parse(req.url,true).query;
	var response = res;
	cardModel.find({},(err,result,res) =&amp;gt; {
		if(err)  return console.log(err);
		console.log(result);
		var content = {status:1,data:result};
		response.send(JSON.stringify(content));
	});
	
})

//定义cardDetail模型
const cardDetailSchema = new mongoose.Schema({
	covers:[{
		origin:String,
		large:String,
		large_low:String,
		small:String,
	}],
	detail_desc:String,
	title:String,
	number:Number,
	tags:[{
 		tag_id:String,
 		name:String,
 		alias:String,
 		cover:String,
 	}],
},{collection:&#39;card&#39;});

//detail接口
router.get(&#39;/detail&#39;,function(req,res,next){
	var params = URL.parse(req.url,true).query;
	var response = res;
	var _vol_id = params.vol_id;
	console.log(_vol_id);
	cardModel.aggregate([{ $match : { vol_id : _vol_id}},{ $project : {title : 1,covers : 1,detail_desc : 1,number : 1,tags : 1,&amp;quot;_id&amp;quot; : 0}}],(err,result,res) =&amp;gt; {
		if(err)  return console.log(err);
		console.log(result);
		var restruct = {
			image_large:result[0].covers[0].large,
			detail_desc:result[0].detail_desc,
			title:result[0].title,
			number:result[0].number,
			tags:result[0].tags,
		}
		var content = {status:1,data:restruct};
		response.send(JSON.stringify(content));
	});
});



module.exports = router;

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;端口管理-nginx&#34;&gt;端口管理 - Nginx&lt;/h3&gt;

&lt;p&gt;Nginx是一个反向代理服务器，平时我们抓包数据从server到client是正向代理，从client到server就是反向代理。服务器的http服务只会向外暴露80端口（默认），https服务暴露443(默认)端口。我们的服务则是3000端口，Nginx会将请求反向代理到3000端口，无论你是http还是hppts请求。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http {
    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &amp;quot;$request&amp;quot; &#39;
                      &#39;$status $body_bytes_sent &amp;quot;$http_referer&amp;quot; &#39;
                      &#39;&amp;quot;$http_user_agent&amp;quot; &amp;quot;$http_x_forwarded_for&amp;quot;&#39;;

    access_log  /var/log/nginx/access.log  main;

    sendfile            on;
    tcp_nopush          on;
    tcp_nodelay         on;
    keepalive_timeout   65;
    types_hash_max_size 2048;

    include             /etc/nginx/mime.types;
    default_type        application/octet-stream;

    # Load modular configuration files from the /etc/nginx/conf.d directory.
    # See http://nginx.org/en/docs/ngx_core_module.html#include
    # for more information.
    include /etc/nginx/conf.d/*.conf;

    server {
        listen       80 default_server;
        listen       [::]:80 default_server;
        server_name  _;
        root         /usr/share/nginx/html;

        # Load configuration files for the default server block.
        include /etc/nginx/default.d/*.conf;

        location / {
	  proxy_pass http://127.0.0.1:3000;
        }

        error_page 404 /404.html;
            location = /40x.html {
        }

        error_page 500 502 503 504 /50x.html;
            location = /50x.html {
        }
    }

# Settings for a TLS enabled server.
#
    server {
        listen       443;
        server_name  www.lify.online;
	ssl on;
        root         html;
	index index.html index.htm;
        ssl_certificate cert/214534222920959.pem;
        ssl_certificate_key cert/214534222920959.key;
        ssl_session_timeout  5m;
        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;
        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
        ssl_prefer_server_ciphers on;
        location / {
	  #root html;
	  #index index.html index.htm;
	  proxy_pass http://127.0.0.1:3000;
        }

}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;进程管理-pm2&#34;&gt;进程管理 - PM2&lt;/h3&gt;

&lt;p&gt;使用它可以很方便的启动、停止和监控进程。刚开始重新发布接口的时候，都需要停止服务，kill进程，再次启动服务，有了pm2只要&lt;code&gt;pm2 restart 进程名&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;以上是我最近一段时间小程序之旅的总结，希望对你有所帮助。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>