<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>董二千</title>
    <link>https://LinkRober.github.io/bookshelf/index.xml</link>
    <description>Recent content on 董二千</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 25 Mar 2018 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://LinkRober.github.io/bookshelf/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>入坑小程序</title>
      <link>https://linkrober.github.io/bookshelf/2018/03/%E5%85%A5%E5%9D%91%E5%B0%8F%E7%A8%8B%E5%BA%8F/</link>
      <pubDate>Sun, 25 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://linkrober.github.io/bookshelf/2018/03/%E5%85%A5%E5%9D%91%E5%B0%8F%E7%A8%8B%E5%BA%8F/</guid>
      <description>

&lt;h3 id=&#34;描述&#34;&gt;描述&lt;/h3&gt;

&lt;p&gt;去年各大平台纷纷开始占领微信上的又一流量入口——小程序。因为小程序的门槛低，这里指，技术上和前端大同小异，审核刚开始也比较松。除了大厂，很多个人开发这都投入进去。想在小程序上打响自己的个人品牌。在筹备了三个月之久，我的第一款小程序，终于快要完成了。在这里我会总结一下整体的过程，从idea到一个完整的小程序、期间遇到的坑、和觉得挺有意思的地方。&lt;/p&gt;

&lt;h3 id=&#34;流程&#34;&gt;流程&lt;/h3&gt;

&lt;p&gt;&lt;br /&gt;
1. 购买服务器
    本人购买的服务器是阿里云服务器，因为经历的几家公司都是用的它，感觉还是比较靠谱的（我一同事也用过腾讯的服务，一直在吐槽不稳定，后来也换到阿里云了)&lt;/p&gt;

&lt;p&gt;&lt;/br&gt;
2. 购买域名
    小程序的是无法直接通过IP访问，必须申请一个域名，同样的阿里云上买就行了。这里要提醒大家的是，因为国家政策原因域名需要备案，整个过程大概需要一个月时间。阿里云还是比较良心的，备案成功之后会再赠送你一个月的服务器时间。因为整个备案时间大概是一个月。所有绑定域名一定要提前。&lt;/p&gt;

&lt;p&gt;&lt;/br&gt;
3. 申请CA证书绑定到域名。在小程序里的API都需要Htps服务，如果你有CA证书可以直接使用，我也是通过阿里云申请的免费CA证书，时间是一年，到期看可以续的。&lt;/p&gt;

&lt;p&gt;&lt;/br&gt;
4. 根据idea设计产品&lt;/p&gt;

&lt;p&gt;&lt;/br&gt;
5. 开发小程序和server&lt;/p&gt;

&lt;p&gt;&lt;/br&gt;
6.发布&lt;/p&gt;

&lt;h3 id=&#34;小程序&#34;&gt;小程序&lt;/h3&gt;

&lt;p&gt;因为是我的第一个小程序，先试试手，所以选了一个比较简单的东西，音乐欣赏。数据是从其他网站爬过来插到数据库的。
本人是移动端出生，对前端和后端的东西都不是很熟，不过刚好去年写了不少RN的东西，前端的东西也算是半只脚入门了。在小程序里面文件分为下面几种&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;js文件，和前端的一样，&lt;/li&gt;
&lt;li&gt;wxml文件，类似于html文件&lt;/li&gt;
&lt;li&gt;wxss文件，类似于css文件&lt;/li&gt;
&lt;li&gt;wxs文件，这是小程序的一套脚本语言，语法看似和JavaScript语法一样，其实他们是不同的语言，有自己的语法，并不和 javascript 一致    。我们可以把它当做方法类在wxml中来使用。在wxml中是无法调用js中的非事件方法的，如果从js文件里拿到的数据你希望再做一步处理然后展示，这样的处理需要放到wxs文件里。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;开发前花半天浏览下微信小程序的API差不多就可以了，套路都差不多MVC。&lt;/p&gt;

&lt;h3 id=&#34;数据库&#34;&gt;数据库&lt;/h3&gt;

&lt;p&gt;服务器是用Node.js+MongoDB+Express搭建的，全套搭建起来还是很快的。Node.js是一个基于事件驱动I/O的服务端JavaScript环境，它在高并发的服务上有很好的体验。同样是js所以语法基本没门槛了。
MongoDB数据库和一般的关系型数据库不同，它是非关系型数据库。关系型数据库对数据操作都是:&lt;code&gt;SELECT&lt;/code&gt;、&lt;code&gt;FROM&lt;/code&gt;、&lt;code&gt;WHERE&lt;/code&gt;、&lt;code&gt;BY&lt;/code&gt;等。来感受一下MongoDB怎么操作数据：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//插入一个数据
var user = {
    &amp;quot;name&amp;quot;:&amp;quot;小芳&amp;quot;，
    &amp;quot;age&amp;quot;:18,
    &amp;quot;gender&amp;quot;:1,
    &amp;quot;country&amp;quot;:&amp;quot;中国&amp;quot;
};
db.user.insert(user)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;//查询姓名是：张三、李四、王五的信息
db.user.find({&amp;quot;name&amp;quot;:  {&amp;quot;\$in&amp;quot; : [&amp;quot;张三&amp;quot;,&amp;quot;李四&amp;quot;,&amp;quot;王五&amp;quot;] }})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;给我最大的感觉，它是一个面向对象面向集合的存储过程，对于经常做面向对象开发人来说是比较容易入手的。&lt;/p&gt;

&lt;h3 id=&#34;express&#34;&gt;Express&lt;/h3&gt;

&lt;p&gt;基于Node.js的极其简洁灵活的web应用开发框架，它有丰富的HTTP快捷方法，非常快捷的创建node服务.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;首页模块入口设置&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...
...
...
var home = require(&#39;./routes/home&#39;);//首页接口
...
...
...
app.use(&#39;/home&#39;, home);//将home绑定到首页接口path
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;详细的首页模块&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var express = require(&#39;express&#39;);
var router = express.Router();
var URL = require(&#39;url&#39;);
var MusicModel = require(&#39;./model.js&#39;);
const mongoose = require(&#39;mongoose&#39;);
//连接数据库并打开
mongoose.connect(&#39;mongodb://localhost:27017/funmusic&#39;)
var db = mongoose.connection;

db.on(&#39;open&#39;,function(){
	console.log(&#39;MongoDB Connect Successed&#39;);
});
db.on(&#39;error&#39;,function(){
	console.log(&#39;MongoDB Connect Error&#39;);
});
//定义card模型
const cardSchema = new mongoose.Schema({
 	vol_id:String,
 	vol_number:String,
 	number:Number,
 	title:String,
 	summary:String,
 	covers:[{
 		origin:String,
 		large:String,
 		large_low:String,
 		small:String,
 	}],
 	create_time:Number,
 	is_free:Number,
 	is_trial:Number,
 	tags:[{
 		tag_id:String,
 		name:String,
 		alias:String,
 		cover:String,
 	}],
 	comments_count:String,
 	favs_count:Number,
 	url:String,
 	detail_desc:String
 }, { collection: &#39;card&#39; });
const cardModel = mongoose.model(&#39;card&#39;,cardSchema);

//list接口
router.get(&#39;/list&#39;,function(req,res,next){
	var params = URL.parse(req.url,true).query;
	var response = res;
	cardModel.find({},(err,result,res) =&amp;gt; {
		if(err)  return console.log(err);
		console.log(result);
		var content = {status:1,data:result};
		response.send(JSON.stringify(content));
	});
	
})

//定义cardDetail模型
const cardDetailSchema = new mongoose.Schema({
	covers:[{
		origin:String,
		large:String,
		large_low:String,
		small:String,
	}],
	detail_desc:String,
	title:String,
	number:Number,
	tags:[{
 		tag_id:String,
 		name:String,
 		alias:String,
 		cover:String,
 	}],
},{collection:&#39;card&#39;});

//detail接口
router.get(&#39;/detail&#39;,function(req,res,next){
	var params = URL.parse(req.url,true).query;
	var response = res;
	var _vol_id = params.vol_id;
	console.log(_vol_id);
	cardModel.aggregate([{ $match : { vol_id : _vol_id}},{ $project : {title : 1,covers : 1,detail_desc : 1,number : 1,tags : 1,&amp;quot;_id&amp;quot; : 0}}],(err,result,res) =&amp;gt; {
		if(err)  return console.log(err);
		console.log(result);
		var restruct = {
			image_large:result[0].covers[0].large,
			detail_desc:result[0].detail_desc,
			title:result[0].title,
			number:result[0].number,
			tags:result[0].tags,
		}
		var content = {status:1,data:restruct};
		response.send(JSON.stringify(content));
	});
});



module.exports = router;

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;端口管理-nginx&#34;&gt;端口管理 - Nginx&lt;/h3&gt;

&lt;p&gt;Nginx是一个反向代理服务器，平时我们抓包数据从server到client是正向代理，从client到server就是反向代理。服务器的http服务只会向外暴露80端口（默认），https服务暴露443(默认)端口。我们的服务则是3000端口，Nginx会将请求反向代理到3000端口，无论你是http还是hppts请求。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http {
    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &amp;quot;$request&amp;quot; &#39;
                      &#39;$status $body_bytes_sent &amp;quot;$http_referer&amp;quot; &#39;
                      &#39;&amp;quot;$http_user_agent&amp;quot; &amp;quot;$http_x_forwarded_for&amp;quot;&#39;;

    access_log  /var/log/nginx/access.log  main;

    sendfile            on;
    tcp_nopush          on;
    tcp_nodelay         on;
    keepalive_timeout   65;
    types_hash_max_size 2048;

    include             /etc/nginx/mime.types;
    default_type        application/octet-stream;

    # Load modular configuration files from the /etc/nginx/conf.d directory.
    # See http://nginx.org/en/docs/ngx_core_module.html#include
    # for more information.
    include /etc/nginx/conf.d/*.conf;

    server {
        listen       80 default_server;
        listen       [::]:80 default_server;
        server_name  _;
        root         /usr/share/nginx/html;

        # Load configuration files for the default server block.
        include /etc/nginx/default.d/*.conf;

        location / {
	  proxy_pass http://127.0.0.1:3000;
        }

        error_page 404 /404.html;
            location = /40x.html {
        }

        error_page 500 502 503 504 /50x.html;
            location = /50x.html {
        }
    }

# Settings for a TLS enabled server.
#
    server {
        listen       443;
        server_name  www.lify.online;
	ssl on;
        root         html;
	index index.html index.htm;
        ssl_certificate cert/214534222920959.pem;
        ssl_certificate_key cert/214534222920959.key;
        ssl_session_timeout  5m;
        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;
        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
        ssl_prefer_server_ciphers on;
        location / {
	  #root html;
	  #index index.html index.htm;
	  proxy_pass http://127.0.0.1:3000;
        }

}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;进程管理-pm2&#34;&gt;进程管理 - PM2&lt;/h3&gt;

&lt;p&gt;使用它可以很方便的启动、停止和监控进程。刚开始重新发布接口的时候，都需要停止服务，kill进程，再次启动服务，有了pm2只要&lt;code&gt;pm2 restart 进程名&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;以上是我最近一段时间小程序之旅的总结，希望对你有所帮助。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>递归</title>
      <link>https://linkrober.github.io/bookshelf/2018/02/%E9%80%92%E5%BD%92/</link>
      <pubDate>Fri, 02 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://linkrober.github.io/bookshelf/2018/02/%E9%80%92%E5%BD%92/</guid>
      <description>&lt;p&gt;&lt;/b&gt;
&lt;span class=&#34;highlight-text primary&#34;&gt;
基本思想
&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;递归是一种直接或者间接调用自身函数或者方法的算法。递归的实质是把问题分解成规模缩小的同类问题的子问题，然后递归调用方法来表示问题的解。递归算法，其实就是程序的自身调用。在一段程序中往往会遇到调用自身的那样一种coding策略。递归往往能带来非常简洁非常直观的代码形式，从而使我们的编码大大简化，但是递归的思想确实和我们的常规思维相逆。我们通常是从上而下的思考问题，而递归是从下往上进行思考。这样我们就能看到我们会用很少的语句解决很大的问题，所以递归策略最主要的体现就是较少的代码量解决复杂的问题。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;&lt;/b&gt;
&lt;span class=&#34;highlight-text primary&#34;&gt;
Example：计算阶乘
&lt;/span&gt;
计算阶乘是递归程序的经典示例。计算某个数的阶乘就是用那个数乘以包含1在内的比它小的所有数。例如，&lt;code&gt;factorial(6)&lt;/code&gt;等价于&lt;code&gt;6*5*4*3*2*1&lt;/code&gt;,阶乘的特性是，某个数的阶乘等于起始数乘以比它小的数的阶乘。阶乘函数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int factorial(int n) {
	return n * factorial(n-1);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是这个函数会永远执行下去，因为它没有终止条件。所以我们需要一个条件告诉它何时停止。我们这里给出的条件就是&lt;code&gt;n == 1&lt;/code&gt;停止&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int factorial(int n){
	if(n == 1){
		return 1;
	}
	else {
		return n * factorial(n - 1);
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;流程示意图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../../../fact-shape.jpg&#34; alt=&#34;fact-shape&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;/b&gt;
&lt;span class=&#34;highlight-text primary&#34;&gt;
Example：斐波纳契数列
&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;数学上&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97&#34;&gt;斐波纳契数列&lt;/a&gt;是以递归的方式来定义的：
&lt;img src=&#34;../../../Fibonacci Sequence.png&#34; alt=&#34;Fibonacci Sequence&#34; /&gt;&lt;/p&gt;

&lt;p&gt;写成递归程序：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int Fibonacci(int n){
    if (n &amp;lt;= 1)  
        return n;  
    else  
        return Fibonacci(n-1) + Fibonacci(n-2);  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/b&gt;
&lt;span class=&#34;highlight-text primary&#34;&gt;
递归条件
&lt;/span&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;递归开始时需要一个种子值&lt;/li&gt;
&lt;li&gt;不断的调用自身&lt;/li&gt;
&lt;li&gt;检查当前值是否已经匹配基本条件。如果匹配，则进行处理并返回值&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>再见2017，你好2018</title>
      <link>https://linkrober.github.io/bookshelf/2018/01/%E5%86%8D%E8%A7%812017%E4%BD%A0%E5%A5%BD2018/</link>
      <pubDate>Tue, 02 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://linkrober.github.io/bookshelf/2018/01/%E5%86%8D%E8%A7%812017%E4%BD%A0%E5%A5%BD2018/</guid>
      <description>&lt;p&gt;不知不觉工作已有三个年头，在iOS这条路上，从当年战战兢兢的新人变成一个熟练的开发者，这一路走来真不容易。不仅仅是身体上的负荷，个人对于技术的追求也使自己或迷惘或奋起。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h4 id=&#34;工作&#34;&gt;工作&lt;/h4&gt;

&lt;p&gt;前两年基本上都在加班赶业务做是某块业务，对于一款App从无到有如何架构的没有系统的考虑过。今年在公司的这款Wecycle视频社交App上，团队内从开发语言、设计模式、缓存策略、网络层设计、组件化方案等几个维度来架构这款App。因为前期产品架构的好，后面产品迭代大家都做的比较轻松。就像一幢大厦有了整体的框架，需要什么就往里面塞就行，定期修正下，时间久了，也不用担心楼歪了。&lt;/p&gt;

&lt;p&gt;今年App做了不少，除了刚才说的还有Snapvote，一款投票App；VISO，一款视频和滤镜编辑的App。
Wecycle是Object-C和Swift混编的工程，在这期间算是入门了苹果爸爸的新开发语言，Swfit所倡导的面相协议编程让开发人员的脑洞可以开的更大了，通过协议抽象各种应用场景着实让人兴奋了一把，在Swfit2.0之后&lt;code&gt;protocol&lt;/code&gt;的&lt;code&gt;extension&lt;/code&gt;支持默认实现，为协议插上了翅膀。感兴趣的同学不妨看看&lt;a href=&#34;https://github.com/ishkawa/APIKit&#34;&gt;&lt;code&gt;APIKit&lt;/code&gt;&lt;/a&gt;这个Swift库，它通过POP的方式在网络请求和模型解析之间给出了一个很棒的解决方案，在此不展开了。Swift的解包、写时复制、大量的值类型的使用使得我们的代码比OC时代写起来更安全。&lt;/p&gt;

&lt;p&gt;Snapvote是一款简单的投票类工具App，没有用户系统，可以说是比较简单的了，所以考虑用跨平台的框架ReactNative开发，顺便练练手。一次使用两个工具（Xcode、React Native Debuger）同时调试,那叫酸爽，两个显示器都不够用。扒拉扒拉ReactNative的OC实现，Runtime、消息转发、RunLoop、多线程、线程锁一大堆的知识点，让人受益匪浅；同时又稍微学了点javascript。关于ReactNative的相关体验自己写了一个系列共四篇文章,从安装到原理的讨论，算是有个交代吧。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://linkrober.github.io/bookshelf/2017/10/react-native%E5%A6%82%E4%BD%95%E9%9B%86%E6%88%90%E5%88%B0%E7%8E%B0%E6%9C%89%E9%A1%B9%E7%9B%AE%E4%B8%AD/&#34;&gt;React Native如何集成到现有项目中&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://linkrober.github.io/bookshelf/2017/10/react-native%E5%92%8Cnative%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1/&#34;&gt;React Native和Native间的通信实践&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://linkrober.github.io/bookshelf/2017/10/rctrootviewrctbridge%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88/&#34;&gt;RCTRootView、RCTBridge做了什么&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://linkrober.github.io/bookshelf/2017/12/object-c%E5%92%8Cjs%E9%80%9A%E4%BF%A1%E6%A6%82%E8%BF%B0/&#34;&gt;Object-C和JS通信概述&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;https://itunes.apple.com/us/app/viso-photo-editor-collage/id1312830469?ls=1&amp;amp;mt=8&#34;&gt;VISO&lt;/a&gt;视频图片编辑的App和VISCO很像，有兴趣的同学可以体验下，期待你们的意见😄。经历了OC和Swift混编的痛苦，本来想使用纯Swift开发，但是受限于公司内部某些视频编辑库是OC写的一时半会儿没发改过来，只能写回OC了。通过这款App的开发让我对音视频的处理有了一个全面的了解。前两年一直忙于业务没有深挖OC的底层，今年花了很多时间在这上面，不仅对Runtime、RunLoop、线程、线程锁有了更深入的理解，还花时间把C又拉出来练了练。用C写了个App上的Socket服务（Ps：因为期间一直在看网络方面的书籍&lt;a href=&#34;https://read.douban.com/ebook/12054542/&#34;&gt;《图解HTTP》&lt;/a&gt;、&lt;a href=&#34;https://book.douban.com/subject/1088054/&#34;&gt;《TCP／IP详解》&lt;/a&gt;，写的时候少走了点弯路，果然是书到用时方恨少），通过浏览器访问App的某个端口实时的查看埋点数据，方便了QA的测试。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://linkrober.github.io/bookshelf/2017/11/%E4%B8%80%E4%B8%AA%E9%9F%B3%E8%A7%86%E9%A2%91%E5%8E%82%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B%E6%A6%82%E8%BF%B0/&#34;&gt;一个音视频厂的图像处理流程概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://linkrober.github.io/bookshelf/2017/09/run-loops-%E4%B8%80/&#34;&gt;Run Loops (一)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://linkrober.github.io/bookshelf/2017/12/ios%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD%E7%9A%84%E9%94%81/&#34;&gt;iOS多线程中的锁&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;行业&#34;&gt;行业&lt;/h4&gt;

&lt;p&gt;因为市场上的培训班不断的输出iOS开发者，iOS市场基本饱和，工作也不是三年前随随便便的就能找到，对技术人员的基本素养要求更高，市场正在慢慢回归到良性，挺好。 今年Javascript、Python、Java大行其道，但还是相信苹果爸爸。在OC这门语言上我会继续深入，它是一门动态的语言有很多有趣的技术是那些在编译期就决定怎么跑的语言所不具备的。学习并吸收它，让自己更透彻的了解一门语言的底层机制。对一个几年的开发人员来说，如果一门语言都不能理解的比较透彻，那是可悲的。花更多的时间熟悉Swift，今后让自己的技术能够平稳的过渡。&lt;/p&gt;

&lt;p&gt;“在我们这个地方，你必须不停地奔跑，才能留在原地。” —— 《爱丽丝漫游奇境》● 红桃皇后&lt;/p&gt;

&lt;h4 id=&#34;生活&#34;&gt;生活&lt;/h4&gt;

&lt;p&gt;今年自己的个人生活出现了些状况，多的也不说了大家都懂。这次经历让我意识到即使是两个人已经在一起了，也不要丢失掉原来的自己，不要忘记对方是因为原来的你才想和你在一起。如果你变了，她也变了。控制自己，时刻保持优秀。无论是工作还是生活，活的精致点。&lt;/p&gt;

&lt;h4 id=&#34;2017书单&#34;&gt;2017书单&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;《图解HTTP》&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;图文并茂，叙述生动。适合新手，让读者对HTTP很快形成一个整体的概念，明白为何这样设计。&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;《Linux Shell脚本》&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;当作参考书需要的时候翻翻&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;《Object-C高级编程（iOS和OSX多线程和内存管理）》&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Autorelease、属性修饰符、block、GCD都有比较深入的理解，都是干货，适合反复阅读。&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;《Head First HTML》&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;入门推荐&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;《程序员的自我修养》&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;好书，对编译和连接有比较深入的描述，是个大菠萝，得慢慢啃。&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;《深入理解计算机系统》&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;好书，操作系统必读书籍，又是个大菠萝。&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Object-C和JS通信概述</title>
      <link>https://linkrober.github.io/bookshelf/2017/12/object-c%E5%92%8Cjs%E9%80%9A%E4%BF%A1%E6%A6%82%E8%BF%B0/</link>
      <pubDate>Mon, 25 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://linkrober.github.io/bookshelf/2017/12/object-c%E5%92%8Cjs%E9%80%9A%E4%BF%A1%E6%A6%82%E8%BF%B0/</guid>
      <description>&lt;p&gt;本系列文章作为学习RN期间的总结&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://linkrober.github.io/bookshelf/2017/10/react-native%E5%A6%82%E4%BD%95%E9%9B%86%E6%88%90%E5%88%B0%E7%8E%B0%E6%9C%89%E9%A1%B9%E7%9B%AE%E4%B8%AD/&#34;&gt;React Native如何集成到现有项目中&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://linkrober.github.io/bookshelf/2017/10/react-native%E5%92%8Cnative%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1/&#34;&gt;React Native和Native间的通信实践&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://linkrober.github.io/bookshelf/2017/10/rctrootviewrctbridge%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88/&#34;&gt;RCTRootView、RCTBridge做了什么&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Object-C和JS通信概述&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h4 id=&#34;流程梳理&#34;&gt;流程梳理&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;../../../来自JSPath作者Bang的一张流程图.png&#34; alt=&#34;来自JSPath作者Bang的一张流程图&#34; /&gt;
首先，无论是RN端还是Native端都会持有一个bridge负责对来自不同端的模块进行桥街，再做消息处理。现附上一张来自JSPath作者Bang的图。
RN调用某个方法向Native发送消息，方法首先会被分解成ModuleId、MethodId和参数，发送到OCBridge。那么OCBridge是如何接受的呢？（因为对JS代码不熟悉这里只讨论OC部分）&lt;/p&gt;

&lt;p&gt;在第一次初始化ReactNative的时候模块信息会被初始化，包括模块名称、方法名。在注册模块的时候我们会用到&lt;code&gt;RCT_EXPORT_MODULE();&lt;/code&gt;这个宏，宏展开&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define RCT_EXPORT_MODULE(js_name) \
RCT_EXTERN void RCTRegisterModule(Class); \
+ (NSString *)moduleName { return @#js_name; } \
+ (void)load { RCTRegisterModule(self); }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;方法1:如果自定义了模块的名称就使用自定义的名称而不是原类的名称&lt;/p&gt;

&lt;p&gt;方法2:在+(void)load方法里对类进行一次注册，注册代码如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void RCTRegisterModule(Class moduleClass)
{
  static dispatch_once_t onceToken;
  dispatch_once(&amp;amp;onceToken, ^{
    RCTModuleClasses = [NSMutableArray new];
  });

  RCTAssert([moduleClass conformsToProtocol:@protocol(RCTBridgeModule)],
            @&amp;quot;%@ does not conform to the RCTBridgeModule protocol&amp;quot;,
            moduleClass);

  // Register module
  [RCTModuleClasses addObject:moduleClass];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果当前类遵循协议&lt;code&gt;RCTBridgeModule&lt;/code&gt;,就把它放到一个静态变量数组&lt;code&gt;RCTModuleClasses&lt;/code&gt;中。所以启动之后，所有RN需要的模块都会被动态载入。
这些模块会被存储在三张表中&lt;code&gt;_moduleDataByName&lt;/code&gt;、&lt;code&gt;_moduleDataByID&lt;/code&gt;、&lt;code&gt;_moduleClassesByID&lt;/code&gt;,在初始化的时候通过遍历该数组来初始化。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NSDictionary&amp;lt;NSString *, RCTModuleData *&amp;gt; *_moduleDataByName;
NSArray&amp;lt;RCTModuleData *&amp;gt; *_moduleDataByID;
NSArray&amp;lt;Class&amp;gt; *_moduleClassesByID;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;for (Class moduleClass in RCTGetModuleClasses()) {
    NSString *moduleName = RCTBridgeModuleNameForClass(moduleClass);

    // Check for module name collisions
    RCTModuleData *moduleData = moduleDataByName[moduleName];
    if (moduleData) {
      if (moduleData.hasInstance) {
        // Existing module was preregistered, so it takes precedence
        continue;
      } else if ([moduleClass new] == nil) {
        // The new module returned nil from init, so use the old module
        continue;
      } else if ([moduleData.moduleClass new] != nil) {
        // Both modules were non-nil, so it&#39;s unclear which should take precedence
        RCTLogError(@&amp;quot;Attempted to register RCTBridgeModule class %@ for the &amp;quot;
                    &amp;quot;name &#39;%@&#39;, but name was already registered by class %@&amp;quot;,
                    moduleClass, moduleName, moduleData.moduleClass);
      }
    }

    // Instantiate moduleData (TODO: can we defer this until config generation?)
    moduleData = [[RCTModuleData alloc] initWithModuleClass:moduleClass
                                                     bridge:self];
    moduleDataByName[moduleName] = moduleData;
    [moduleClassesByID addObject:moduleClass];
    [moduleDataByID addObject:moduleData];
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分别是模块名称、模块名称对应的对象&lt;code&gt;RCTModuleData&lt;/code&gt;、模块名称和模块对象的映射字典，方便后续使用。&lt;/p&gt;

&lt;p&gt;这时候还有一个重要的东西需要处理就是callback，JSBridge在传递消息的时候会把callback缓存起来，仅仅把callbackId传递到OCBridge。
这时候OCBridge拿到了传过来的ModuleId、MethodId、callbackId，再通过Native端的配置表分别取出模块和方法。模块会被转化为&lt;code&gt;RCTModuleData&lt;/code&gt;对象，方法都会被转化为一个&lt;code&gt;RCTModuleMethod&lt;/code&gt;对象，看一下这个对象&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  Class _moduleClass;
  const RCTMethodInfo *_methodInfo;
  NSString *_JSMethodName;

  SEL _selector;
  NSInvocation *_invocation;
  NSArray&amp;lt;RCTArgumentBlock&amp;gt; *_argumentBlocks;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;发现了&lt;code&gt;_moduleClass&lt;/code&gt;、&lt;code&gt;_argumentBlocks&lt;/code&gt;、&lt;code&gt;_invocation&lt;/code&gt;、&lt;code&gt;_selector&lt;/code&gt;这时候就很容易想到消息转发的最后一个阶段，将消息的目标、selector、参数封装到NSInvocation中进行消息转发。&lt;/p&gt;

&lt;p&gt;刚才上面讲到模块的注册，那么方法是如何筛选的呢？注意下面的3个宏&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define RCT_EXPORT_METHOD(method) \
  RCT_REMAP_METHOD(, method)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;#define RCT_REMAP_METHOD(js_name, method) \
  _RCT_EXTERN_REMAP_METHOD(js_name, method, NO) \
  - (void)method;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;#define _RCT_EXTERN_REMAP_METHOD(js_name, method, is_blocking_synchronous_method) \
  + (const RCTMethodInfo *)RCT_CONCAT(__rct_export__, RCT_CONCAT(js_name, RCT_CONCAT(__LINE__, __COUNTER__))) { \
    static RCTMethodInfo config = {#js_name, #method, is_blocking_synchronous_method}; \
    return &amp;amp;config; \
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在我们具体定义方法的时候并没有&lt;code&gt;-(void)&lt;/code&gt;字符串前缀，因为在预编译的时候，宏会帮我们加上这段字符（看第二个宏）。
第三个宏主要实现了字符串的拼接，&lt;code&gt;(__LINE__, __COUNTER__)&lt;/code&gt;的意思是为当前的宏生成一个唯一的tag（行数+一个数字），再和前面的&lt;code&gt;js_name&lt;/code&gt;连接，最后再和&lt;code&gt;__rct_export__&lt;/code&gt;连接，大概像这样&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-(void)__rct_export__8976699MethodName{
	//
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;其实&lt;strong&gt;COUNTER&lt;/strong&gt;是一个预定义的宏，这个值在编译过程中将从0开始计数，每次被调用时加1。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;所有JSBridge传过来的参数都是&lt;code&gt;NSNumber&lt;/code&gt;,OCBridge会把它们转化成基本类型和字符串。上面在提到JSBridge传参数的时候会带一个callbackId，这时候OCBridge会根据这个Id生成一个callback，保存在内存中。&lt;/p&gt;

&lt;p&gt;这时候OC执行方法的调用，执行block。将参数和callbackId传到JSBridge，JSBridge根据Id找到之前缓存的JSCallback，进行调用。到这里就完成RN-Native-RN的一个闭环。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;JS是怎么调用OC的呢？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;其实并不是JS调用OC，而是JS将消息放到一个消息队列里面MessageQueue，等OC来取，这里面还有很多问题值得讨论多长时间取一次；不来取怎么办。有待我们继续研究&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
&lt;p&gt;为什么OC和JS可以实现这种框架？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;要实现这个机制需要语言有动态反射的特性(OC是一门动态语言，消息和消息的target等都是在运行时决定)，即可以通过类/方法名字符串找到对应的类/方法进行调用，没有这特性就做不了。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;知识点&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;使用&lt;a href=&#34;https://linkrober.github.io/bookshelf/2017/09/run-loops-%E4%B8%80/&#34;&gt;RunLoop&lt;/a&gt;让JS线程常驻内存&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;//RCTJSCExecutor

+ (void)runRunLoopThread
{
  @autoreleasepool {
    // copy thread name to pthread name
    pthread_setname_np([NSThread currentThread].name.UTF8String);

    // Set up a dummy runloop source to avoid spinning
    CFRunLoopSourceContext noSpinCtx = {0, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
    CFRunLoopSourceRef noSpinSource = CFRunLoopSourceCreate(NULL, 0, &amp;amp;noSpinCtx);
    CFRunLoopAddSource(CFRunLoopGetCurrent(), noSpinSource, kCFRunLoopDefaultMode);
    CFRelease(noSpinSource);

    // run the run loop
    while (kCFRunLoopRunStopped != CFRunLoopRunInMode(kCFRunLoopDefaultMode, ((NSDate *)[NSDate distantFuture]).timeIntervalSinceReferenceDate, NO)) {
      RCTAssert(NO, @&amp;quot;not reached assertion&amp;quot;); // runloop spun. that&#39;s bad.
    }
  }
}

static NSThread *newJavaScriptThread(void)
{
  NSThread *javaScriptThread = [[NSThread alloc] initWithTarget:[RCTJSCExecutor class]
                                                       selector:@selector(runRunLoopThread)
                                                         object:nil];
  javaScriptThread.name = RCTJSCThreadName;
  javaScriptThread.qualityOfService = NSOperationQualityOfServiceUserInteractive;
  [javaScriptThread start];
  return javaScriptThread;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;通过动态&lt;a href=&#34;https://linkrober.github.io/bookshelf/2017/10/runtime%E4%B8%89-%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91/&#34;&gt;消息转发&lt;/a&gt;发送来自RN的消息,RCTModuleMethod&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;//RCTModuleMethod

NSMethodSignature *typeSignature = [RCTConvert methodSignatureForSelector:selector];
NSInvocation *typeInvocation = [NSInvocation invocationWithMethodSignature:typeSignature];
typeInvocation.selector = selector;
typeInvocation.target = [RCTConvert class];

[argumentBlocks addObject:^(__unused RCTBridge *bridge, NSUInteger index, id json) {
void *returnValue = malloc(typeSignature.methodReturnLength);
[typeInvocation setArgument:&amp;amp;json atIndex:2];
[typeInvocation invoke];
[typeInvocation getReturnValue:returnValue];
[invocation setArgument:returnValue atIndex:index + 2];
free(returnValue);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;用Runtime拿到所有的类信息和方法&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;//RCTBridge

void RCTVerifyAllModulesExported(NSArray *extraModules)
{
  // Check for unexported modules
  unsigned int classCount;
  Class *classes = objc_copyClassList(&amp;amp;classCount);

  NSMutableSet *moduleClasses = [NSMutableSet new];
  [moduleClasses addObjectsFromArray:RCTGetModuleClasses()];
  [moduleClasses addObjectsFromArray:[extraModules valueForKeyPath:@&amp;quot;class&amp;quot;]];

  for (unsigned int i = 0; i &amp;lt; classCount; i++) {
    Class cls = classes[i];
    Class superclass = cls;
    while (superclass) {
      if (class_conformsToProtocol(superclass, @protocol(RCTBridgeModule))) {
        if ([moduleClasses containsObject:cls]) {
          break;
        }

        // Verify it&#39;s not a super-class of one of our moduleClasses
        BOOL isModuleSuperClass = NO;
        for (Class moduleClass in moduleClasses) {
          if ([moduleClass isSubclassOfClass:cls]) {
            isModuleSuperClass = YES;
            break;
          }
        }
        if (isModuleSuperClass) {
          break;
        }

        RCTLogWarn(@&amp;quot;Class %@ was not exported. Did you forget to use RCT_EXPORT_MODULE()?&amp;quot;, cls);
        break;
      }
      superclass = class_getSuperclass(superclass);
    }
  }

  free(classes);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;GCD的大量使用，在初始化各个模块时(initModulesAndLoadSource和setupJSExecutorAndModuleConfig这两个group)对于线程依赖的控制&lt;code&gt;dispatch_group_enter();&lt;/code&gt;&lt;code&gt;dispatch_group_leave()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;//RCTBatchedBridge

- (void)start
{
  [[NSNotificationCenter defaultCenter]
    postNotificationName:RCTJavaScriptWillStartLoadingNotification
    object:_parentBridge userInfo:@{@&amp;quot;bridge&amp;quot;: self}];

  RCT_PROFILE_BEGIN_EVENT(0, @&amp;quot;-[RCTBatchedBridge setUp]&amp;quot;, nil);

  dispatch_queue_t bridgeQueue = dispatch_queue_create(&amp;quot;com.facebook.react.RCTBridgeQueue&amp;quot;, DISPATCH_QUEUE_CONCURRENT);

  dispatch_group_t initModulesAndLoadSource = dispatch_group_create();

  // Asynchronously load source code
  dispatch_group_enter(initModulesAndLoadSource);
  __weak RCTBatchedBridge *weakSelf = self;
  __block NSData *sourceCode;
  [self loadSource:^(NSError *error, NSData *source, __unused int64_t sourceLength) {
    if (error) {
      RCTLogWarn(@&amp;quot;Failed to load source: %@&amp;quot;, error);
      dispatch_async(dispatch_get_main_queue(), ^{
        [weakSelf stopLoadingWithError:error];
      });
    }

    sourceCode = source;
    dispatch_group_leave(initModulesAndLoadSource);
  } onProgress:^(RCTLoadingProgress *progressData) {
#if RCT_DEV &amp;amp;&amp;amp; __has_include(&amp;quot;RCTDevLoadingView.h&amp;quot;)
    RCTDevLoadingView *loadingView = [weakSelf moduleForClass:[RCTDevLoadingView class]];
    [loadingView updateProgress:progressData];
#endif
  }];

  // Synchronously initialize all native modules that cannot be loaded lazily
  [self initModulesWithDispatchGroup:initModulesAndLoadSource];

  RCTPerformanceLogger *performanceLogger = self-&amp;gt;_performanceLogger;
  __block NSString *config;
  dispatch_group_enter(initModulesAndLoadSource);
  dispatch_async(bridgeQueue, ^{
    dispatch_group_t setupJSExecutorAndModuleConfig = dispatch_group_create();

    // Asynchronously initialize the JS executor
    dispatch_group_async(setupJSExecutorAndModuleConfig, bridgeQueue, ^{
      [performanceLogger markStartForTag:RCTPLJSCExecutorSetup];
      [weakSelf setUpExecutor];
      [performanceLogger markStopForTag:RCTPLJSCExecutorSetup];
    });

    // Asynchronously gather the module config
    dispatch_group_async(setupJSExecutorAndModuleConfig, bridgeQueue, ^{
      if (weakSelf.valid) {
        RCT_PROFILE_BEGIN_EVENT(0, @&amp;quot;-[RCTBatchedBridge moduleConfig&amp;quot;, nil);
        [performanceLogger markStartForTag:RCTPLNativeModulePrepareConfig];
        config = [weakSelf moduleConfig];
        [performanceLogger markStopForTag:RCTPLNativeModulePrepareConfig];
        RCT_PROFILE_END_EVENT(RCTProfileTagAlways, @&amp;quot;&amp;quot;);
      }
    });

    dispatch_group_notify(setupJSExecutorAndModuleConfig, bridgeQueue, ^{
      // We&#39;re not waiting for this to complete to leave dispatch group, since
      // injectJSONConfiguration and executeSourceCode will schedule operations
      // on the same queue anyway.
      [performanceLogger markStartForTag:RCTPLNativeModuleInjectConfig];
      [weakSelf injectJSONConfiguration:config onComplete:^(NSError *error) {
        [performanceLogger markStopForTag:RCTPLNativeModuleInjectConfig];
        if (error) {
          RCTLogWarn(@&amp;quot;Failed to inject config: %@&amp;quot;, error);
          dispatch_async(dispatch_get_main_queue(), ^{
            [weakSelf stopLoadingWithError:error];
          });
        }
      }];
      dispatch_group_leave(initModulesAndLoadSource);
    });
  });

  dispatch_group_notify(initModulesAndLoadSource, bridgeQueue, ^{
    RCTBatchedBridge *strongSelf = weakSelf;
    if (sourceCode &amp;amp;&amp;amp; strongSelf.loading) {
      [strongSelf executeSourceCode:sourceCode];
    }
  });

  RCT_PROFILE_END_EVENT(RCTProfileTagAlways, @&amp;quot;&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;参考文档&#34;&gt;参考文档&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.cnbang.net/tech/2698/&#34;&gt;React Native通信机制详解&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://awhisper.github.io/2016/06/24/ReactNative%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/&#34;&gt;ReactNative iOS源码解析&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>iOS多线程中的锁</title>
      <link>https://linkrober.github.io/bookshelf/2017/12/ios%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD%E7%9A%84%E9%94%81/</link>
      <pubDate>Fri, 01 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://linkrober.github.io/bookshelf/2017/12/ios%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD%E7%9A%84%E9%94%81/</guid>
      <description>&lt;p&gt;涉及到多线程共享资源的情况下就避免不了资源竞争的问题，这时候就会用到各种锁，例如，&lt;code&gt;@synchronized&lt;/code&gt;、&lt;code&gt;NSLock&lt;/code&gt;、&lt;code&gt;OSSpinLock&lt;/code&gt;等等，虽然都是锁，但是锁的底层实现也不尽相同。大概可以分为：&lt;span class=&#34;highlight-text blue&#34;&gt;互斥锁&lt;/span&gt;、&lt;span class=&#34;highlight-text blue&#34;&gt;自旋锁&lt;/span&gt;、&lt;span class=&#34;highlight-text blue&#34;&gt;递归锁&lt;/span&gt;、
&lt;span class=&#34;highlight-text blue&#34;&gt;读写锁&lt;/span&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
	lock()//加锁
		doSomeThing()//临界区
	unlock()//解锁
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们锁的目的是在任何时刻最多只能有一个线程在修改资源，即在任何时刻只能有一个操作者保持锁。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h4 id=&#34;互斥锁&#34;&gt;互斥锁&lt;/h4&gt;

&lt;p&gt;通过一个全局变量来控制某个线程是否可以在某个时刻访问资源，该变量值大于0说明锁正在被使用。如果某个线程在尝试获得锁的是否发现已经被占用，线程挂起，等待锁的释放。&lt;/p&gt;

&lt;h4 id=&#34;自旋锁&#34;&gt;自旋锁&lt;/h4&gt;

&lt;p&gt;通过一个全局变量来控制某个线程是否可以在某个时刻访问资源，该变量值大于0说明锁正在被使用。如果某个线程在尝试获得锁的是否发现已经被占用，进入忙等状态，直到获得锁。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;以上可以看出，互斥锁和自旋锁很类似，稍有不同的地方在于当处于等待状态的时候各自的线程是怎么调度的。互斥锁即使时间片还未用尽，互斥锁也会直接挂起，这样就减少了CPU的开销。但是这时候会进行上下文（线程）的切换，也会带来一定的开销，适合I/O密集型操作。自旋锁，顾名思义，即使处于等待状态线程也不会挂起，一直处于忙等状态，类似于一直在进行一个whilte循环。这样增加了CPU的开销，所以对于需要保持上下文的任务必须要使用自旋锁，同时它是不能被抢占的（高优先级会抢占低优先级的进程），适用于CPU密集型的任务。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;递归锁&#34;&gt;递归锁&lt;/h4&gt;

&lt;p&gt;对于递归调的时候我们不能简单的使用某个锁来锁住临界区，这样就会造成死锁，必须要使用递归锁。当加锁的时候，变量就会加1，解锁的时候开始减1，直到值为0的时候释放锁。&lt;/p&gt;

&lt;h4 id=&#34;读写锁&#34;&gt;读写锁&lt;/h4&gt;

&lt;p&gt;在上面提到的几种锁同一时刻只允许一个线程访问资源，在操作资源的时候，往往会出现一个线程在写操作，一个线程在读操作，这时候我们就会用到读写锁。
读写锁，它分为两种锁，读锁和写锁。当一个线程在读资源的时候，我们为其加上读锁，有另一个线程也要访问资源的时候我们需要再加一个读锁。当第三个线程需要进行写操作的时候我们就要加上一个写锁，但是这个写锁只有当读锁的使用者为0的时候才有效。也就是说我们必须等另外两个线程的读操作结束之后才能为其加上写锁。虽然互斥锁和自旋锁也能达到要求，但是读写锁无疑让控制更加精细，节省了CPU。&lt;/p&gt;

&lt;h4 id=&#34;ios中的锁&#34;&gt;iOS中的锁&lt;/h4&gt;

&lt;p&gt;大神ibireme的一篇博客&lt;a href=&#34;https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/&#34;&gt;不再安全的 OSSpinLock&lt;/a&gt;对锁的性能做了简单的比较，大家可以看下。
&lt;img src=&#34;../../../来自ibireme的博客.png&#34; alt=&#34;来自ibireme的博客&#34; /&gt;&lt;/p&gt;

&lt;h6 id=&#34;osspinlock&#34;&gt;OSSpinLock&lt;/h6&gt;

&lt;span class=&#34;highlight-text blue&#34;&gt;自旋锁&lt;/span&gt;

&lt;p&gt;在此之前OSSpinLock是无疑性能最好的锁，在2015年的时候苹果工程师透露出了自旋锁的bug。具体问题大概如下：
系统维护了不同等级优先级的线程，高优先级的线程更容易获得系统资源。当一个低优先级的线程先获得锁之后，高优先级线程这时候也试图获取锁。这时候高优先级占据了大量的CPU，一直处于忙等状态。而低优先级的线程因为没有分配到足够的CPU一直无法完成任务，也就无法释放锁。这时候线程的调度就产生了优先级翻转。&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;&lt;/b&gt;
&lt;span class=&#34;highlight-text success&#34;&gt;
Example
&lt;/span&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//定义OSSpinLock锁
__block OSSpinLock theLock = OS_SPINLOCK_INIT;
//线程1
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    OSSpinLockLock(&amp;amp;theLock); 
    NSLog(@&amp;quot;需要线程同步的操作1 开始&amp;quot;); 
    sleep(3); 
    NSLog(@&amp;quot;需要线程同步的操作1 结束&amp;quot;);
    OSSpinLockUnlock(&amp;amp;theLock);
});
//线程2
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
     OSSpinLockLock(&amp;amp;theLock); 
     sleep(1); 
     NSLog(@&amp;quot;需要线程同步的操作2&amp;quot;); 
     OSSpinLockUnlock(&amp;amp;theLock);
});

&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&#34;sychronized&#34;&gt;sychronized&lt;/h6&gt;

&lt;p&gt;&lt;span class=&#34;highlight-text blue&#34;&gt;互斥锁&lt;/span&gt; &lt;span class=&#34;highlight-text blue&#34;&gt;递归锁&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;iOS中性能最差的锁，但是写起来很开心，用起来简单，无论普通的锁还是递归锁都能应对。它牺牲了性能，保证了接口得友好。它会把每个传入的对象当作锁（这要求我们要保证对象的唯一性）并把他们放在一个哈希表中存储，通过这张表来管理锁。要注意的是，对象不能为&lt;strong&gt;nil&lt;/strong&gt;，这会让临界区不再是线程安全的。&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;&lt;/b&gt;&lt;/p&gt;

&lt;span class=&#34;highlight-text success&#34;&gt;
Example
&lt;/span&gt;

&lt;pre&gt;&lt;code&gt;//需要加锁的对象
NSObject *obj = [[NSObject alloc] init];
//线程1
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    @synchronized(obj) {
         NSLog(@&amp;quot;需要线程同步的操作1 开始&amp;quot;);
         sleep(3); 
         NSLog(@&amp;quot;需要线程同步的操作1 结束&amp;quot;);
     } 
  }); 
//线程2
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ 
    sleep(1); 
    @synchronized(obj) { 
         NSLog(@&amp;quot;需要线程同步的操作2&amp;quot;); 
     } 
});

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Result&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ThreadTest[13438:385647] 需要线程同步的操作1 开始
ThreadTest[13438:385647] 需要线程同步的操作1 结束
ThreadTest[13438:385646] 需要线程同步的操作2
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&#34;nslock&#34;&gt;NSLock&lt;/h6&gt;

&lt;span class=&#34;highlight-text blue&#34;&gt;互斥锁&lt;/span&gt;

&lt;p&gt;将C语言的pthread_mutex锁进行了一次封装，更加的OC。&lt;code&gt;NSLock&lt;/code&gt;提供了&lt;code&gt;tryLock&lt;/code&gt;和&lt;code&gt;lockBeforeDate:&lt;/code&gt;方法。在加锁前尝试加锁，如果返回无法获得锁，并不会阻塞线程会继续往下走，返回&lt;code&gt;NO&lt;/code&gt;,&lt;code&gt;lockBeforeDate:&lt;/code&gt;让你控制加锁的时间，在规定时间未获得锁返回&lt;code&gt;NO&lt;/code&gt;
&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;&lt;/b&gt;
&lt;span class=&#34;highlight-text success&#34;&gt;
Example
&lt;/span&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//创建锁
NSLock *lock = [[NSLock alloc] init];
//线程1
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ 
    //[lock lock]; 
    //立即加锁
    [lock lockBeforeDate:[NSDate date]];
    NSLog(@&amp;quot;需要线程同步的操作1 开始&amp;quot;); 
    sleep(2); 
    NSLog(@&amp;quot;需要线程同步的操作1 结束&amp;quot;); 
    [lock unlock];
});
//线程2
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    sleep(1);
    //尝试加锁
    if ([lock tryLock]) {
        //尝试获取锁，如果获取不到返回NO，不会阻塞该线程 
        NSLog(@&amp;quot;锁可用的操作&amp;quot;); 
        [lock unlock]; 
    }else{
        NSLog(@&amp;quot;锁不可用的操作&amp;quot;); 
    } 
    
    NSDate *date = [[NSDate alloc] initWithTimeIntervalSinceNow:3]; 
    if ([lock lockBeforeDate:date]) {
          //尝试在未来的3s内获取锁，并阻塞该线程，如果3s内获取不到恢复线程, 返回NO,不会阻塞该线程
          NSLog(@&amp;quot;没有超时，获得锁&amp;quot;); 
          [lock unlock]; 
     }else{ 
          NSLog(@&amp;quot;超时，没有获得锁&amp;quot;); 
     } 
});

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Result&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ThreadTest[13541:394814] 需要线程同步的操作 1 开始
ThreadTest[13541:394804] 锁不可用的操作
ThreadTest[13541:394814] 需要线程同步的操作 1 结束
ThreadTest[13541:394804] 没有超时，获得锁
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&#34;nsrecursivelock&#34;&gt;NSRecursiveLock&lt;/h6&gt;

&lt;p&gt;&lt;span class=&#34;highlight-text blue&#34;&gt;互斥锁&lt;/span&gt; &lt;span class=&#34;highlight-text blue&#34;&gt;递归锁&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;实现和&lt;code&gt;NSLock&lt;/code&gt;差不多，只不过在底层NSLock使用的C的&lt;code&gt;pthread_mutex_lock&lt;/code&gt;,而&lt;code&gt;NSRecursiveLock&lt;/code&gt;使用的是&lt;code&gt;pthread_mutex_recursive&lt;/code&gt;。
它也同样提供了&lt;code&gt;- (BOOL)tryLock&lt;/code&gt;和&lt;code&gt;- (BOOL)lockBeforeDate:(NSDate *)limit&lt;/code&gt;方法&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;&lt;/b&gt;
&lt;span class=&#34;highlight-text success&#34;&gt;
Example
&lt;/span&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//NSLock *lock = [[NSLock alloc] init];
NSRecursiveLock *lock = [[NSRecursiveLock alloc] init];
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ 
    static void (^RecursiveMethod)(int); 
    RecursiveMethod = ^(int value) { 
        [lock lock]; 
        if (value &amp;gt; 0) { 
            NSLog(@&amp;quot;value = %d&amp;quot;, value); 
            sleep(1); 
            RecursiveMethod(value - 1); 
      } 
        [lock unlock]; 
    };
     RecursiveMethod(5); 
});

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果使用&lt;code&gt;NSLock&lt;/code&gt;就会直接死锁。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Result&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ThreadTest[13593:400360] value = 5
ThreadTest[13593:400360] value = 4
ThreadTest[13593:400360] value = 4
ThreadTest[13593:400360] value = 2
ThreadTest[13593:400360] value = 1
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&#34;nscondition&#34;&gt;NSCondition&lt;/h6&gt;

&lt;p&gt;&lt;span class=&#34;highlight-text blue&#34;&gt;互斥锁&lt;/span&gt; &lt;span class=&#34;highlight-text blue&#34;&gt;条件变量&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;条件变量和信号量很类似，提供了阻塞、等待就绪、唤醒线程的方法。比如，生产-消费者模式。
在单线程执行中，我们经常会通过一个布尔值来控制某个方法或者值是否需要被执行和修改。在多线程的环境下，需要互斥锁来配合保证线程安全。&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;&lt;/b&gt;
&lt;span class=&#34;highlight-text success&#34;&gt;
Example
&lt;/span&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NSConditionLock *lock = [[NSConditionLock alloc] init];
NSMutableArray *products = [NSMutableArray array]; 
NSInteger HAS_DATA = 1; 
NSInteger NO_DATA = 0;

dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ 
    while (1) { 
        [lock lockWhenCondition:NO_DATA]; 
        [products addObject:[[NSObject alloc] init]]; 
        NSLog(@&amp;quot;produce a product,总量:%zi&amp;quot;,products.count); 
        [lock unlockWithCondition:HAS_DATA]; 
        sleep(1); 
   } 
}); 

dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ 
    while (1) { 
         NSLog(@&amp;quot;wait for product&amp;quot;); 
         [lock lockWhenCondition:HAS_DATA]; 
         [products removeObjectAtIndex:0]; 
         NSLog(@&amp;quot;custome a product&amp;quot;); 
         [lock unlockWithCondition:NO_DATA]; 
    } 
});

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Result&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ThreadTest[13645:406942] wait for product
ThreadTest[13645:406951] produce a product, 总量 :1
ThreadTest[13645:406942] custome a product
ThreadTest[13645:406942] wait for product
ThreadTest[13645:406951] produce a product, 总量:1
ThreadTest[13645:406942] custome a product
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;只有当&lt;code&gt;unlock&lt;/code&gt;和&lt;code&gt;lock&lt;/code&gt;的值一一对应才能唤醒线程，执行后续操作。&lt;/p&gt;

&lt;h4 id=&#34;参考资料&#34;&gt;参考资料&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/&#34;&gt;不再安全的 OSSpinLock&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://casatwy.com/pthreadde-ge-chong-tong-bu-ji-zhi.html&#34;&gt;pthread的各种同步机制&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://bestswifter.com/ios-lock/&#34;&gt;深入理解 iOS 开发中的锁&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.jianshu.com/p/4edf98a61483&#34;&gt;IOS 保证线程同步方式&amp;amp;性能对比&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/lattera/glibc/blob/master/nptl/pthread_mutex_lock.c&#34;&gt;pthreadmutexlock.c 源码&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://yulingtianxia.com/blog/2015/11/01/More-than-you-want-to-know-about-synchronized/&#34;&gt;关于 @synchronized，这儿比你想知道的还要多&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://pubs.opengroup.org/onlinepubs/7908799/xsh/pthread_mutex_lock.html&#34;&gt;pthreadmutexlock&lt;/a&gt;
&lt;a href=&#34;https://developer.apple.
com/library/content/documentation/Cocoa/Conceptual/Multithreading/ThreadSafety/ThreadSafety.html&#34;&gt;ThreadSafety&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://stackoverflow.com/questions/62814/difference-between-binary-semaphore-and-mutex&#34;&gt;Difference between binary semaphore and mutex&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.csdn.net/Javadino/article/details/2891388&#34;&gt;[Pthread] Linux中的线程同步机制(二)&amp;ndash;In Glibc&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://android.googlesource.com/platform/external/pthreads/+/master/pthread_cond_wait.
c&#34;&gt;pthreadcondwait&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://stackoverflow.com/questions/3513045/conditional-variable-vs-semaphore&#34;&gt;Conditional Variable vs Semaphore&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>快速排序</title>
      <link>https://linkrober.github.io/bookshelf/2017/12/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Fri, 01 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://linkrober.github.io/bookshelf/2017/12/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</guid>
      <description>&lt;span class=&#34;highlight-text primary&#34;&gt;
故事
&lt;/span&gt;

&lt;p&gt;快速排序由&lt;strong&gt;C.A.R.Hoare（东尼霍尔）&lt;/strong&gt;在1960年提出。之后又有许多人对此进行改进。如果你对快速排序感兴趣可以去看看东尼霍尔1962年在Computer Journal发表的论文“Quicksort”以及《算法导论》的第七章。&lt;/p&gt;

&lt;p&gt;&lt;/b&gt;
&lt;span class=&#34;highlight-text primary&#34;&gt;
基本思想
&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;通过一次排序将需要排序的数组分割成两部分,一部分的值比另一部分要小。再将这两个部分通过上面的方式排序，以此类推。最后分割成了很小的一部分，直到每个数字。整个排序的过程我们可以通过递归的方式进行。&lt;/p&gt;

&lt;p&gt;&lt;/b&gt;
&lt;span class=&#34;highlight-text primary&#34;&gt;
时间复杂度
&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;快速排序之所比较快，因为相比冒泡排序，每次交换是跳跃式的。每次排序的时候设置一个基准点，将小于等于基准点的数全部放到基准点的左边，将大于等于基准点的数全部放到基准点的右边。这样在每次交换的时候就不会像冒泡排序一样每次只能在相邻的数之间进行交换，交换的距离就大的多了。因此总的比较和交换次数就少了，速度自然就提高了。当然在最坏的情况下，仍可能是相邻的两个数进行了交换。因此快速排序的最差时间复杂度和冒泡排序是一样的都是O(N2)，它的平均时间复杂度为O(NlogN)。&lt;/p&gt;

&lt;p&gt;&lt;/b&gt;
&lt;span class=&#34;highlight-text primary&#34;&gt;
Example：演示第一轮排序
&lt;/span&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;5 7 6 4 3 1 9 8 0 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对上面的数进行排序,先定义一个基准数：&lt;strong&gt;5&lt;/strong&gt;。比较从两边进行，一边是从索引为0的开始，如果遇到比5大的就停下；另一边是从索引为9的开始，如果遇到比5小的就停下。然后交换两遍的数。在第一轮中，从左边开始比较的在遇到7之后就会停下来，因为7比5大；从右边开始的遇到2就会停下来，因为2比5小。然后交换两个人的位置。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;5 2 6 4 3 1 9 8 0 7
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;继续走，6比5大，0比5小，交换&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;5 2 0 4 3 1 9 8 6 7
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;继续走，左边的遇到了9，比5大，停下来；右边的经过8，快要和左边的相遇了停下来。这时候当把9和5交换的时候发现排序后5左边并没有都比右边小&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;9 2 0 4 3 1 5 8 6 7
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;alert danger &#34;&gt;
  &lt;p&gt;注意这里我们刚开始的时候就先后顺序走错了，应该右边的先比较。&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;纠正一下，重新开始，最后一步比较的时候：这时候右边的先到1，发现1比5小停下。等左边的和右边的相遇时。将右边的1和基准数5交换，如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1 2 0 4 3 5 9 8 6 7
&lt;/code&gt;&lt;/pre&gt;

&lt;span class=&#34;highlight-text primary&#34;&gt;
Code
&lt;/span&gt;

&lt;pre&gt;&lt;code&gt;int a[10] = {6,1,2,7,9,3,4,5,10,8};

void quickSort(int left,int right){
    int i,j,t,temp;
    if(left &amp;gt; right){
        return;
    }
    
    temp = a[left];
    i = left;
    j = right;
    
    while (i!=j) {
        while (a[j] &amp;gt; temp &amp;amp;&amp;amp; i &amp;lt; j) {
            j--;
        }
        while (a[i] &amp;lt;= temp &amp;amp;&amp;amp; i &amp;lt; j) {
            i++;
        }
        
        if(i &amp;lt; j){
            t = a[i];
            a[i] = a[j];
            a[j] = t;
        }
    }
    a[left] = a[i];
    a[i] = temp;
    
    quickSort(left, i - 1);
    quickSort(i + 1, right);
}

int main(int argc, const char * argv[]) {
    // insert code here...
    quickSort(0, 9);
    for(int i = 0 ; i &amp;lt; 10;i++){
        printf(&amp;quot;%d &amp;quot;,a[i]);
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>一个音视频厂的图像处理流程概述</title>
      <link>https://linkrober.github.io/bookshelf/2017/11/%E4%B8%80%E4%B8%AA%E9%9F%B3%E8%A7%86%E9%A2%91%E5%8E%82%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B%E6%A6%82%E8%BF%B0/</link>
      <pubDate>Mon, 27 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://linkrober.github.io/bookshelf/2017/11/%E4%B8%80%E4%B8%AA%E9%9F%B3%E8%A7%86%E9%A2%91%E5%8E%82%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B%E6%A6%82%E8%BF%B0/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/1086250-3eac00965effbe70?imageMogr2/auto-orient/strip%7CimageView2/2/w/320&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;视频编辑分为两部分：&lt;strong&gt;Camrea Engine（视频资源采集）&lt;/strong&gt;和&lt;strong&gt;Video Edit Engine（后期视频编辑）&lt;/strong&gt;。在Camrea Engine采集的时候我们也可以做一些编辑操作，这叫预处理，比如说加滤镜。等到把采集到的资源交给Video Edit Engine时就是后处理。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;Camera Engine是通过把被摄对象的光信号转变成相应的电信号，这时候还是模拟信号，经过采样、量化、编码，形成数字信号，计算机就可以用0和1来记录它，最终保存到磁盘上。&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;highlight-text blue&#34;&gt;这里先阐述一下基本知识：&lt;/span&gt;&lt;/br&gt;
滤镜是怎么加上去的呢？这要从图片说起。其实视频就是很多张图片连续播放形成的。人眼为什么可以看到东西，物体通过漫反射把光子打到视网膜上，而这个影像在视网膜上消失需要一段时间，这就是残影。经过试验只要两张图片的切换在1/24秒人眼是分辨不出来的，那么对人来说它就是连续的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/1086250-f7df91c7c0967686?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在胶卷时代是每秒要求24张，数字时期是达到了每秒30张，就算中间丢了6张图片我们也是不知道的，增加了视频处理的容错率，下面我们专业一点，用帧来代表一张图。那么一帧是怎么构成的呢，每帧上的色彩都是通过RGB三原色各种不同的组合呈现给我们的。在我们的日常生活中经常会听分辨率1080920类似的词，它说的就是在这个屏幕上有横向有920个像素，纵向有1080个像素，每个像素就是一个色点。把图片放大，你就可以清晰的看到图片是由一个个小方块构成的，每个方块都有自己的颜色。这里的颜色就是通过RGB三原色叠加而成的，而RGB每个都有256种亮度，从0到255。那么总共就能组合出256256*256=16777216种颜色，很多吧。&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;highlight-text blue&#34;&gt;到这里基本知识我们铺垫的差不多了&lt;/span&gt;&lt;/br&gt;
再回到加滤镜的话题，在业务层开发中我们加滤镜其实是加入了一种可以让Camera Engine识别的描述，它描述了每一帧上的每一个像素如何被“修改”，这里的“修改”可以是直接修改像点的RBG值，也可以是在这一帧上叠加一层(当然也可以叠加多层)。肉眼就会看到和原来视频不同的滤镜效果。有的滤镜亮，有的滤镜暗等等，其实最终就是通过调整GRB的亮度来实现的。到这里就是是视频的预处理。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/1086250-b0f7dc9db4e364fc?imageMogr2/auto-orient/strip%7CimageView2/2/w/320&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Video Edit Engine&lt;/strong&gt;设计到一下几个部分：storyboard、clip、stream、producer、effect和player。&lt;/p&gt;

&lt;p&gt;storyboard相当于一个画布，这是一个抽象的概念，便于我们理解视频编辑，所有的编辑操作我们都在这上面进行。上面放的就是视频、图片，这里并不是指视频、图片的原文件，而是对原文件的描述。比如视频的起始时间和终止时间、视频的路径，方向等等。这种描述是通过一种面向对象的类clip体现的。一个storyboard上可以有很多段描述文件clip，它们是有序的，可修改的。这时候我们也可以为clip添加effect。effect可以理解为修改视频的描述文件的抽象类（我们使用的素材template就是effect更上层的抽象）。在storyboard导出成视频或图片的时候，它告诉Engine怎么修改视频的，最终也是通过修改每一帧上的像素点来实现的。
&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/1086250-765d8bfa6eb45e74?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在导出的时候需要经过进一步封装，把storyboard封装成stream，它会将文件进行解码，根据effect对clip的描述，通过producer生成一个用户想要的视频。只有通过stream才能压缩编码成本地的文件或者解码成比特流让播放器player来使用。所以stream起到了一个对VF（视频）和AF（音频）编解码的作用。这里就是视频的后处理。&lt;/p&gt;

&lt;p&gt;到这里就是一些视频相关的厂视频图片编辑的大概思路。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>RCTRootView、RCTBridge做了什么</title>
      <link>https://linkrober.github.io/bookshelf/2017/10/rctrootviewrctbridge%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88/</link>
      <pubDate>Sat, 28 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>https://linkrober.github.io/bookshelf/2017/10/rctrootviewrctbridge%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88/</guid>
      <description>&lt;p&gt;本系列文章作为学习RN期间的总结&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://linkrober.github.io/bookshelf/2017/10/react-native%E5%A6%82%E4%BD%95%E9%9B%86%E6%88%90%E5%88%B0%E7%8E%B0%E6%9C%89%E9%A1%B9%E7%9B%AE%E4%B8%AD/&#34;&gt;React Native如何集成到现有项目中&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://linkrober.github.io/bookshelf/2017/10/react-native%E5%92%8Cnative%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1/&#34;&gt;React Native和Native间的通信实践&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;RCTRootView、RCTBridge做了什么&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://linkrober.github.io/bookshelf/2017/12/native%E5%92%8Cjs%E9%80%9A%E4%BF%A1%E6%A6%82%E8%BF%B0/&#34;&gt;Object-C和JS通信概述&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;本章主要讨论，RCTRootView、RCTBridge彼此之间的关系，以及它们做了什么。先放上类图&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../../../相关类图.png&#34; alt=&#34;相关类图&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;rctrootview&#34;&gt;RCTRootView&lt;/h4&gt;

&lt;p&gt;它是RN在Native上展示的容器，&lt;code&gt;RCTJavaScriptWillStartLoadingNotification&lt;/code&gt;、&lt;code&gt;RCTJavaScriptDidLoadNotification&lt;/code&gt;、&lt;code&gt;RCTContentDidAppearNotification&lt;/code&gt;这些通知注册都在里面。同时也是运行js的入口。&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;highlight-text blue&#34;&gt;RCTJavaScriptWillStartLoadingNotification&lt;/span&gt;&lt;/br&gt;
当你在Debug模式下，选择&lt;strong&gt;Live Reload&lt;/strong&gt;每次保存js文件的时候就会重新加载js。之前的&lt;code&gt;reactTag&lt;/code&gt;会清空，等待重新赋值，但第一次初始化并不会触发这个通知。因为通知这时候还没注册。&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;highlight-text blue&#34;&gt;RCTJavaScriptDidLoadNotification&lt;/span&gt;&lt;/br&gt;
同样的在&lt;strong&gt;Live Reload&lt;/strong&gt;模式下，每次保存，才会正真的重新加载js，完毕之后，开始视图view的重新初始化即，&lt;code&gt;RCTRootContentView&lt;/code&gt;，然后&lt;code&gt;RCTRootView&lt;/code&gt;会通过bridge发送消息&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (void)enqueueJSCall:(NSString *)module 
			   method:(NSString *)method 
			     args:(NSArray *)args 
		   completion:(dispatch_block_t)completion;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它把模块名称，方法名和在native中定义的属性（上一节提到的properies）发送到js端，让js端完整的逻辑渲染&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;它们是如何控制在第一次初始化rootview的时候不执行&lt;code&gt;RCTJavaScriptDidLoadNotification&lt;/code&gt;这个通知定义的事件的呢？是通过下面的判断&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt; RCTBridge *bridge = notification.userInfo[@&amp;quot;bridge&amp;quot;];
  if (bridge != _contentView.bridge) {
    [self bundleFinishedLoading:bridge];
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;alert danger &#34;&gt;
  &lt;p&gt;&lt;code&gt;RCTBatchedBridge.mm&lt;/code&gt;是&lt;code&gt;RCTBridge.m&lt;/code&gt;的子类，但是在后面可能会废弃。&lt;code&gt;RCTBridge&lt;/code&gt;通过一种向下转型的方式，让其拥有了子类的能力。&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span class=&#34;highlight-text blue&#34;&gt;RCTContentDidAppearNotification&lt;/span&gt;&lt;/br&gt;
在视图出来的时候RN会通过这个通知隐藏loading页面，loading页面也是可以自定义的，通过重新它的&lt;code&gt;setLoadingView:&lt;/code&gt;方法。&lt;/p&gt;

&lt;span class=&#34;highlight-text yellow&#34;&gt;总结：&lt;/span&gt;

&lt;ul&gt;
&lt;li&gt;负责RN和Native通信的&lt;code&gt;RCTBridge&lt;/code&gt;实例的初始化。&lt;/li&gt;
&lt;li&gt;正真用来展示视图的&lt;code&gt;RCTRootContentView&lt;/code&gt;的初始化，完事后通过&lt;code&gt;[self insertSubview:_contentView atIndex:0];&lt;/code&gt;的方式加到rootview上。&lt;/li&gt;
&lt;li&gt;负责loading视图的展示和隐藏。&lt;/li&gt;
&lt;li&gt;负责在刷新视图时清空reactTag，它是也是区分js中每个view的identifier。&lt;/li&gt;
&lt;li&gt;负责通知&lt;code&gt;RCTBridge&lt;/code&gt;在合适的时候向JS发送已经准备好的信息，模块名，方法名、参数一起传递过去。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;rctbridge&#34;&gt;RCTBridge&lt;/h4&gt;

&lt;p&gt;所有的模块都保存在内存的静态常量区域，这个内存空间是在&lt;code&gt;RCTBridge&lt;/code&gt;中被初始化的。因此这些模块属于全局的变量，可以在不同的bridge之间共享。可以通过&lt;code&gt;NSString *RCTBridgeModuleNameForClass(Class cls)&lt;/code&gt;拿到每个模块的名称。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NSString *RCTBridgeModuleNameForClass(Class cls)
{
#if RCT_DEBUG
  RCTAssert([cls conformsToProtocol:@protocol(RCTBridgeModule)],
            @&amp;quot;Bridge module `%@` does not conform to RCTBridgeModule&amp;quot;, cls);
#endif

  NSString *name = [cls moduleName];
  if (name.length == 0) {
    name = NSStringFromClass(cls);
  }

  if ([name hasPrefix:@&amp;quot;RK&amp;quot;]) {
    name = [name substringFromIndex:2];
  } else if ([name hasPrefix:@&amp;quot;RCT&amp;quot;]) {
    name = [name substringFromIndex:3];
  }

  return name;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从上面的代码可以看出，在native中定义的模块在被传递到js的时候会加上&lt;code&gt;RK&lt;/code&gt;或者&lt;code&gt;RCT&lt;/code&gt;前缀。&lt;/p&gt;

&lt;div class=&#34;alert info no-icon &#34;&gt;
  &lt;p&gt;模块都是遵循&lt;code&gt;RCTBridgeModule&lt;/code&gt;协议的，用宏&lt;code&gt;RCT_EXPORT_MODULE();&lt;/code&gt;进行声明；&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;JS队列的初始化会在&lt;code&gt;RCTBridge&lt;/code&gt;被调用到的时候通过&lt;code&gt;+ (void)initialize&lt;/code&gt;进行初始化，而且它是一个单列对象。通过C的&lt;code&gt;extern __attribute__((visibility(&amp;quot;default&amp;quot;)))&lt;/code&gt;暴露出来，让该队列变量暴露在动态链接库之外&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dispatch_queue_t RCTJSThread;

+ (void)initialize
{
  static dispatch_once_t onceToken;
  dispatch_once(&amp;amp;onceToken, ^{

    // Set up JS thread
    RCTJSThread = (id)kCFNull;
  });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每一个当前视图正在使用的bridge也会放在静态常量区，每次视图切换的时候都会重新赋值。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static RCTBridge *RCTCurrentBridgeInstance = nil;

/**
 * The last current active bridge instance. This is set automatically whenever
 * the bridge is accessed. It can be useful for static functions or singletons
 * that need to access the bridge for purposes such as logging, but should not
 * be relied upon to return any particular instance, due to race conditions.
 */
+ (instancetype)currentBridge
{
  return RCTCurrentBridgeInstance;
}

+ (void)setCurrentBridge:(RCTBridge *)currentBridge
{
  RCTCurrentBridgeInstance = currentBridge;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在&lt;code&gt;RCTBridge&lt;/code&gt;的初始化方法中同时还会对&lt;code&gt;RCTBatchedBridge&lt;/code&gt;进行初始化，由其发送消息开始加载js。其中分为两步：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;初始化modul和load资源&lt;/li&gt;
&lt;li&gt;设置JS的Executor和modul的配置&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;它们在同一个队列&lt;code&gt;dispatch_queue_t bridgeQueue = dispatch_queue_create(&amp;quot;com.facebook.react.RCTBridgeQueue&amp;quot;, DISPATCH_QUEUE_CONCURRENT);&lt;/code&gt;里的两个不同的group中异步执行：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;dispatch_group_t initModulesAndLoadSource = dispatch_group_create();&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dispatch_group_t setupJSExecutorAndModuleConfig = dispatch_group_create();&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因为在第一个group中的异步方法中也存在异步操作所有作者使用的&lt;code&gt;dispatch_group_enter()&lt;/code&gt; 和 &lt;code&gt;dispatch_group_leave()&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;第二个group直接用的&lt;code&gt;dispatch_group_async(dispatch_group_t  _Nonnull group, dispatch_queue_t  _Nonnull queue, ^(void)block)&lt;/code&gt;
当第二group的异步任务完成之后（&lt;code&gt;initModulesAndLoadSource&lt;/code&gt;依赖&lt;code&gt;setupJSExecutorAndModuleConfig&lt;/code&gt;），就开始执行对应的notify闭包向js注入json字符串&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dispatch_group_notify(setupJSExecutorAndModuleConfig, bridgeQueue, ^{
      // We&#39;re not waiting for this to complete to leave dispatch group, since
      // injectJSONConfiguration and executeSourceCode will schedule operations
      // on the same queue anyway.
      [performanceLogger markStartForTag:RCTPLNativeModuleInjectConfig];
      [weakSelf injectJSONConfiguration:config onComplete:^(NSError *error) {
        [performanceLogger markStopForTag:RCTPLNativeModuleInjectConfig];
        if (error) {
          RCTLogWarn(@&amp;quot;Failed to inject config: %@&amp;quot;, error);
          dispatch_async(dispatch_get_main_queue(), ^{
            [weakSelf stopLoadingWithError:error];
          });
        }
      }];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;待第二个group结束，开始执行第一个group对应的notify闭包,开始加载js，加载结束之后发出&lt;code&gt;RCTJavaScriptDidLoadNotification&lt;/code&gt;通知。&lt;/p&gt;

&lt;div class=&#34;alert info no-icon &#34;&gt;
  &lt;p&gt;执行JS所有相关的内容都是&lt;code&gt;@protocol RCTJavaScriptExecutor&lt;/code&gt;这个协议负责，定义在bridge中&lt;code&gt;@property (nonatomic, weak, readonly) id&amp;lt;RCTJavaScriptExecutor&amp;gt; javaScriptExecutor;&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;当你在Debug模式下save或者退出当前页面的时候收到reload命令，该类会在主线程中将当前的bridge置空，如果没有成功会调用其所遵循的协议&lt;code&gt;@protocol RCTInvalidating&lt;/code&gt;中的&lt;code&gt;invalidate&lt;/code&gt;方法进行一系列的局部变量释放操作&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (void)invalidate
{
  RCTBridge *batchedBridge = self.batchedBridge;
  self.batchedBridge = nil;

  if (batchedBridge) {
    RCTExecuteOnMainQueue(^{
      [batchedBridge invalidate];
    });
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;span class=&#34;highlight-text yellow&#34;&gt;总结：&lt;/span&gt;

&lt;ul&gt;
&lt;li&gt;保存模块的集合 &amp;ndash;&lt;code&gt;RCTModuleClasses&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;定义了JS队列 &amp;ndash; &lt;code&gt;dispatch_queue_t RCTJSThread&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;定义当前正在使用的bridge，并负责切换&lt;/li&gt;
&lt;li&gt;负责&lt;code&gt;RCTBatchedBridge&lt;/code&gt;的初始化，调用子类bridge，开始执行加载js的一系列操作&lt;/li&gt;
&lt;li&gt;负责在view消失或者重新加载的时候释放之前的一些对象（eg. currentbridge,遵循&lt;code&gt;RCTBridgeModule&lt;/code&gt;协议的对象）。&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>React Native和Native间的通信实践</title>
      <link>https://linkrober.github.io/bookshelf/2017/10/react-native%E5%92%8Cnative%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E5%AE%9E%E8%B7%B5/</link>
      <pubDate>Wed, 25 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>https://linkrober.github.io/bookshelf/2017/10/react-native%E5%92%8Cnative%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E5%AE%9E%E8%B7%B5/</guid>
      <description>&lt;!-- thumbnailImage = &#39;rn_image.jpeg&#39;
thumbnailImagePosition = &#39;bottom&#39; --&gt;

&lt;p&gt;本系列文章作为学习RN期间的总结&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://linkrober.github.io/bookshelf/2017/10/react-native%E5%A6%82%E4%BD%95%E9%9B%86%E6%88%90%E5%88%B0%E7%8E%B0%E6%9C%89%E9%A1%B9%E7%9B%AE%E4%B8%AD/&#34;&gt;React Native如何集成到现有项目中&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;React Native和Native间的通信实践&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://linkrober.github.io/bookshelf/2017/10/rctrootviewrctbridge%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88/&#34;&gt;RCTRootView、RCTBridge做了什么&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://linkrober.github.io/bookshelf/2017/12/native%E5%92%8Cjs%E9%80%9A%E4%BF%A1%E6%A6%82%E8%BF%B0/&#34;&gt;Object-C和JS通信概述&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;刚开始接触RN，有几点大家都想弄清楚：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;如何从Native向RN传递参数，这里也分为几小点&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;在初始化RN的时候如何从Native传递初始化的参数&lt;/li&gt;
&lt;li&gt;在RN视图已经渲染完成之后，如果从Native那参数&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如何从RN向Native传递参数：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;如何向Native发送消息（能否使用闭包）&lt;/li&gt;
&lt;li&gt;如何让RN接受naitve的异步回调&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;native-rn&#34;&gt;Native -&amp;gt; RN&lt;/h4&gt;

&lt;h6 id=&#34;properties&#34;&gt;Properties&lt;/h6&gt;

&lt;p&gt;&lt;code&gt;properties&lt;/code&gt;是RN和Native间通信最简单的方式。我们只需要在初始化&lt;code&gt;RCTRootView&lt;/code&gt;的时候，将需要的数据通过方法入参的形式传入，它是一个字典类型。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (instancetype)initWithBundleURL:(NSURL *)bundleURL
                       moduleName:(NSString *)moduleName
                initialProperties:&lt;span class=&#34;highlight-text red&#34;&gt;(NSDictionary *)initialProperties&lt;/span&gt;
                    launchOptions:(NSDictionary *)launchOptions
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在RN中我们用来承接&lt;code&gt;initialProperties&lt;/code&gt;参数的就是每个js类的&lt;code&gt;props&lt;/code&gt;。如果我们需要在Native中修改&lt;code&gt;props&lt;/code&gt;属性，就要对&lt;code&gt;RCTRootView&lt;/code&gt;的&lt;code&gt;appProperties&lt;/code&gt;进行重新赋值，然后RN会对视图进行重新渲染，当且仅当两次赋值不一样的时候才会重新渲染。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rootView.appProperties = @{@&amp;quot;content&amp;quot; : imageList};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们也可以使用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (instancetype)initWithBridge:(RCTBridge *)bridge
                    moduleName:(NSString *)moduleName
             initialProperties:(NSDictionary *)initialProperties NS_DESIGNATED_INITIALIZER;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在初始化bridge时以代理的方式将bundleURL传入：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (instancetype)initWithDelegate:(id&amp;lt;RCTBridgeDelegate&amp;gt;)delegate
                   launchOptions:(NSDictionary *)launchOptions;


 @protocol RCTBridgeDelegate &amp;lt;NSObject&amp;gt;

/**
 * The location of the JavaScript source file. When running from the packager
 * this should be an absolute URL, e.g. `http://localhost:8081/index.ios.bundle`.
 * When running from a locally bundled JS file, this should be a `file://` url
 * pointing to a path inside the app resources, e.g. `file://.../main.jsbundle`.
 */
- (NSURL *)sourceURLForBridge:(RCTBridge *)bridge;

@optional 
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;alert warning &#34;&gt;
  &lt;p&gt;需要注意的是，赋值操作必需要放在Native的主线程。而且js中的&lt;code&gt;componentWillReceiveProps&lt;/code&gt;和&lt;code&gt;componentWillUpdateProps&lt;/code&gt;并不会因为重新渲染而被再次调用，你只能在&lt;code&gt;componentWillMount&lt;/code&gt;方法中访问新的&lt;code&gt;props&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;h6 id=&#34;rcteventemitter&#34;&gt;RCTEventEmitter&lt;/h6&gt;

&lt;p&gt;我们可以使用&lt;code&gt;RCTEventEmitter&lt;/code&gt;类来让js监听native的事件，facebook的文档中是这样描述&lt;code&gt;RCTEventEmitter&lt;/code&gt;的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * RCTEventEmitter is an abstract base class to be used for modules that emit
 * events to be observed by JS.
 */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它是一个模块的抽象基类，用来发送被JS监听的事件。我们通过&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (void)sendEventWithName:(NSString *)name body:(id)body
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;方法来完成事件的发送。入参是事件名称和需要携带的参数（Dictionary）。
每一个&lt;code&gt;RCTRootView&lt;/code&gt;都有一个&lt;code&gt;RCTBridge&lt;/code&gt;属性，它是RN中非常重要的一个类，负责Native和JS之间的通信。通过&lt;code&gt;RCTBridge&lt;/code&gt;的:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * Retrieve a bridge module instance by name or class. Note that modules are
 * lazily instantiated, so calling these methods for the first time with a given
 * module name/class may cause the class to be sychronously instantiated,
 * potentially blocking both the calling thread and main thread for a short time.
 */
- (id)moduleForName:(NSString *)moduleName;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;方法，我们可以拿到每个&lt;code&gt;RCTRootView&lt;/code&gt;对应的&lt;code&gt;RCTEventEmitter&lt;/code&gt;实例（它是通过lazy load的方式初始化的），因为这里的&lt;code&gt;moduleName&lt;/code&gt;参数可以是类名也可以是自定义的模块名称，所以在项目中如果出现多个实例，需要在初始化通过view的&lt;code&gt;reactTag&lt;/code&gt;属性来区分。该属性声明在分类&lt;code&gt;UIView+React.h&lt;/code&gt;中。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;RCT_EXPORT_MODULE();

+ (EventEmitterManger *)mangerWithRootView:(RCTRootView *)rootView {
    return [rootView.bridge moduleForName:NSStringFromClass(self)];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样我们就拿到目标RootView对应的&lt;code&gt;RCTEventEmitter&lt;/code&gt;对象。接下来我们需要为事件定义一个identifier，重写&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * Override this method to return an array of supported event names. Attempting
 * to observe or send an event that isn&#39;t included in this list will result in
 * an error.
 */
- (NSArray&amp;lt;NSString *&amp;gt; *)supportedEvents;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;方法，把你方法的identifer作为数组的一个元素返回。这样就可以使用上面所说的方法进行消息的发送了。
到这里Native端的代码已经完成了，下面看在js中如何设置。
我们需要在对应的js中引入一个&lt;code&gt;NativeModules&lt;/code&gt;、&lt;code&gt;NativeEventEmitter&lt;/code&gt;模块，然后获取监听模块的manger&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var raToRnManger = NativeModules.EventEmitterManger
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在js对象的声明周期方法&lt;code&gt;componentWillMount&lt;/code&gt;中设置监听，接下来就等native发送消息了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;componentWillMount(){
         var raToRnMangerEmitter = new NativeEventEmitter(raToRnManger)
          const subscription = raToRnMangerEmitter.addListener(&amp;quot;EventReminder&amp;quot;,
              (reminder) =&amp;gt; {
                  console.log(&amp;quot;test&amp;quot;)
                    this.setState({
                        name:&amp;quot;B&amp;quot;
                    })
              }
          );
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;rn-native&#34;&gt;RN -&amp;gt; Native&lt;/h4&gt;

&lt;h6 id=&#34;rctbridgemodule&#34;&gt;RCTBridgeModule&lt;/h6&gt;

&lt;p&gt;在Native端定义RN模块的时候，让其遵循&lt;code&gt;&amp;lt;RCTBridgeModule&amp;gt;&lt;/code&gt;协议，在实现文件中暴露出你想要从RN向Native发送的消息&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;RCT_EXPORT_METHOD(exampleMethod:(NSString *)name)
{
    NSLog(@&amp;quot;%@&amp;quot;,name);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你想要该方法参数支持闭包，可以使用RN内置的闭包类型&lt;code&gt;RCTResponseSenderBlock&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;RCT_EXPORT_METHOD(exampleCallbackMethod:(RCTResponseSenderBlock)callback)
{
    NSDictionary *param = @{@&amp;quot;letter&amp;quot;:@&amp;quot;B&amp;quot;};
    callback(@[[NSNull null], param]);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在js端，通过&lt;code&gt;NativeModules&lt;/code&gt;模块拿到Native中对应的模块&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var manger = NativeModules.ExportMethodManger
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果RN中某个事件被触发了，直接通过manger向Native发送消息，消息名称正如你在Native中声明的那样&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;onPressLearnMore(){
        manger.exampleMethod(&amp;quot;##############Learn More############&amp;quot;)
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在Native项目中嵌入RN，你绝对不想要在js中再写一套网络请求吧。这时候就会遇到用RN展示UI，而数据请求放在在Native中做的情况。我们可以使用&lt;code&gt;XMLHttpRequest&lt;/code&gt;这类js网络框架，但是这里想说的是&lt;code&gt;async/await&lt;/code&gt;语法，它在ES6中被提供。从命名上一眼就能看出其目的，异步方法等待消息返回。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;async updateEvents(){
        try {
            var events = await manger.findEvents();
            this.setState({
                letter:events[0].letter
            });
          } catch (e) {
            console.error(e);
          }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，如果Native中&lt;code&gt;findEvents&lt;/code&gt;是一个异步的方法就可以在js中等待Native的回调了。&lt;/p&gt;

&lt;div class=&#34;alert info &#34;&gt;
  &lt;p&gt;从JS到Naitve所有的消息都是由&lt;code&gt;NSInvocation&lt;/code&gt;负责转发，后面打算专门开一章讨论这个类在RN中的使用。&lt;/p&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>React Native如何集成到现有项目中</title>
      <link>https://linkrober.github.io/bookshelf/2017/10/react-native%E5%A6%82%E4%BD%95%E9%9B%86%E6%88%90%E5%88%B0%E7%8E%B0%E6%9C%89%E9%A1%B9%E7%9B%AE%E4%B8%AD/</link>
      <pubDate>Mon, 23 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>https://linkrober.github.io/bookshelf/2017/10/react-native%E5%A6%82%E4%BD%95%E9%9B%86%E6%88%90%E5%88%B0%E7%8E%B0%E6%9C%89%E9%A1%B9%E7%9B%AE%E4%B8%AD/</guid>
      <description>&lt;!-- thumbnailImage = &#39;rn_thumbnailImage.jpeg&#39;
thumbnailImagePosition = &#39;bottom&#39; --&gt;

&lt;p&gt;本系列文章作为学习RN期间的总结&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;React Native如何集成到现有项目中&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://linkrober.github.io/bookshelf/2017/10/react-native%E5%92%8Cnative%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1/&#34;&gt;React Native和Native间的通信实践&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://linkrober.github.io/bookshelf/2017/10/rctrootviewrctbridge%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88/&#34;&gt;RCTRootView、RCTBridge做了什么&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://linkrober.github.io/bookshelf/2017/12/native%E5%92%8Cjs%E9%80%9A%E4%BF%A1%E6%A6%82%E8%BF%B0/&#34;&gt;Object-C和JS通信概述&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;虽然ReactNative能做到iOS和Android的大部分逻辑共享一套代码，节约开发成本；拥有像JSPatch那样的热修复功能，为线上问题提供非常灵活的解决方案。但是为什么大部分公司还是持观望态度，或者只在产品的某些部分用RN进行开发呢？&lt;/p&gt;

&lt;p&gt;首先，React Native官方的某些组件仍然存在性能瓶颈，开发复杂场景的时候可能会遇到性能问题，像ListView，动不动就渲染整个视图，虽然推出了FlatList但是也存在着一些其他的Bug。其次，RN的周边生态并不完善，很多OC或Swift上已有的Library在NR上需要通过RN提供的方法重新用JS实现或者需要把这些库桥接到RN。因此大部分公司会选择交互不多，页面不太复杂的场景来尝试。本章，主要介绍如果在已有的App中集成React Native。&lt;/p&gt;

&lt;h4 id=&#34;关键步骤&#34;&gt;关键步骤&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;设置RN的依赖和目录结构&lt;/li&gt;
&lt;li&gt;搞清楚你要在你的项目中使用的RN组件&lt;/li&gt;
&lt;li&gt;使用CocoaPods添加你要使用的RN组件的依赖&lt;/li&gt;
&lt;li&gt;使用npm安装JS组件&lt;/li&gt;
&lt;li&gt;在JavaScript环境下，开发你的RN模块&lt;/li&gt;
&lt;li&gt;添加一个&lt;code&gt;RCTRootView&lt;/code&gt;到你的app。它将会作为容器展示你的RN模块。&lt;/li&gt;
&lt;li&gt;启动RN服务，Run你的App。&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&#34;alert info &#34;&gt;
  &lt;p&gt;前置条件：安装Node、npm最新版本(npm是基于Node实现的包管理工具和iOS的CocoaPod地位相当)&lt;/p&gt;
&lt;/div&gt;

&lt;h6 id=&#34;设置rn的依赖和目录结构&#34;&gt;设置RN的依赖和目录结构&lt;/h6&gt;

&lt;p&gt;为React Native项目创建一个新的文件夹，在文件夹中新建&lt;code&gt;/ios&lt;/code&gt;目录，拷贝所有原项目的内容到&lt;code&gt;/ios&lt;/code&gt;目录下。&lt;/p&gt;

&lt;h6 id=&#34;安装javascript依赖&#34;&gt;安装JavaScript依赖&lt;/h6&gt;

&lt;p&gt;在刚刚新建的文件夹中（即根目录中）创建一个&lt;code&gt;package.json&lt;/code&gt;文件，并添加一下内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;name&amp;quot;: &amp;quot;Snapvote&amp;quot;,
  &amp;quot;version&amp;quot;: &amp;quot;0.0.1&amp;quot;,
  &amp;quot;private&amp;quot;: true,
  &amp;quot;scripts&amp;quot;: {
    &amp;quot;start&amp;quot;: &amp;quot;node node_modules/react-native/local-cli/cli.js start&amp;quot;,
    &amp;quot;test&amp;quot;: &amp;quot;jest&amp;quot;
  },
  &amp;quot;dependencies&amp;quot;: {
    &amp;quot;react&amp;quot;: &amp;quot;16.0.0-alpha.12&amp;quot;,
    &amp;quot;react-native&amp;quot;: &amp;quot;0.48.4&amp;quot;,
    &amp;quot;react-native-vector-icons&amp;quot;: &amp;quot;^4.4.2&amp;quot;,
    &amp;quot;whatwg-fetch&amp;quot;: &amp;quot;^2.0.3&amp;quot;
  },
  &amp;quot;devDependencies&amp;quot;: {
    &amp;quot;babel-jest&amp;quot;: &amp;quot;21.2.0&amp;quot;,
    &amp;quot;babel-preset-react-native&amp;quot;: &amp;quot;4.0.0&amp;quot;,
    &amp;quot;jest&amp;quot;: &amp;quot;21.2.0&amp;quot;,
    &amp;quot;react-test-renderer&amp;quot;: &amp;quot;16.0.0-alpha.12&amp;quot;
  },
  &amp;quot;jest&amp;quot;: {
    &amp;quot;preset&amp;quot;: &amp;quot;react-native&amp;quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下去，安装react和react-native包。打开Terminal，在你项目的根目录下面执行下面命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install --save r16.0.0-alpha.12 react-native
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;alert warning &#34;&gt;
  &lt;p&gt;要确保这里安装的版本和package.json里说明的版本一致&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;执行这个命令之后，将会在项目的根目录下创建一个&lt;code&gt;/node_modules&lt;/code&gt;的目录，这里保存着所有你项目中所需的JavaScript依赖。&lt;/p&gt;

&lt;h6 id=&#34;安装cocoapods&#34;&gt;安装CocoaPods&lt;/h6&gt;

&lt;p&gt;这里就不说了&lt;/p&gt;

&lt;h6 id=&#34;配置cocoapods依赖&#34;&gt;配置CocoaPods依赖&lt;/h6&gt;

&lt;p&gt;在你集成RN到你项目中之前，你需要选择你要使用的React Native库。你将通过CocoaPod库的开发模式将其集成进去。
&lt;img src=&#34;../../../pod_develop.png&#34; alt=&#34;pod_develop&#34; /&gt;
这些库的&lt;code&gt;subspec&lt;/code&gt;文件都会在&lt;code&gt;/node_modules&lt;/code&gt;目录下被说明,最后执行&lt;code&gt;pod install&lt;/code&gt;命令，所有的React Native库依赖到这里就都准备好了。
&lt;img src=&#34;../../../pod_file.png&#34; alt=&#34;pod_file&#34; /&gt;&lt;/p&gt;

&lt;h6 id=&#34;业务代码&#34;&gt;业务代码&lt;/h6&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;创建 &lt;code&gt;index.js&lt;/code&gt; 文件
在项目的根目录下创建&lt;code&gt;index.js&lt;/code&gt;文件，这个文件是你RN项目的
&lt;span class=&#34;highlight-text danger&#34;&gt;
入口
&lt;/span&gt;，所有在Native中要用到的RN模块都在这里面进行注册。例如项目中的投票列表、设置页面等。各个模块的名称要和Native中的模块名称对应。
&lt;img src=&#34;../../../rn_modul.png&#34; alt=&#34;rn_modul&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;添加React Native 代码（JavaScript和CSS）&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;&#39;use strict&#39;;

import React from &#39;react&#39;;
import {
  AppRegistry,
  StyleSheet,
  Text,
  View,
  FlatList,
  NativeModules,
  Image,
  ActivityIndicator,
  TouchableOpacity,
  ScrollView,
  Switch,
  TouchableWithoutFeedback,
  Alert,
  NativeEventEmitter,
  
} from &#39;react-native&#39;;

import StarRatingView from &#39;./starRating.view.js&#39;

var { width, height } = require(&#39;Dimensions&#39;).get(&#39;window&#39;);
var nativeModuleManager = NativeModules.XYRCTBrigeModule;

class SettingsView extends React.PureComponent{

    constructor(props){
        super(props);
    }
    .....
    .....
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在Native中使用&lt;code&gt;RCTRootView&lt;/code&gt;作为RN模块的容器。所有通过RN渲染出来的视图都会展示在该View上。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#import &amp;lt;React/RCTBundleURLProvider.h&amp;gt;
#import &amp;lt;React/RCTRootView.h&amp;gt;

@implementation AppDelegate

- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{
  NSURL *jsCodeLocation;
  &lt;span class=&#34;highlight-text green&#34;&gt;//设置获取JavaScript文件的路径，从服务器或者本地文件获取&lt;/span&gt;
#if DEBUG
  jsCodeLocation = [NSURL URLWithString:@&amp;quot;http://10.0.30.119:8081/index.ios.bundle?platform=ios&amp;quot;];
#else
  jsCodeLocation = [[RCTBundleURLProvider sharedSettings] jsBundleURLForBundleRoot:@&amp;quot;index.ios&amp;quot; fallbackResource:nil];
#endif
  
  &lt;span class=&#34;highlight-text green&#34;&gt;//通过URL、模块名称加载对应的RN视图，生成一个OC对象`RCTRootView`，最后将该View添加到controller的View上&lt;/span&gt;
  RCTRootView *rootView = [[RCTRootView alloc] initWithBundleURL:jsCodeLocation
                                                      moduleName:@&amp;quot;TabberView&amp;quot;
                                               initialProperties:nil
                                                   launchOptions:launchOptions];
  rootView.backgroundColor = [[UIColor alloc] initWithRed:1.0f green:1.0f blue:1.0f alpha:1];
  
  self.window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds];
  UIViewController *rootViewController = [UIViewController new];
  rootViewController.view = rootView;
  self.window.rootViewController = rootViewController;
  [self.window makeKeyAndVisible];
  return YES;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;到这里就完成了一个简单React Native App的集成。&lt;/p&gt;

&lt;h4 id=&#34;测试&#34;&gt;测试&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;因为HTTPS的限制，请将Domain添加到&lt;code&gt;Info.plist&lt;/code&gt;的白名单
&lt;code&gt;
&amp;lt;key&amp;gt;NSAppTransportSecurity&amp;lt;/key&amp;gt;
&amp;lt;dict&amp;gt;
&amp;lt;key&amp;gt;NSExceptionDomains&amp;lt;/key&amp;gt;
&amp;lt;dict&amp;gt;
    &amp;lt;key&amp;gt;localhost&amp;lt;/key&amp;gt;
    &amp;lt;dict&amp;gt;
        &amp;lt;key&amp;gt;NSTemporaryExceptionAllowsInsecureHTTPLoads&amp;lt;/key&amp;gt;
        &amp;lt;true/&amp;gt;
    &amp;lt;/dict&amp;gt;
&amp;lt;/dict&amp;gt;
&amp;lt;/dict&amp;gt;
&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;执行&lt;code&gt;npm start&lt;/code&gt;开启本地服务&lt;/li&gt;
&lt;li&gt;Xcode run.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;相关链接&#34;&gt;相关链接&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;https://facebook.github.io/react-native/docs/integration-with-existing-apps.html&#34;&gt;Integration with Existing Apps&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Runtime(三) 消息转发</title>
      <link>https://linkrober.github.io/bookshelf/2017/10/runtime%E4%B8%89-%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91/</link>
      <pubDate>Mon, 16 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>https://linkrober.github.io/bookshelf/2017/10/runtime%E4%B8%89-%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91/</guid>
      <description>&lt;p&gt;向对象发送一个消息，如果没有处理就会发生错误。但是在产生错误之前，runtime会给接受对象第二次机会来处理消息。
&lt;/p&gt;

&lt;h3 id=&#34;forwarding&#34;&gt;Forwarding&lt;/h3&gt;

&lt;p&gt;向对象发送一个消息，如果没有处理就会发生错误。但是在产生错误之前，runtime会向对象发送&lt;code&gt;forwardInvocation:&lt;/code&gt;消息，消息携带了一个&lt;code&gt;NSInvocation&lt;/code&gt;对象，这个对象里面包裹了原始消息和参数。&lt;/p&gt;

&lt;p&gt;你可以实现&lt;code&gt;forwardInvocation:&lt;/code&gt;方法来处理消息，来避免错误的发生。正如方法名所暗示的&lt;code&gt;forwardInvocation:&lt;/code&gt;一般用来向另一个对象转发消息。&lt;/p&gt;

&lt;p&gt;为了看到转发的过程和结果，我们想象下面的场景：首先，你设计了一个对象能够响应&lt;code&gt;negotiate&lt;/code&gt;方法，你希望它能够响应另外一个对象的消息。无论&lt;code&gt;negotiate&lt;/code&gt;的方法体是在哪里实现的,你可以通过传入&lt;code&gt;negotiate&lt;/code&gt;消息到另一个对象来完成。下一步，假设你想要&lt;code&gt;negotiate&lt;/code&gt;消息的响应可以被另外一个类明确的接受。一种办法是通过继承的方式，让你的类从父类中继承这个方法。但是如果在不同的继承链中，这种方法是不可能实现的。&lt;/p&gt;

&lt;p&gt;即使你的类不能通过继承的方式使用&lt;code&gt;negotiate&lt;/code&gt;方法，我们仍然可以借用下面这种方式，向另一个类对象传递消息。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (id)negotiate
{
    if ( [someOtherObject respondsTo:@selector(negotiate)] )
        return [someOtherObject negotiate];
    return self;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是这种方式有点笨重，特别是如果你有大量的消息需要传递到另一个类的时候。你必须要在一个方法里面覆盖所有你想要调用的其他类的方法。而且，可能有些方法你不能考虑周全。所有的方法集合都依赖于运行时事件，在以后类的实现中作为新的方法发生改变。&lt;/p&gt;

&lt;p&gt;第二次机会被&lt;code&gt;forwardInvocation:&lt;/code&gt;方法所提供，这是一种比较特殊的解决方式，它是动态的而不是静态的。它工作起来就像是：当一个对象不能响应一个消息，因为在消息中没有selector匹配这个方法。runtime会用&lt;code&gt;forwardInvocation:&lt;/code&gt;消息来通知对象。每个对象都从NSObject里继承了&lt;code&gt;forwardInvocation:&lt;/code&gt;方法。但是NSObject只是简单的调用&lt;code&gt;doesNotRecognizeSelector:&lt;/code&gt;。通过重写NSObject版本的实现，你可以利用这次机会，通过&lt;code&gt;forwardInvocation:&lt;/code&gt;消息提供一个方法转发到另一个类中。
为了转发一个消息，所有的&lt;code&gt;forwardInvocation:&lt;/code&gt;方法必须包含下面的两个步骤:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;确定消息的去向&lt;/li&gt;
&lt;li&gt;转发的时候携带原始的参数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;消息可以通过&lt;code&gt;invokeWithTarget:&lt;/code&gt;方法被发送：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (void)forwardInvocation:(NSInvocation *)anInvocation
{
	if ([someOtherObject respondsToSelector:[anInvocation selector]])
		[aInvocation invokeWithTarget:someOtherObject];
	else
		[super forwardInvocation:anInvocation];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;被转发的消息的返回值被返回到原始的sender。所有返回值的类型包括：ids、structures，双精度浮点数。
对于unrecognized消息，&lt;code&gt;forwardInvocation:&lt;/code&gt;方法就像一个消息转发中心，将message包裹起来发送到不同的接受者。或者作为一个中转站，发送所有消息到同样的地方。它可以转发一个消息到另一个。&lt;code&gt;forwardInvocation:&lt;/code&gt;方法可以定位几个消息消息到单一的response。&lt;code&gt;forwardInvocation:&lt;/code&gt;要做的是准备实现。但是，这次机会为转发链中的链接对象提供更多程序设计的可能。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;code&gt;forwardInvocation:&lt;/code&gt;方法开始处理消息，只有它们不能调用在接受者中已经存在的方法时。比如，你想要你的对象去转发&lt;code&gt;negotiate&lt;/code&gt;消息到另一个对象，但对象并没有自己对该消息的实现。如果是这样，消息将永远不会到达&lt;code&gt;forwardInvocation:&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;forwarding-and-multiple-inheritance&#34;&gt;Forwarding and Multiple Inheritance&lt;/h3&gt;

&lt;p&gt;转发可以模仿多继承，可以实现多继承的一些效果。对象通过转发来响应消息，就像是借用或者继承了另一个类的某个方法的实现
&lt;img src=&#34;../../../forwarding.png&#34; alt=&#34;forwarding&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在这个例子中，Warrior类的实例转发一个&lt;code&gt;negotiate&lt;/code&gt;消息到Diplomat类的实例。Warrior可以像Diplomat一样调用negotiate。看起来就像响应&lt;code&gt;negotiate&lt;/code&gt;方法。
对象转发消息，这样“继承”的方法来自两种继承架构链。上面的例子中，它就像Warrior的类继承自Diplomat ，就像子类继承父类一样。&lt;/p&gt;

&lt;p&gt;转发提供了很多特性，一般你可以用它来实现多继承。但是，这和多继承有两个很大不同地方：首先，在一个类中，多继承组合出不同的能力。它趋向于较庞大的多接口对象。另一方面，继承可以区分不同种类的方法到不同的对象。&lt;/p&gt;

&lt;h3 id=&#34;forwarding-and-inheritance&#34;&gt;Forwarding and Inheritance&lt;/h3&gt;

&lt;p&gt;尽管转发可以模仿继承，NSObject类绝不能混合这两种方式。像&lt;code&gt;respondsToSelector:&lt;/code&gt;和&lt;code&gt;isKindOfClass:&lt;/code&gt;方法，只能在继承链中看到，不能用于消息转发链。例如，一个Warrior对象被查询是否响应&lt;code&gt;negotiate&lt;/code&gt;消息，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if([aWarrior respondsToSelector:@selector(negotiate)])
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;答案是&lt;code&gt;NO&lt;/code&gt;，在某种意义上，即使它能无错误的接受&lt;code&gt;negotiate&lt;/code&gt;消息，并且响应它们，通过转发它们到Diplomat。&lt;/p&gt;

&lt;p&gt;在许多情况下，&lt;code&gt;NO&lt;/code&gt;是正确的答案。但也需不是。如果你使用转发来设置一个替代的object或者扩展一个类的能力，转发机制应该像继承一样透明。如果你想要你的对象的行为就好像真正是通过继承来实现消息转发的。你将需要重新实现&lt;code&gt;respondsToSelector:&lt;/code&gt;和&lt;code&gt;isKindOfClass:&lt;/code&gt;包括你的转发算法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (BOOL)respondsToSelector:(SEL)aSelector
{
	if([super respondsToSelector:aSelector])
		return YESl
	else {
		/* Here,test whether the aSelector message can *
		 * be forwarded to another object and whether that *
		 * object can respond to it.Return YES if it can. */
	}
	return NO;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;除了&lt;code&gt;respondsToSelector:&lt;/code&gt;和&lt;code&gt;isKindOfClass:&lt;/code&gt;,&lt;code&gt;instancesRespondToSelector:&lt;/code&gt;方法应该反映转发算法。如果协议被使用,&lt;code&gt;conformsToProtocol:&lt;/code&gt;方法应该同样被添加到这个list中。类似的，如果一个对象转发任何它接受的远程消息，它应该有一个&lt;code&gt;methodSignatureForSelector:&lt;/code&gt;方法的实现，它能返回方法精确的描述。最终响应转发的消息。例如，如果一个对象能够转发一个消息到它的替代者，你应该向下面这样实现&lt;code&gt;methodSignatureForSelector:&lt;/code&gt;方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (NSMethodSignature *)methodSignatureForSelector:(SEL)selector
{
	NSMethodSignature *signature = [super methodSignatureForSelector:selector];
	if(!signature){
		signature = [surrogate methodSignatureForSelector:selector];
	}
	return signature;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可能考虑把转发算法放在私有代码的某个地方并且拥有所有这些方法,&lt;code&gt;forwardInvocation:&lt;/code&gt;包括调用它。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;这是一个高级技巧，仅仅适用于没有其他解决方案的时候。这也不将作为继承的替代。如果你必须使用这个技术，确保你能完全理解在进行转发和要转发到的目标类的行为。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在这部分提到的方法被描述在&lt;code&gt;NSObject&lt;/code&gt;类的说明中。更多的关于&lt;code&gt;invokeWithTarget:&lt;/code&gt;请看&lt;a href=&#34;https://developer.apple.com/documentation/foundation/nsinvocation&#34;&gt;NSInvocation&lt;/a&gt;类的说明。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Runtime (二)  动态方法实现</title>
      <link>https://linkrober.github.io/bookshelf/2017/10/runtime-%E4%BA%8C--%E5%8A%A8%E6%80%81%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Mon, 09 Oct 2017 18:06:28 +0800</pubDate>
      
      <guid>https://linkrober.github.io/bookshelf/2017/10/runtime-%E4%BA%8C--%E5%8A%A8%E6%80%81%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0/</guid>
      <description>&lt;h3 id=&#34;dynamic-method-resolution&#34;&gt;Dynamic Method Resolution&lt;/h3&gt;

&lt;p&gt;有的时候，你可能想要提供方法的动态实现。例如，Object-C 属性特征包含了&lt;code&gt;@dynamic&lt;/code&gt;
&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@dynamic propertyName;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里是告诉编译器属性相关方法的实现会被动态的提供。&lt;/p&gt;

&lt;p&gt;你可以实现&lt;code&gt;resolveInstanceMethod:&lt;/code&gt;和&lt;code&gt;resolveClassMethod:&lt;/code&gt;为各个实例和类动态的提供一个selector。&lt;/p&gt;

&lt;p&gt;一个Object-C方法是一个简单的C函数，它最少持有两个参数&amp;ndash;&lt;code&gt;self&lt;/code&gt;和&lt;code&gt;_cmd&lt;/code&gt;。你可以使用&lt;code&gt;class_addMethod&lt;/code&gt;添加一个函数到类中作为方法，函数大概像这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void dynamicMethodIMP(id self,SEL _cmd) {
	//implementation...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可以动态的把它添加到类中作为一个方法，通过使用&lt;code&gt;resolveInstanceMethod:&lt;/code&gt;调用&lt;code&gt;resolveThisMethodDynamically&lt;/code&gt;方法，像这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@implementation MyClass
+ (BOOL)resolveInstanceMethod:(SEL)aSEL
{
	if(aSEL == @selector(resolveThisMethodDynamically)){
		class_addMethod([self class],aSEL,(IMP)dynamicMethodIMP,&amp;quot;v@:&amp;quot;);
		return YES;
	}
	return [super resolveInstanceMethod:aSEL];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;@end
一个类在消息转发机制开始前有机会动态的添加一个方法。如果&lt;code&gt;respondsToSelector:&lt;/code&gt;或者&lt;code&gt;instancesRespondToSelector:&lt;/code&gt;方法被调用时，动态的方法接受者首先会被给予一次机会，为selector提供一个&lt;code&gt;IMP&lt;/code&gt;。如果你实现了&lt;code&gt;resolveInstanceMethod:&lt;/code&gt;方法，但是想要指定的selector，通过转发机制被转发，你要return &lt;code&gt;NO&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&#34;dynamic-loading&#34;&gt;Dynamic Loading&lt;/h3&gt;

&lt;p&gt;一个Object-C程序可以在运行的时候加载和链接新的类。动态加载可以用来做很多不同的事情。例如，系统偏好中的不同模块是通过动态加载的方式实现的。
在Cocoa的环境中，动态加载一般被用来让应用更具灵活性。在编写自己的模块的时候，可以在runtime的时候被加载。更多的是用接口加载自定义的模版。OS X的系统设置中加载自定义的偏好模块。你应用程序的模块扩展等。
因此在Mach-O文件中有一个runtime函数执行Object-C的动态加载(objc_loadModules,定义在objc/objc-load.h中)，Cocoa的&lt;code&gt;NSBundle&lt;/code&gt;类为动态加载提供了一个更方便的接口&amp;ndash;面向对象的聚合相关服务的接口。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Runtime (一) 消息</title>
      <link>https://linkrober.github.io/bookshelf/2017/09/runtime-%E4%B8%80-%E6%B6%88%E6%81%AF/</link>
      <pubDate>Fri, 29 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>https://linkrober.github.io/bookshelf/2017/09/runtime-%E4%B8%80-%E6%B6%88%E6%81%AF/</guid>
      <description>&lt;h3 id=&#34;message&#34;&gt;Message&lt;/h3&gt;

&lt;p&gt;这篇文章描述了消息如何通过使用&lt;code&gt;objc_msgSend&lt;/code&gt;发送，如何通过方法名称找到对应方法的reference&lt;/p&gt;

&lt;h4 id=&#34;the-objc-msgsend-function&#34;&gt;The objc_msgSend Function&lt;/h4&gt;

&lt;p&gt;在Object-C中，发送的消息直到运行时才绑定到正真的方式实现。
&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[receiver message]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;objc_msgSend&lt;/code&gt;是真正调用消息的函数，这个函数持有消息的接受者和方法的名称：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;objc_msgSend(receiver,selector)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;任何其他的参数也是通过这个方法传入：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;objc_msgSend(receiver,selector,arg1,arg2,...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个方法会做一些必要的事情来进行动态绑定：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;首先找到方法的实现即selector的引用。因为在不同的类中都可以实现相同方法名的方法，所以通过方法的实现找到真正的receiver的class。&lt;/li&gt;
&lt;li&gt;然后传入该方法指定的receiver和参数。&lt;/li&gt;
&lt;li&gt;最后将实现的返回值作为它自己的返回值。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;Note:编译器生成调用消息的方法，在日常开发中永远不要在你写的代码中直接调用。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在架构中消息传递的关键在于编译器编译每个class和object。每个class的结构中包含两个重要元素：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;指向父类的指针&lt;/li&gt;
&lt;li&gt;一个类的派发表 ，这个表记录了方法的selector和定义该方法的地址。&lt;code&gt;setOrigin::&lt;/code&gt;方法和其对应的地址；&lt;code&gt;display&lt;/code&gt;和其对应的地址。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当一个新的对象被创建，内存被分配，实例变量被初始化。第一件事就是对象变量指针指向它的类结构。这个指针一般被称作&lt;code&gt;isa&lt;/code&gt;,给予对象访问类的权利。所有的类都是从这个类继承而来。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Note:尽管这是oc不太严谨的一部分(容易被hook)，但是这也是oc对象在运行时不可缺少的一部分。一个对象需要一个和它等效的结构体来代表，在任何地方都可以用它来定义。如果你曾经需要创建一个根对象。这个对象自动继承&lt;code&gt;NSObject&lt;/code&gt;或者&lt;code&gt;NSProxy&lt;/code&gt;都会携带一个&lt;code&gt;isa&lt;/code&gt;变量。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;类的这些元素和对象结构如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../../../messaging1.png&#34; alt=&#34;messaging1&#34; /&gt;&lt;/p&gt;

&lt;p&gt;当消息被发送到一个对象，消息方法跟随对象的&lt;code&gt;isa&lt;/code&gt;指向类结构，在派发表中一直向上寻找对应的方法。如果你不能在这里找到你需要的方法，&lt;code&gt;objc_msgSend&lt;/code&gt;方法会继续向上在父类的派发表里面尝试寻找该方法。还是失败就会一直寻找直到到达&lt;code&gt;NSObject&lt;/code&gt;类，一旦找到selector，就会从表中的入口调用该方法，把它传递到对象的数据结构中。&lt;/p&gt;

&lt;p&gt;这种方式的方法调用是在运行时进行的。在面向对象编程的专业术语中，我们称它为—&lt;strong&gt;动态消息绑定&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;为了加速消息处理的过程，运行时系统会缓存曾经使用过的selectors和对应的方法地址。每个类是被分开缓存的。和在类中定义的方法一样，它也包含继承方法的selector。在查找派发表之前，消息路径会第一个会检查接受者类的缓存.如果方法的selector在缓存中，消息只比方法调用慢一点点。一旦程序运行了足够长的时间唤醒缓存，几乎发送的所有消息都能在缓存中找到。在程序运行的时候，缓存动态的增加来容纳新的方法。&lt;/p&gt;

&lt;h4 id=&#34;using-hidden-arguments&#34;&gt;Using Hidden Arguments&lt;/h4&gt;

&lt;p&gt;当&lt;code&gt;objc_msgSend&lt;/code&gt;寻找实现方法的过程，它调用方法并传递所有的参数。同时它也为这个程序传递了两个隐藏的参数：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;接受者对象&lt;/li&gt;
&lt;li&gt;方法的selector&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这些参数给予每个方法的实现明确的信息。因为这两个参数的隐藏不能表现在编码中，一般是在编译的时候被插入到具体的实现。&lt;/p&gt;

&lt;p&gt;尽管这些参数没有被明确的声明，源码仍然可以引用到它们(就像可以引用对象的实例变量)。方法通过&lt;code&gt;self&lt;/code&gt;引用接受者对象，通过&lt;code&gt;_cmd&lt;/code&gt;代表selector。在下面的例子中，&lt;code&gt;_cmd&lt;/code&gt;指向&lt;code&gt;strange&lt;/code&gt;方法的selector，这个对象的&lt;code&gt;self&lt;/code&gt;接受&lt;code&gt;strange&lt;/code&gt;消息。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- strange
{
	id target = getTheReceiver();
	SEL method = getTheMethod();

	if(target == self || method == _cmd)
		return nil;
	return [target performSelector:method];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;getting-a-method-address&#34;&gt;Getting a Method Address&lt;/h4&gt;

&lt;p&gt;避免动态绑定的唯一办法，就是拿到方法的地址直接调用，就像调用一个方法一样。这只适合在一些少有情况下：当一个具体的方法需要被多次成功的执行，你想要在每次方法执行的时候避免消息带来的开销。&lt;/p&gt;

&lt;p&gt;定义在&lt;code&gt;NSObject&lt;/code&gt;类中的方法&lt;code&gt;methodForSelector:&lt;/code&gt;你可以获得一个指向方法具体实现的指针，然后使用指针调用程序。&lt;code&gt;methodForSelector:&lt;/code&gt;方法返回的指针一定要小心的包裹来指向一个适当的函数类型。返回值和输入参数都需要包含在里面。&lt;/p&gt;

&lt;p&gt;下面的例子展示了&lt;code&gt;setFilled:&lt;/code&gt;方法调用的实现过程：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void (*setter)(id,SEL,BOOL);
int i;
setter = (void (*)(id,SEL,BOOL))[target methodForSelector:@selector(setFilled:)];
for(i = 0;i &amp;lt; 100;i++){
	setter(targetList[i],@selector(setFilled:),YES);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先&lt;code&gt;self&lt;/code&gt;和&lt;code&gt;_cmd&lt;/code&gt;被传递到具体的实现，在两个参数在方法中通过语法的方式被隐藏，但是当这些参数在被作为一个funcation被调用的时候必须要明确。
使用&lt;code&gt;methodForSelector:&lt;/code&gt;来避免动态绑定可以节省大部分时间。但是如果同一个消息被多次调用，动态绑定的缓存机制可能更优雅点，因为上面的&lt;code&gt;for&lt;/code&gt;循环会遍历所有tartet。
记住，&lt;code&gt;methodForSelector:&lt;/code&gt;是Cocoa的运行时系统提供的，它不是OC语言自己的特性。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Run Loops (二)</title>
      <link>https://linkrober.github.io/bookshelf/2017/09/run-loops-%E4%BA%8C/</link>
      <pubDate>Tue, 26 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>https://linkrober.github.io/bookshelf/2017/09/run-loops-%E4%BA%8C/</guid>
      <description>&lt;h3 id=&#34;when-would-you-use-a-run-loop&#34;&gt;When Would You Use a Run Loop?&lt;/h3&gt;

&lt;p&gt;你唯一要使用run loop，就是当你要在application中创建线程的时候。你Application的主线程是架构很重要的一部分。所以，iOS系统为app的提供了&lt;i&gt;runloop&lt;/i&gt;代码，并自动开始。在iOS中运行Main loop作为app启动步骤的一部分。
&lt;/p&gt;

&lt;p&gt;对于其他的线程，你需要考虑是否必须要使用&lt;i&gt;run loop&lt;/i&gt;。如果有需要，配置并自己启动它。你不需要在每个线程中都启用run loop。例如，如果你使用一个线程来执行一些很长时间的运行和已经准备好的任务，你可能要避免使用它。Run loop的目的主要是用来解决线程间的通信。例如，如果你打算做下面的事情，你需要开启一个run loop。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用port或者自定义input source来和其他线程通讯&lt;/li&gt;
&lt;li&gt;在线程中使用timer&lt;/li&gt;
&lt;li&gt;在Cocoa application使用&lt;code&gt;performSelector…&lt;/code&gt;方法&lt;/li&gt;
&lt;li&gt;维持线程来执行周期性的任务&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果你选择使用run loop，配置和设置就是接下来要做的。纵观整个线程编码过程，你应该有一个明确的认识在什么时候退出线程，这比强制退出好很多。关于如何配置和退出run loop的信息在这&lt;a href=&#34;https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW5&#34;&gt;Using Run Loop Objects&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&#34;using-run-loop-objects&#34;&gt;Using Run Loop Objects&lt;/h3&gt;

&lt;p&gt;&lt;i&gt;run loop&lt;/i&gt;对象提供了主要的接口来添加input sources，timers，run-loop observers到&lt;i&gt;run loop&lt;/i&gt;中再运行它。每个线程有一个和它相关的run loop object。在Cocoa中，这个对象是&lt;a href=&#34;https://developer.apple.com/documentation/foundation/runloop&#34;&gt;NSRunLoop&lt;/a&gt;的实例。在应用的底层，它是&lt;a href=&#34;https://developer.apple.com/documentation/corefoundation/cfrunloop&#34;&gt;CFRunLoopRef&lt;/a&gt;类的指针。&lt;/p&gt;

&lt;h3 id=&#34;getting-a-run-loop-object&#34;&gt;Getting a Run Loop Object&lt;/h3&gt;

&lt;p&gt;获取当前线程的runloop对象，你使用下面的一种方式：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在Cocoa Application中，使用&lt;a href=&#34;https://developer.apple.com/documentation/foundation/runloop/1412291-current&#34;&gt;NSRunLoop&lt;/a&gt;的类方法&lt;a href=&#34;https://developer.apple.com/documentation/foundation/runloop&#34;&gt;currentRunLoop&lt;/a&gt;，来获取&lt;code&gt;NSRunLoop&lt;/code&gt;对象。&lt;/li&gt;
&lt;li&gt;使用&lt;a href=&#34;https://developer.apple.com/documentation/corefoundation/1542428-cfrunloopgetcurrent&#34;&gt;CFRunLoopGetCurrent&lt;/a&gt;方法。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;尽管它们不是无缝桥接的类，当需要的时候你可以从&lt;code&gt;NSRunLoop&lt;/code&gt;对象获得一个&lt;code&gt;CFRunLoopRef&lt;/code&gt;指针。&lt;code&gt;NSRunLoop&lt;/code&gt;类定义了一个&lt;a href=&#34;https://developer.apple.com/documentation/foundation/nsrunloop/1410140-getcfrunloop&#34;&gt;getCFRunLoop&lt;/a&gt;方法，它返回了一个&lt;code&gt;CFRunLoopRef&lt;/code&gt;类型，这你可以传入到Core Foundation中。因为两个对象指向同一个run loop，需要的时候你可以混合使用。&lt;/p&gt;

&lt;h3 id=&#34;configuring-the-run-loop&#34;&gt;Configuring the Run Loop&lt;/h3&gt;

&lt;p&gt;当你在自定义线程中跑run loop的时候，你至少添加一个input source或timer到run loop中，如果一个*run loop*没有任何source来监听，当你尝试运行它的时候，它会立即退出。如何向run loop中添加一个source，请看这里&lt;a href=&#34;https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW7&#34;&gt;Configuring Run Loop Sources&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;除了装载sources，你也可以装载run loop observers，使用它们来监听run loop的执行步骤。为了装载run loop observer，你创建了一个&lt;a href=&#34;https://developer.apple.com/documentation/corefoundation/cfrunloopobserver&#34;&gt;CFRunLoopObserverRef&lt;/a&gt;指针，并且使用&lt;a href=&#34;https://developer.apple.com/documentation/corefoundation/1542504-cfrunloopaddobserver&#34;&gt;CFRunLoopAddObserver&lt;/a&gt;方法并把它添加到你的run loop中。Run loop observer必须要使用Core Foundation来创建。&lt;/p&gt;

&lt;p&gt;下面展示了在一个线程中，添加一个run loop observer到run loop中的主要的代码部分。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (void)threadMain
{
	//The application use garbage collection,so no autorelease pool is needed.
	NSRunLoop *myRunLoop = [NSRunLoop currentRunLoop];	
	//Create a run loop observer and attach it to the run loop.
	CFRunLoopObserverContent context = {0,self,NULL,NULL,NULL};
	CFRunLoopObserverRef observer = CFRunLoopObserverCreate(kCFAllocatorDefault,kCFRunLoopAllActivities,YES,0,&amp;amp;myRunLoopObserver,&amp;amp;context);
	if(observer)
	{
		CFRunLoopRef cfLoop = [myRunLoop getCFRunLoop];
		CFRunLoopAddObserver(cfLoop,observer,kCFRunLoopDefaultMode);		
	}	
	//Create and schedule the timer.
		[NSTimer scheduledTimerWithTimeInterval:0.1 target:self selector:@selector(doFireTimer:) userInfo:nil repeats:YES];
		NSInteger loopCount = 10;
	do 
	{
		//Run the run loop 10 times to let the timer fire
		[myRunLoop runUntilDate:[NSDate dateWithTimeIntervalSinceNow:1]];
		loopCount--;
	}
	while(loopCount);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当为一个活跃的线程配置run loop的时候，至少添加一个input source到接受的消息。尽管你能够只需要通过一个timer来启动run loop中，但是，一旦timer触发之后，它就会无效的，这会引起run loop的退出。传入一个repeat的timer可以保持run loop运行很长一段时间。但是将会周期性的调用触发的timer来唤醒你的线程。这是维持线程中&lt;i&gt;run loop&lt;/i&gt;的另一种方式，一个input source等待事件的到达，让你的线程处于睡眠中，直到它被唤醒。&lt;/p&gt;

&lt;h3 id=&#34;starting-the-run-loop&#34;&gt;Starting the Run Loop&lt;/h3&gt;

&lt;p&gt;一个run loop必须装载至少一个input source或者timer来。如果没有，run loop立即退出。
下面有几种办法开启一个run loop。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;无条件的启动run loop&lt;/li&gt;
&lt;li&gt;设置一个超时时间启动run loop&lt;/li&gt;
&lt;li&gt;通过一种特殊的模式启动run loop&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;无条件的启动&lt;i&gt;runloop&lt;/i&gt;是最简单的，但是这也是最不推荐的一种方式。无条件的启动你的runloop，把线程作为&lt;i&gt;runloop&lt;/i&gt;的一个参数。这种方式对runloop的控制权很小。你可以添加或移除input source和timers，唯一停止&lt;i&gt;runloop&lt;/i&gt;的方式就是kill。这种启动方式没有办法在自定义mode。&lt;/p&gt;

&lt;p&gt;除了无条件的启动一个runloop，使用time out value来开始一个&lt;i&gt;runloop&lt;/i&gt;更好。当你使用time out value，runloop运行直到事件到达或者超时。如果事件抵达，事件会被派发到一个handler来处理，然后run loop退出。你的code又能够重新开始runloop去处理下一个事件。如果超时，你可以简单的重启runloop，或者利用这段时间做任何需要的事。&lt;/p&gt;

&lt;p&gt;除了time out value，你也可以使用一个指定的mode来运行runloop。Modes和timeout value并不是互斥的。当运行runloop的时候也可以同时使用它们。Modes限制了source的type。详细被描述在&lt;a href=&#34;https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW12&#34;&gt;Run Loop Modes&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;下面的code主要部分展示了runloop的基本结构。本质上，你添加你的input source和timer到runloop。重复调用其中一个routine来开始一个&lt;i&gt;run loop&lt;/i&gt;。每次run loop routine 返回的时，你检查&lt;i&gt;run lop&lt;/i&gt;是否满足某些条件导致退出thread。例子中使用Core Foundation的run loop routines，以至于它能检查返回的结果并检测run loop为什么退出。你也能使用&lt;a href=&#34;https://developer.apple.com/documentation/foundation/runloop&#34;&gt;NSRunLoop&lt;/a&gt;的方法以一种相似的方式来运行runloop，如果你正在使用Cocoa框架中的NSRunLoop，它是不需要检查return value的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (void)skeletonThreadMain {
	//Set up an autorelease pool here if not using garbage collection.
	BOOL done = NO;
	//Add your sources or timer to the run loop and do any other setup
	do
	{
		//Start the run loop but return after earch source is handled
		SInt32 result = CFRunLoopRunInMode(kCFRunLoopDefaultMode,10,YES)
		
		//If a source explicitly stopped the run loop,or if there no sources or timers,go head and exit.
		if ((result == kCFRunLoopRunStopped) || (result == kCFRunLoopRunFinished))
		done = YES;
		
		//Check for any other exit conditions here and set the done variable as needed
	}
	while(!done);
	//Clean up code here. Be sure to release any allocated autorelease pools.
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;递归运行run loop也是可能的。换句话说，你能够调用&lt;a href=&#34;https://developer.apple.com/documentation/corefoundation/1542011-cfrunlooprun&#34;&gt;CFRunLoopRun&lt;/a&gt;、&lt;a href=&#34;https://developer.apple.com/documentation/corefoundation/1541988-cfrunloopruninmode&#34;&gt;CFRunLoopRunInMode&lt;/a&gt;,任何&lt;code&gt;NSRunLoop&lt;/code&gt;的方法，从input source 或者 timer的handler routine开始runloop。当这样做的时候，你可以使用你想要的mode来运行内嵌的runloop。包括被outer run loop正在使用的mode。&lt;/p&gt;

&lt;h3 id=&#34;exiting-the-run-loop&#34;&gt;Exiting the Run Loop&lt;/h3&gt;

&lt;p&gt;有两种办法使runloop在处理事件之前退出。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;为&lt;i&gt;Runloop&lt;/i&gt;配置一个time out时间&lt;/li&gt;
&lt;li&gt;主动告诉&lt;i&gt;Runloop&lt;/i&gt;停止&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用time out时间是一种比较好的选择。在退出之前，指定一个time out时间让runloop完成所有的任务，包括向&lt;i&gt;runloop observer&lt;/i&gt;发送通知。&lt;/p&gt;

&lt;p&gt;使用&lt;a href=&#34;https://developer.apple.com/documentation/corefoundation/1541796-cfrunloopstop&#34;&gt;CFRunLoopStop&lt;/a&gt;方法停止一个&lt;i&gt;runloop&lt;/i&gt;，产生一个类似于超时的结果。使用runloop发送完剩下的runloop通知然后退出。唯一不同的就是只有当你无条件的启动&lt;i&gt;Runloop&lt;/i&gt;的时候才能使用这种方式退出。&lt;/p&gt;

&lt;p&gt;尽管移除runloop的input source和timers可以引起runloop的退出，但是这不是一种稳定的方式。一些系统一般添加input source到run loop来处理需要的事件。因为你的code不需要关心这些input source。所以你不能移除input sources，让&lt;i&gt;run loop&lt;/i&gt;退出。&lt;/p&gt;

&lt;h3 id=&#34;thread-safety-and-run-loop-objects&#34;&gt;Thread Safety and Run Loop Objects&lt;/h3&gt;

&lt;p&gt;线程安全取决于你使用操作&lt;i&gt;runloop&lt;/i&gt;的API。在Core Foundation中的方法一般是线程安全的，可以被任何其他线程调用。如果你正在执行操作，这些操作改变了runloop的配置。无论什么时候，这样做任然是一个很好的实践。&lt;/p&gt;

&lt;p&gt;Cocoa的&lt;a href=&#34;https://developer.apple.com/documentation/foundation/runloop&#34;&gt;NSRunLoop&lt;/a&gt;类。Cocoa的NSRunLoop和Core Foundation不一样，不是线程安全的。如果你使用&lt;code&gt;NSRunLoop&lt;/code&gt;类来修改你的runloop，你应该在原来的线程中做这些操作。在其他线程添加一个input source或者timer到原来runloop可能引起crash，或者一个意想不到的行为。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Run Loops (一)</title>
      <link>https://linkrober.github.io/bookshelf/2017/09/run-loops-%E4%B8%80/</link>
      <pubDate>Mon, 25 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>https://linkrober.github.io/bookshelf/2017/09/run-loops-%E4%B8%80/</guid>
      <description>&lt;p&gt;
&amp;gt;下面会用一些陌生的或者容易让人混淆的字符，我们先来统一概念再继续，这样能够让你更加愉快的阅读：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;runloop:&lt;/strong&gt;iOS一个底层机制的专业术语。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;run loop:&lt;/strong&gt;一种运行的循环。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Handler:&lt;/strong&gt;指&lt;code&gt;handlePort:&lt;/code&gt;、&lt;code&gt;customSrc:&lt;/code&gt;、&lt;code&gt;mySelector:&lt;/code&gt;、&lt;code&gt;timerFired:&lt;/code&gt;，指开发者希望当进入run loop的时候要执行的操作&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;run-loop observer：&lt;/strong&gt;观察runloop行为的观察者&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;run-loop mode：&lt;/strong&gt;每个runloop都要指定一种mode，一种mode可以对应多个input source&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;runloop object：&lt;/strong&gt;runloop相关的对象，这里分Cocoa和CoreFoundation中的&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;i&gt;Runloop&lt;/i&gt;是线程架构相关的一部分，是事件处理的循环。你可以用它来安排循环执行任务，协调相关的事件（kCFRunLoopEntry、kCFRunLoopExit等）。
用几行示意代码来展示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function loop() {
    initialize();
    do {
        var message = get_next_message();
        process_message(message);
    } while (message != quit);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;i&gt;Runloop&lt;/i&gt;实际上是一个管理要处理的事件和消息的对象，并为开发者提供了一个入口来执行run loop的逻辑部分。一直处于类似于“接受消息&amp;ndash;&amp;gt;等待&amp;ndash;&amp;gt;处理”这样的一个循环汇总&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;i&gt;Runloop&lt;/i&gt;的目的：一般我们自己写的线程在执行完相应的任务就会退出，而runloop&lt;strong&gt;让你的线程在有事干的时候干活，没事干的时候休息，节省系统资源&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;i&gt;Runloop&lt;/i&gt;的管理不全是自动的，&lt;strong&gt;对于自己的线程，必须要自己添加代码，并在适当的时候启动Run loop&lt;/strong&gt;来响应接受的事件。
Cocoa和Core Foundation提供了&lt;strong&gt;runloop objects&lt;/strong&gt;来帮助你配置和管理线程的run loop。你的Application不需要自己创建这些对象(像alloc、init这些方法)。每个thread，包括Application的主线程，都已经有runloop object，有方法可以直接获取这这些对象，类似于这样的&lt;code&gt;[NSRunLoop currentRunLoop]&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/// 全局的Dictionary，key 是 pthread_t， value 是 CFRunLoopRef
static CFMutableDictionaryRef loopsDic;
/// 访问 loopsDic 时的锁
static CFSpinLock_t loopsLock;
 
/// 获取一个 pthread 对应的 RunLoop。
CFRunLoopRef _CFRunLoopGet(pthread_t thread) {
    OSSpinLockLock(&amp;amp;loopsLock);
    
    if (!loopsDic) {
        // 第一次进入时，初始化全局Dic，并先为主线程创建一个 RunLoop。
        loopsDic = CFDictionaryCreateMutable();
        CFRunLoopRef mainLoop = _CFRunLoopCreate();
        CFDictionarySetValue(loopsDic, pthread_main_thread_np(), mainLoop);
    }
    
    /// 直接从 Dictionary 里获取。
    CFRunLoopRef loop = CFDictionaryGetValue(loopsDic, thread));
    
    if (!loop) {
        /// 取不到时，创建一个
        loop = _CFRunLoopCreate();
        CFDictionarySetValue(loopsDic, thread, loop);
        /// 注册一个回调，当线程销毁时，顺便也销毁其对应的 RunLoop。
        _CFSetTSD(..., thread, loop, __CFFinalizeRunLoop);
    }
    
    OSSpinLockUnLock(&amp;amp;loopsLock);
    return loop;
}
 
CFRunLoopRef CFRunLoopGetMain() {
    return _CFRunLoopGet(pthread_main_thread_np());
}
 
CFRunLoopRef CFRunLoopGetCurrent() {
    return _CFRunLoopGet(pthread_self());
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;苹果提供了&lt;code&gt;CFRunLoopGetMain&lt;/code&gt; 、&lt;code&gt;CFRunLoopGetMain&lt;/code&gt;这两个方法来创建&lt;i&gt;runloop&lt;/i&gt;，如果它不被调用，线程中就不会有runloop。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Cocoa中的&lt;code&gt;NSRunLoop&lt;/code&gt;,和Core Foundation中的&lt;code&gt;CFRunLoopRef&lt;/code&gt;等Run loop相关的类。它们的方法一般也是一一对应的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;唯一不同的是：你自己创建的线程需要明确的代码来让runloop跑起来，比如&lt;code&gt;[runLoop run]&lt;/code&gt;这样的方法。但是对于主线程的&lt;i&gt;runloop&lt;/i&gt;，系统会在App起来的时候自动设置并跑主线程里面的&lt;i&gt;runloop&lt;/i&gt;，这是Application运行起来的一部分。&lt;/p&gt;

&lt;h3 id=&#34;anatomy-of-run-loop-剖析runloop&#34;&gt;Anatomy of Run Loop（剖析runloop）&lt;/h3&gt;

&lt;p&gt;“一个运行的循环”，看它名字的意思就能猜得到。它会循环不断的进入线程，在&lt;i&gt;runloop&lt;/i&gt;进入之后做一些自己的事情。你的code提供了状态的控制用来实现&lt;i&gt;runloop&lt;/i&gt;真正的循环部分。—— 换句话说，你的code提供&lt;code&gt;while&lt;/code&gt;或&lt;code&gt;for&lt;/code&gt;循环来驱动run loop。在你的循环中，你使用一个&lt;i&gt;runloop object&lt;/i&gt;来运行事件处理的code，&lt;i&gt;runloop&lt;/i&gt;接受事件并调用你已经准备好的方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/*
 这里doFireTimer方法就是你要处理的事件的code，&amp;lt;i&amp;gt;runloop&amp;lt;/i&amp;gt;在从sleep状态被wakeup之后会执行改方法。
*/
[NSTimer scheduledTimerWithTimeInterval:0.016
                                     target:self
                                   selector:@selector(doFireTimer:)
                                   userInfo:nil
                                    repeats:YES];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面我们提到&lt;strong&gt;“你使用一个runloop object来运行事件处理的code”&lt;/strong&gt;，这里的事件是从哪里来呢？即事件源是什么？&lt;/p&gt;

&lt;p&gt;事件源分两类：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;i&gt;Input source&lt;/i&gt;所驱动的异步事件，一般它用来从一个线程向另一个线程发送事件或者从一个Application向另一个Application。&lt;/li&gt;
&lt;li&gt;&lt;i&gt;Timer sources&lt;/i&gt;所驱动的同步事件，事件发生在一个已经预先设定好的时间，或者在重复的事件间隔发生。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当事件到达的时候，这两种source会按照系统指定的步骤来处理事件。&lt;/p&gt;

&lt;p&gt;下图展示了一个&lt;i&gt;runloop&lt;/i&gt;的概念结构和各种不同的sources。Input sources发送一个异步的事件来执行相对应的handler（例如，图中的&lt;code&gt;hanlePort&lt;/code&gt;、&lt;code&gt;mySelector&lt;/code&gt;等），并通过&lt;code&gt;runUntilDate:&lt;/code&gt;方法（调用thread相关的&lt;a href=&#34;https://developer.apple.com/documentation/foundation/runloop&#34;&gt;NSRunLoop&lt;/a&gt;对象）来退出。Timer sources发送事件到runloop的handler，但不会引起runloop的退出。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/1086250-2f8e40f8ce0f82c0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;runloop-1.jpg&#34; /&gt;&lt;/p&gt;

&lt;p&gt;除了处理输入源对应的handler，&lt;i&gt;Runloop&lt;/i&gt;生成关于run loop行为的通知。注册&lt;i&gt;run-loop&lt;/i&gt; 的observer接受这些通知。使用它们在thread上做一些其他的操作。你可以在你的线程中使用Core Foundation里面的类来创建&lt;i&gt;run-loop observer&lt;/i&gt;。&lt;/p&gt;

&lt;h3 id=&#34;run-loop-modes&#34;&gt;Run Loop Modes&lt;/h3&gt;

&lt;p&gt;&lt;i&gt;run-loop mode&lt;/i&gt;是被监听的&lt;i&gt;Input sources&lt;/i&gt;和&lt;i&gt;Timers&lt;/i&gt;的集合，同时还是被通知的&lt;i&gt;run-loop observer&lt;/i&gt;的集合，大家可能比较疑惑怎么是两种东西的集合（source和obaserver），下面是我的理解，从代码出发：
&lt;code&gt;[runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];&lt;/code&gt;
&lt;strong&gt;线程的每个Source都要指定一个Mode，这里是NSDefaultRunLoopMode&lt;/strong&gt;
&lt;code&gt;CFRunLoopAddObserver(cfLoop, observer, kCFRunLoopCommonModes);&lt;/code&gt;
&lt;strong&gt;观察者是观察该Runloop的某些Modes，kCFRunLoopCommonModes是mode的集合，每种mode都可以添加到Common中&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;每次你运行你的&lt;i&gt;runloop&lt;/i&gt;的时候，要指定一个具体的mode在&lt;i&gt;runloop&lt;/i&gt;里面跑。在进入&lt;i&gt;runloop&lt;/i&gt;的时候，只有和这个mode相关联的source能被对应的&lt;i&gt;run-loop observer&lt;/i&gt;监听到，被允许向它们传递事件。而其他mode相关的source会一直等待，直到&lt;i&gt;run-loop mode&lt;/i&gt;和source指定的mode相对应的时候才开始传递事件。&lt;/p&gt;

&lt;p&gt;在你的代码中，你通过具体的名称来定义mode(&lt;code&gt;kCFRunLoopDefaultMode&lt;/code&gt;、&lt;code&gt;kCFRunLoopCommonModes&lt;/code&gt;等)。Cocoa和Core Foundation都定义了默认的mode和一些经常使用的mode。&lt;/p&gt;

&lt;p&gt;你也能通过简单的字符串来自定义自己的mode。尽管custom mode定义起来好像很随意，但使用起来可不能随意啊。对于任何mode，你必须要确保添加一个或者更多的&lt;i&gt;sources&lt;/i&gt;，&lt;i&gt;timers&lt;/i&gt;或者&lt;i&gt;run-loop observer&lt;/i&gt;，如果你没有做到，&lt;i&gt;run loop&lt;/i&gt;就会直接退出。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//如果没有第二行代码，runloop会自动退出
NSRunLoop *runLoop = [NSRunLoop currentRunLoop];
[runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];
[runLoop run];

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可以使用mode过滤掉不想要的source。大多数情况下，你只需要用系统定义的“default”mode来运行你的runloop。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Note:Mode是根据事件source来匹配的而不是根据事件的type。例如，你不可以使用鼠标的按下事件或者键盘按下事件来匹配mode。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;下面是一些系统定义好的Modes&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Mode&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Name&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Default&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://developer.apple.com/documentation/foundation/nsdefaultrunloopmode&#34;&gt;NSDefaultRunLoopMode&lt;/a&gt;(Cocoa)&lt;a href=&#34;https://developer.apple.com/documentation/corefoundation/kcfrunloopdefaultmode&#34;&gt;kCFRunLoopDefaultMode&lt;/a&gt;(Core Foundation)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Connection&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://developer.apple.com/documentation/foundation/nsconnectionreplymode&#34;&gt;NSConnectionReplyMode&lt;/a&gt;(Cocoa)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Modal&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://developer.apple.com/documentation/appkit/nsmodalpanelrunloopmode&#34;&gt;NSModalPanelRunLoopMode&lt;/a&gt;(Cocoa)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Event tracking&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://developer.apple.com/documentation/foundation/runloopmode/1428765-eventtrackingrunloopmode&#34;&gt;NSEventTrackingRunLoopMode&lt;/a&gt;(Cocoa)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Common modes&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://developer.apple.com/documentation/foundation/runloopmode/1408609-commonmodes&#34;&gt;NSRunLoopCommonModes&lt;/a&gt;(Cocoa)&lt;a href=&#34;https://developer.apple.com/documentation/corefoundation/kcfrunloopcommonmodes&#34;&gt;kCFRunLoopCommonModes&lt;/a&gt;(Core Foundation)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;input-sources&#34;&gt;Input Sources&lt;/h3&gt;

&lt;p&gt;&lt;i&gt;Input source&lt;/i&gt;通过异步的方式向你的线程传递事件。事件的源取决于&lt;i&gt;input source&lt;/i&gt;的类型。&lt;i&gt;input source&lt;/i&gt;大概分为两类：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Port-based port&lt;/strong&gt;
&lt;i&gt;Port-based port&lt;/i&gt;监控你application的Mach port。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Custom input source&lt;/strong&gt;
&lt;i&gt;Custom input source&lt;/i&gt;监控自定义的事件source。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;i&gt;runloop&lt;/i&gt;不关心是哪种&lt;i&gt;input source&lt;/i&gt;，这两种*input sources*系统都有实现。这两个&lt;i&gt;input source&lt;/i&gt;唯一的不同就是它们如何发送信号。&lt;i&gt;Port-based port&lt;/i&gt;通过内核自动发送信号。&lt;i&gt;Custom input source&lt;/i&gt;只能从其他线程接受手动发送的信号。&lt;/p&gt;

&lt;p&gt;当你创建一个&lt;i&gt;input source&lt;/i&gt;，你把它赋值到&lt;i&gt;runloop&lt;/i&gt;的mode。mode会影响被监控的input source。大多数情况，你在&lt;code&gt;NSDefaultRunLoopMode&lt;/code&gt;下运行&lt;i&gt;runloop&lt;/i&gt;，但是你也可以指定自定义的mode。如果一个&lt;i&gt;input source&lt;/i&gt;不在当前被监控的mode中，它产生的一些事件将会被暂时的放在一边，直到下一个run loop的mode和input source的mode相同才开始处理这个input source产生的事件。&lt;/p&gt;

&lt;p&gt;接下去的部分描述了一些input source&lt;/p&gt;

&lt;h5 id=&#34;port-based-sources&#34;&gt;Port-Based Sources&lt;/h5&gt;

&lt;p&gt;Cocoa和Core Foundation通过提供端口相关的对象和方法来创建&lt;i&gt;Port-Based Source&lt;/i&gt;。例如，在Cocoa中，你没必要直接创建input source。你使用&lt;code&gt;NSPort&lt;/code&gt;的方法&lt;code&gt;[NSPort port]&lt;/code&gt;，添加port到run loop中。Port object会为你创建和配置所需的&lt;i&gt;Port-Based Sources&lt;/i&gt;。&lt;/p&gt;

&lt;p&gt;在 Core Foundation中，你必须要自己创建port和它的run loop source。用 &lt;a href=&#34;https://developer.apple.com/documentation/corefoundation/cfmachport&#34;&gt;CFMachPortRef&lt;/a&gt;, &lt;a href=&#34;https://developer.apple.com/documentation/corefoundation/cfmessageportref&#34;&gt;CFMessagePortRef&lt;/a&gt;,  &lt;a href=&#34;https://developer.apple.com/documentation/corefoundation/cfsockeref&#34;&gt;CFSocketRef&lt;/a&gt;这些不透明指针创建相应的对象。&lt;/p&gt;

&lt;p&gt;如何配置和设置自定义的&lt;i&gt;Port-Based Sources&lt;/i&gt;，请看&lt;a href=&#34;https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-131281&#34;&gt; Configuring a Port-Based Input Source&lt;/a&gt;&lt;/p&gt;

&lt;h5 id=&#34;custom-input-sources-core-foundation&#34;&gt;Custom Input Sources（Core Foundation）&lt;/h5&gt;

&lt;p&gt;为了创建自定义的input source，你必须使用Core Foundation中的&lt;a href=&#34;https://developer.apple.com/documentation/corefoundation/cfrunloopsource&#34;&gt;CFRunLoopSourceRef&lt;/a&gt;不透明类相关的方法。你需要在回调方法中配置这个Custom Input Sources。Core Foundation会在配置Custom Input Sources、处理输入事件和当source要从runloop中移除的时候调用这几个回调。&lt;/p&gt;

&lt;p&gt;对于如何创建一个custom input source请看这里&lt;a href=&#34;https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW3&#34;&gt;Defining a Custom Input Source&lt;/a&gt;&lt;/p&gt;

&lt;h5 id=&#34;cocoa-perform-selector-sources-cocoa&#34;&gt;Cocoa Perform Selector Sources（Cocoa）&lt;/h5&gt;

&lt;p&gt;除了&lt;i&gt;Port-Based Sources&lt;/i&gt;，Cocoa定义了一个&lt;i&gt;custom input source&lt;/i&gt;，这允许你向任何线程中发送选择子。和&lt;i&gt;Port-Based Sources&lt;/i&gt;一样，执行选择子selector的请求在同一个线程上是连续的，当多个方法同时向线程发送请求的时候可能会导致同步的问题。和&lt;i&gt;Port-Based Sources&lt;/i&gt;不同的是：一个&lt;i&gt;perform selector source&lt;/i&gt;执行完它的selector，它自己会从runloop中移除。&lt;/p&gt;

&lt;p&gt;当向另一个线程发送selector请求时，目标线程必须有一个active的&lt;i&gt;runloop&lt;/i&gt;。这意味着你必须等待，直到该线程中runloop的状态变成 active。因为主线程会自己开始一个&lt;i&gt;runloop&lt;/i&gt;，只要系统一调用Application delegate的&lt;code&gt;applicationDidFinishLaunching:&lt;/code&gt;（这时候系统的runloop就创建出来了），你就可以向主线程发送selector请求。每次&lt;i&gt;Runloop&lt;/i&gt;会处理所有队列的selector请求，而不是只处理一个队列的请求。下面列出了一些perform方法&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Methods&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://developer.apple.com/documentation/objectivec/nsobject/1414900-performselector&#34;&gt;performSelectorOnMainThread:withObject:waitUntilDone:&lt;/a&gt;、&lt;a href=&#34;https://developer.apple.com/documentation/objectivec/nsobject/1411637-performselector&#34;&gt;performSelectorOnMainThread:withObject:waitUntilDone:modes:&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://developer.apple.com/documentation/objectivec/nsobject/1414476-perform&#34;&gt;performSelector:onThread:withObject:waitUntilDone:&lt;/a&gt;、&lt;a href=&#34;https://developer.apple.com/documentation/objectivec/nsobject/1417922-perform&#34;&gt;performSelector:onThread:withObject:waitUntilDone:modes:&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://developer.apple.com/documentation/objectivec/nsobject/1416176-perform&#34;&gt;performSelector:withObject:afterDelay:&lt;/a&gt;、&lt;a href=&#34;https://developer.apple.com/documentation/objectivec/nsobject/1415652-perform&#34;&gt;performSelector:withObject:afterDelay:inModes:&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://developer.apple.com/documentation/objectivec/nsobject/1417611-cancelpreviousperformrequests&#34;&gt;cancelPreviousPerformRequestsWithTarget:&lt;/a&gt;、&lt;a href=&#34;https://developer.apple.com/documentation/objectivec/nsobject/1410849-cancelpreviousperformrequests&#34;&gt;cancelPreviousPerformRequestsWithTarget:selector:object:&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h5 id=&#34;timer-sources&#34;&gt;Timer Sources&lt;/h5&gt;

&lt;p&gt;&lt;i&gt;Timer sources&lt;/i&gt;会在将来的某个时间，发送同步事件到你的当前的线程。Timer是线程用来通知它自己的一种方式。
尽管它是基于时间的通知，一个timer并不能保证在准确的时间点执行事件。和其他的&lt;i&gt;Input source&lt;/i&gt;一样，Timer和你&lt;i&gt;run loop&lt;/i&gt;指定的mode有关系。如果Timer的mode不是你当前runloop正在跑的mode，它是不会被触发的，直到你的&lt;i&gt;runloop&lt;/i&gt;运行的的mode是你的Timer所支持的。类似的，如果一个Timer被触发，但是当runloop在执行Handler，Timer将会一直等待，直到下次再次进入runloop的时候才会执行。如果这个&lt;i&gt;runloop&lt;/i&gt;不再跑了，这个Timer将永远不会被触发。&lt;/p&gt;

&lt;p&gt;你可以配置Timer来运行事件，一次或者不停重复。一个重复的Timer会基于设定好的触发时间，自动重新安排它自己到run loop中，但这个时间间隔并不一定准确。例如，如果一个Timer在一个特定时间被触发，每5秒重复一次。即使实际的触发时间被延迟了，被安排的触发时间总落在5秒的延迟时间间隔之内。如果触发时间被延迟太多，会导致它错过了一次或者更多被安排到run loop的机会。在一个不恰当的时机被触发之后，Timer则会被安排到下一次run loop。
关于配置timer sources的更多信息，请看&lt;a href=&#34;https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW6&#34;&gt;Configuring Timer Sources&lt;/a&gt;。更多相关信息&lt;a href=&#34;https://developer.apple.com/documentation/foundation/timer&#34;&gt;NSTimer Class Reference&lt;/a&gt;或&lt;a href=&#34;https://developer.apple.com/documentation/corefoundation/cfrunlooptimer-rhk&#34;&gt;CFRunLoopTimer Reference&lt;/a&gt;。&lt;/p&gt;

&lt;h5 id=&#34;run-loop-observers&#34;&gt;Run Loop Observers&lt;/h5&gt;

&lt;p&gt;一般的source是在一个异步或者同步的事件发生的时候被触发的，而&lt;i&gt;run-loop observer&lt;/i&gt;是在&lt;i&gt;runloop&lt;/i&gt;它执行的时候触发的。你可以通过&lt;i&gt;run-loop observer&lt;/i&gt;来准备一些线程待处理的事件，或者在线程sleep之前，在线程中做一些事。&lt;i&gt;run-loop observers&lt;/i&gt;可以观察到下面的一些事件：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;进入&lt;i&gt;runloop&lt;/i&gt;的时候&lt;/li&gt;
&lt;li&gt;当&lt;i&gt;runloop&lt;/i&gt;将要处理timer的时候&lt;/li&gt;
&lt;li&gt;当&lt;i&gt;runloop&lt;/i&gt;将要处理input source的时候&lt;/li&gt;
&lt;li&gt;当&lt;i&gt;runloop&lt;/i&gt;将要sleep的时候&lt;/li&gt;
&lt;li&gt;当&lt;i&gt;runloop&lt;/i&gt;已经醒来，还没有开始处理event的时候&lt;/li&gt;
&lt;li&gt;当&lt;i&gt;runloop&lt;/i&gt;退出的时候&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;你可以使用Core Foundation向Application添加&lt;i&gt;run-loop observer&lt;/i&gt;。为了创建一个&lt;i&gt;run_loop observer&lt;/i&gt;，你需要使用&lt;a href=&#34;https://developer.apple.com/documentation/corefoundation/cfrunloopobserver&#34;&gt;CFRunLoopObserverRef&lt;/a&gt;类。这个类会追踪你自定义callback函数、你感兴趣的&lt;code&gt;CFRunLoopActivity&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;和Timer相似，&lt;i&gt;run-loop observer&lt;/i&gt;可以只运行一次，或者不停重复。只运行一次的&lt;i&gt;run-loop observer&lt;/i&gt;在一次run loop之后就会从&lt;i&gt;runloop&lt;/i&gt;中移除。当你创建&lt;i&gt;run-loop observer&lt;/i&gt;的时候，你要决定r是一次还是不停重复。&lt;/p&gt;

&lt;p&gt;对于如何创建一个&lt;i&gt;run-loop observer&lt;/i&gt;的例子，看&lt;a href=&#34;https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW18&#34;&gt; Configuring the Run Loop&lt;/a&gt;,更多相关信息&lt;a href=&#34;https://developer.apple.com/documentation/corefoundation/cfrunloopobserver-ri3&#34;&gt;CFRunLoopObserver Reference&lt;/a&gt;&lt;/p&gt;

&lt;h5 id=&#34;the-run-loop-sequence-of-events&#34;&gt;The Run Loop Sequence of Events&lt;/h5&gt;

&lt;p&gt;每次你运行&lt;i&gt;runloop&lt;/i&gt;，你线程的&lt;i&gt;runloop&lt;/i&gt;会处理之前挂起的事件，并且向*run-loop observer*发送通知。&lt;i&gt;runloop&lt;/i&gt;执行的顺序如下面所列出的：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;通知&lt;i&gt;run-loop observer&lt;/i&gt;，进入&lt;i&gt;runloop&lt;/i&gt;&lt;/li&gt;
&lt;li&gt;通知&lt;i&gt;run-loop observer&lt;/i&gt;，已经准备好的Timer将要触发&lt;/li&gt;
&lt;li&gt;通知&lt;i&gt;run-loop observer&lt;/i&gt;，以及准备好的*no-port-based input source*将要被触发&lt;/li&gt;
&lt;li&gt;触发&lt;i&gt;no-port-based input source&lt;/i&gt;&lt;/li&gt;
&lt;li&gt;如果一个&lt;i&gt;port-based input source&lt;/i&gt;准备好等待触发，立即处理该事件，再从第九步开始执行&lt;/li&gt;
&lt;li&gt;通知&lt;i&gt;run-loop observer&lt;/i&gt;，线程将要sleep&lt;/li&gt;
&lt;li&gt;线程sleep直到下面的事件发生：

&lt;ul&gt;
&lt;li&gt;&lt;i&gt;port-based input source&lt;/i&gt;事件到达&lt;/li&gt;
&lt;li&gt;一个Timer触发了&lt;/li&gt;
&lt;li&gt;&lt;i&gt;runloop&lt;/i&gt;超时了&lt;/li&gt;
&lt;li&gt;&lt;i&gt;runloop&lt;/i&gt;被手动唤醒&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;通知&lt;i&gt;run-loop observer&lt;/i&gt;，线程将要被唤醒&lt;/li&gt;

&lt;li&gt;&lt;p&gt;处理挂起的事件&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果一个用户定义的timer触发了，处理相关事件，重新开始循环，回到第二步继续执行&lt;/li&gt;
&lt;li&gt;如果&lt;i&gt;input source&lt;/i&gt;触发，传递相应的事件&lt;/li&gt;
&lt;li&gt;如果&lt;i&gt;runloop*&lt;/i&gt;明确的被唤醒，但是还没有超时，重新开始循环，回到第二步继续执行&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;通知&lt;i&gt;run_loop observer&lt;/i&gt;，&lt;i&gt;runloop&lt;/i&gt;已经退出&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Tip:&lt;/strong&gt;no-port-based input source就是我们常说的&lt;strong&gt;source0&lt;/strong&gt;，port-based input source就是&lt;strong&gt;source1&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;因为Timer和input source的通知是在事件被触发之前，所以这之间有一个过渡时间。如果你要在这个时间做一些事情，你可以使用&lt;strong&gt;sleep&lt;/strong&gt;和 &lt;strong&gt;awake-from-sleep&lt;/strong&gt; 通知来帮助你获得这段时间的控制权。&lt;/p&gt;

&lt;p&gt;一个&lt;i&gt;runloop&lt;em&gt;&lt;/i&gt;可以通过使用&lt;i&gt;run loop object&lt;/i&gt;被唤醒。其他的事件也可能引起&lt;i&gt;runloop&lt;/em&gt;&lt;/i&gt;被唤醒。例如，添加&lt;i&gt;no-port-based input source&lt;/i&gt;来唤醒&lt;i&gt;runloop*&lt;/i&gt;以至于input source可以被立即处理，而不是等待其他的事件发生。&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
&lt;p&gt;iOS系统中有很多用到了RunLoop的地方：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;AutoreleasePool：监听&lt;code&gt;kCFRunLoopEntry&lt;/code&gt;事件，保证在所以回调之前创建自动释放池；监听&lt;code&gt;BeforeWaiting&lt;/code&gt;事件，释放旧的线程池，创建新的线程池；监听&lt;code&gt;kCFRunLoopExit&lt;/code&gt;事件，保证线程池最后被释放。&lt;/li&gt;
&lt;li&gt;事件响应：通过port-based input source监听用户的事件，并转发给App进程，如用UIControl的事件。&lt;/li&gt;
&lt;li&gt;手势识别：监听&lt;code&gt;kCFRunLoopBeforeWaiting&lt;/code&gt;事件在事件的回调函数中标记待处理的手势，并处理手势。&lt;/li&gt;
&lt;li&gt;界面更新：&lt;code&gt;setNeedsLayout&lt;/code&gt;、&lt;code&gt;setNeedsDisplay&lt;/code&gt;都会将该view标记为待处理，等到下一个runloop的时候会布局UI。&lt;/li&gt;
&lt;li&gt;定时器：就是一个CFRunLoopTimerRef&lt;/li&gt;
&lt;li&gt;PerformSelecter：将方法扔到某个线程中，在下一个run loop的时候执行。&lt;/li&gt;
&lt;li&gt;关于GCD：dispatch_async(dispatch_get_main_queue(), block)向主线程的run loop发送消息，唤醒run loop。并执行block中的内容。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;PPT总结一下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/1086250-cb2c4b4a6d0973e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;Screen Shot 2017-09-05 at 10.12.16 AM.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/1086250-fb6430f46efe4735.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;Screen Shot 2017-09-05 at 10.12.37 AM.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/1086250-7118fdeabb5ffe76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;Screen Shot 2017-09-05 at 10.12.53 AM.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/1086250-e7ae08b4d61ec9e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;Screen Shot 2017-09-05 at 10.13.01 AM.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/1086250-073579ed39612c1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;Screen Shot 2017-09-05 at 10.12.47 AM.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/1086250-cae92bc60b877b48.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;Screen Shot 2017-09-05 at 10.13.12 AM.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/1086250-fae8de2bdb8232aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;Screen Shot 2017-09-05 at 10.13.21 AM.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/1086250-ac972598a07a90bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;Screen Shot 2017-09-05 at 10.13.27 AM.png&#34; /&gt;&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>