<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>董二千</title>
    <link>https://LinkRober.github.io/bookshelf/tags/javsscript/index.xml</link>
    <description>Recent content on 董二千</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <atom:link href="https://LinkRober.github.io/bookshelf/tags/javsscript/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Object-C和JS通信概述</title>
      <link>https://linkrober.github.io/bookshelf/2017/12/object-c%E5%92%8Cjs%E9%80%9A%E4%BF%A1%E6%A6%82%E8%BF%B0/</link>
      <pubDate>Mon, 25 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://linkrober.github.io/bookshelf/2017/12/object-c%E5%92%8Cjs%E9%80%9A%E4%BF%A1%E6%A6%82%E8%BF%B0/</guid>
      <description>&lt;p&gt;本系列文章作为学习RN期间的总结&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://linkrober.github.io/bookshelf/2017/10/react-native%E5%A6%82%E4%BD%95%E9%9B%86%E6%88%90%E5%88%B0%E7%8E%B0%E6%9C%89%E9%A1%B9%E7%9B%AE%E4%B8%AD/&#34;&gt;React Native如何集成到现有项目中&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://linkrober.github.io/bookshelf/2017/10/react-native%E5%92%8Cnative%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1/&#34;&gt;React Native和Native间的通信实践&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://linkrober.github.io/bookshelf/2017/10/rctrootviewrctbridge%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88/&#34;&gt;RCTRootView、RCTBridge做了什么&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Object-C和JS通信概述&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h4 id=&#34;流程梳理&#34;&gt;流程梳理&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;../../../来自JSPath作者Bang的一张流程图.png&#34; alt=&#34;来自JSPath作者Bang的一张流程图&#34; /&gt;
首先，无论是RN端还是Native端都会持有一个bridge负责对来自不同端的模块进行桥街，再做消息处理。现附上一张来自JSPath作者Bang的图。
RN调用某个方法向Native发送消息，方法首先会被分解成ModuleId、MethodId和参数，发送到OCBridge。那么OCBridge是如何接受的呢？（因为对JS代码不熟悉这里只讨论OC部分）&lt;/p&gt;

&lt;p&gt;在第一次初始化ReactNative的时候模块信息会被初始化，包括模块名称、方法名。在注册模块的时候我们会用到&lt;code&gt;RCT_EXPORT_MODULE();&lt;/code&gt;这个宏，宏展开&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define RCT_EXPORT_MODULE(js_name) \
RCT_EXTERN void RCTRegisterModule(Class); \
+ (NSString *)moduleName { return @#js_name; } \
+ (void)load { RCTRegisterModule(self); }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;方法1:如果自定义了模块的名称就使用自定义的名称而不是原类的名称&lt;/p&gt;

&lt;p&gt;方法2:在+(void)load方法里对类进行一次注册，注册代码如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void RCTRegisterModule(Class moduleClass)
{
  static dispatch_once_t onceToken;
  dispatch_once(&amp;amp;onceToken, ^{
    RCTModuleClasses = [NSMutableArray new];
  });

  RCTAssert([moduleClass conformsToProtocol:@protocol(RCTBridgeModule)],
            @&amp;quot;%@ does not conform to the RCTBridgeModule protocol&amp;quot;,
            moduleClass);

  // Register module
  [RCTModuleClasses addObject:moduleClass];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果当前类遵循协议&lt;code&gt;RCTBridgeModule&lt;/code&gt;,就把它放到一个静态变量数组&lt;code&gt;RCTModuleClasses&lt;/code&gt;中。所以启动之后，所有RN需要的模块都会被动态载入。
这些模块会被存储在三张表中&lt;code&gt;_moduleDataByName&lt;/code&gt;、&lt;code&gt;_moduleDataByID&lt;/code&gt;、&lt;code&gt;_moduleClassesByID&lt;/code&gt;,在初始化的时候通过遍历该数组来初始化。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NSDictionary&amp;lt;NSString *, RCTModuleData *&amp;gt; *_moduleDataByName;
NSArray&amp;lt;RCTModuleData *&amp;gt; *_moduleDataByID;
NSArray&amp;lt;Class&amp;gt; *_moduleClassesByID;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;for (Class moduleClass in RCTGetModuleClasses()) {
    NSString *moduleName = RCTBridgeModuleNameForClass(moduleClass);

    // Check for module name collisions
    RCTModuleData *moduleData = moduleDataByName[moduleName];
    if (moduleData) {
      if (moduleData.hasInstance) {
        // Existing module was preregistered, so it takes precedence
        continue;
      } else if ([moduleClass new] == nil) {
        // The new module returned nil from init, so use the old module
        continue;
      } else if ([moduleData.moduleClass new] != nil) {
        // Both modules were non-nil, so it&#39;s unclear which should take precedence
        RCTLogError(@&amp;quot;Attempted to register RCTBridgeModule class %@ for the &amp;quot;
                    &amp;quot;name &#39;%@&#39;, but name was already registered by class %@&amp;quot;,
                    moduleClass, moduleName, moduleData.moduleClass);
      }
    }

    // Instantiate moduleData (TODO: can we defer this until config generation?)
    moduleData = [[RCTModuleData alloc] initWithModuleClass:moduleClass
                                                     bridge:self];
    moduleDataByName[moduleName] = moduleData;
    [moduleClassesByID addObject:moduleClass];
    [moduleDataByID addObject:moduleData];
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分别是模块名称、模块名称对应的对象&lt;code&gt;RCTModuleData&lt;/code&gt;、模块名称和模块对象的映射字典，方便后续使用。&lt;/p&gt;

&lt;p&gt;这时候还有一个重要的东西需要处理就是callback，JSBridge在传递消息的时候会把callback缓存起来，仅仅把callbackId传递到OCBridge。
这时候OCBridge拿到了传过来的ModuleId、MethodId、callbackId，再通过Native端的配置表分别取出模块和方法。模块会被转化为&lt;code&gt;RCTModuleData&lt;/code&gt;对象，方法都会被转化为一个&lt;code&gt;RCTModuleMethod&lt;/code&gt;对象，看一下这个对象&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  Class _moduleClass;
  const RCTMethodInfo *_methodInfo;
  NSString *_JSMethodName;

  SEL _selector;
  NSInvocation *_invocation;
  NSArray&amp;lt;RCTArgumentBlock&amp;gt; *_argumentBlocks;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;发现了&lt;code&gt;_moduleClass&lt;/code&gt;、&lt;code&gt;_argumentBlocks&lt;/code&gt;、&lt;code&gt;_invocation&lt;/code&gt;、&lt;code&gt;_selector&lt;/code&gt;这时候就很容易想到消息转发的最后一个阶段，将消息的目标、selector、参数封装到NSInvocation中进行消息转发。&lt;/p&gt;

&lt;p&gt;刚才上面讲到模块的注册，那么方法是如何筛选的呢？注意下面的3个宏&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define RCT_EXPORT_METHOD(method) \
  RCT_REMAP_METHOD(, method)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;#define RCT_REMAP_METHOD(js_name, method) \
  _RCT_EXTERN_REMAP_METHOD(js_name, method, NO) \
  - (void)method;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;#define _RCT_EXTERN_REMAP_METHOD(js_name, method, is_blocking_synchronous_method) \
  + (const RCTMethodInfo *)RCT_CONCAT(__rct_export__, RCT_CONCAT(js_name, RCT_CONCAT(__LINE__, __COUNTER__))) { \
    static RCTMethodInfo config = {#js_name, #method, is_blocking_synchronous_method}; \
    return &amp;amp;config; \
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在我们具体定义方法的时候并没有&lt;code&gt;-(void)&lt;/code&gt;字符串前缀，因为在预编译的时候，宏会帮我们加上这段字符（看第二个宏）。
第三个宏主要实现了字符串的拼接，&lt;code&gt;(__LINE__, __COUNTER__)&lt;/code&gt;的意思是为当前的宏生成一个唯一的tag（行数+一个数字），再和前面的&lt;code&gt;js_name&lt;/code&gt;连接，最后再和&lt;code&gt;__rct_export__&lt;/code&gt;连接，大概像这样&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-(void)__rct_export__8976699MethodName{
	//
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;其实&lt;strong&gt;COUNTER&lt;/strong&gt;是一个预定义的宏，这个值在编译过程中将从0开始计数，每次被调用时加1。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;所有JSBridge传过来的参数都是&lt;code&gt;NSNumber&lt;/code&gt;,OCBridge会把它们转化成基本类型和字符串。上面在提到JSBridge传参数的时候会带一个callbackId，这时候OCBridge会根据这个Id生成一个callback，保存在内存中。&lt;/p&gt;

&lt;p&gt;这时候OC执行方法的调用，执行block。将参数和callbackId传到JSBridge，JSBridge根据Id找到之前缓存的JSCallback，进行调用。到这里就完成RN-Native-RN的一个闭环。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;JS是怎么调用OC的呢？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;其实并不是JS调用OC，而是JS将消息放到一个消息队列里面MessageQueue，等OC来取，这里面还有很多问题值得讨论多长时间取一次；不来取怎么办。有待我们继续研究&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
&lt;p&gt;为什么OC和JS可以实现这种框架？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;要实现这个机制需要语言有动态反射的特性(OC是一门动态语言，消息和消息的target等都是在运行时决定)，即可以通过类/方法名字符串找到对应的类/方法进行调用，没有这特性就做不了。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;知识点&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;使用&lt;a href=&#34;https://linkrober.github.io/bookshelf/2017/09/run-loops-%E4%B8%80/&#34;&gt;RunLoop&lt;/a&gt;让JS线程常驻内存&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;//RCTJSCExecutor

+ (void)runRunLoopThread
{
  @autoreleasepool {
    // copy thread name to pthread name
    pthread_setname_np([NSThread currentThread].name.UTF8String);

    // Set up a dummy runloop source to avoid spinning
    CFRunLoopSourceContext noSpinCtx = {0, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
    CFRunLoopSourceRef noSpinSource = CFRunLoopSourceCreate(NULL, 0, &amp;amp;noSpinCtx);
    CFRunLoopAddSource(CFRunLoopGetCurrent(), noSpinSource, kCFRunLoopDefaultMode);
    CFRelease(noSpinSource);

    // run the run loop
    while (kCFRunLoopRunStopped != CFRunLoopRunInMode(kCFRunLoopDefaultMode, ((NSDate *)[NSDate distantFuture]).timeIntervalSinceReferenceDate, NO)) {
      RCTAssert(NO, @&amp;quot;not reached assertion&amp;quot;); // runloop spun. that&#39;s bad.
    }
  }
}

static NSThread *newJavaScriptThread(void)
{
  NSThread *javaScriptThread = [[NSThread alloc] initWithTarget:[RCTJSCExecutor class]
                                                       selector:@selector(runRunLoopThread)
                                                         object:nil];
  javaScriptThread.name = RCTJSCThreadName;
  javaScriptThread.qualityOfService = NSOperationQualityOfServiceUserInteractive;
  [javaScriptThread start];
  return javaScriptThread;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;通过动态&lt;a href=&#34;https://linkrober.github.io/bookshelf/2017/10/runtime%E4%B8%89-%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91/&#34;&gt;消息转发&lt;/a&gt;发送来自RN的消息,RCTModuleMethod&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;//RCTModuleMethod

NSMethodSignature *typeSignature = [RCTConvert methodSignatureForSelector:selector];
NSInvocation *typeInvocation = [NSInvocation invocationWithMethodSignature:typeSignature];
typeInvocation.selector = selector;
typeInvocation.target = [RCTConvert class];

[argumentBlocks addObject:^(__unused RCTBridge *bridge, NSUInteger index, id json) {
void *returnValue = malloc(typeSignature.methodReturnLength);
[typeInvocation setArgument:&amp;amp;json atIndex:2];
[typeInvocation invoke];
[typeInvocation getReturnValue:returnValue];
[invocation setArgument:returnValue atIndex:index + 2];
free(returnValue);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;用Runtime拿到所有的类信息和方法&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;//RCTBridge

void RCTVerifyAllModulesExported(NSArray *extraModules)
{
  // Check for unexported modules
  unsigned int classCount;
  Class *classes = objc_copyClassList(&amp;amp;classCount);

  NSMutableSet *moduleClasses = [NSMutableSet new];
  [moduleClasses addObjectsFromArray:RCTGetModuleClasses()];
  [moduleClasses addObjectsFromArray:[extraModules valueForKeyPath:@&amp;quot;class&amp;quot;]];

  for (unsigned int i = 0; i &amp;lt; classCount; i++) {
    Class cls = classes[i];
    Class superclass = cls;
    while (superclass) {
      if (class_conformsToProtocol(superclass, @protocol(RCTBridgeModule))) {
        if ([moduleClasses containsObject:cls]) {
          break;
        }

        // Verify it&#39;s not a super-class of one of our moduleClasses
        BOOL isModuleSuperClass = NO;
        for (Class moduleClass in moduleClasses) {
          if ([moduleClass isSubclassOfClass:cls]) {
            isModuleSuperClass = YES;
            break;
          }
        }
        if (isModuleSuperClass) {
          break;
        }

        RCTLogWarn(@&amp;quot;Class %@ was not exported. Did you forget to use RCT_EXPORT_MODULE()?&amp;quot;, cls);
        break;
      }
      superclass = class_getSuperclass(superclass);
    }
  }

  free(classes);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;GCD的大量使用，在初始化各个模块时(initModulesAndLoadSource和setupJSExecutorAndModuleConfig这两个group)对于线程依赖的控制&lt;code&gt;dispatch_group_enter();&lt;/code&gt;&lt;code&gt;dispatch_group_leave()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;//RCTBatchedBridge

- (void)start
{
  [[NSNotificationCenter defaultCenter]
    postNotificationName:RCTJavaScriptWillStartLoadingNotification
    object:_parentBridge userInfo:@{@&amp;quot;bridge&amp;quot;: self}];

  RCT_PROFILE_BEGIN_EVENT(0, @&amp;quot;-[RCTBatchedBridge setUp]&amp;quot;, nil);

  dispatch_queue_t bridgeQueue = dispatch_queue_create(&amp;quot;com.facebook.react.RCTBridgeQueue&amp;quot;, DISPATCH_QUEUE_CONCURRENT);

  dispatch_group_t initModulesAndLoadSource = dispatch_group_create();

  // Asynchronously load source code
  dispatch_group_enter(initModulesAndLoadSource);
  __weak RCTBatchedBridge *weakSelf = self;
  __block NSData *sourceCode;
  [self loadSource:^(NSError *error, NSData *source, __unused int64_t sourceLength) {
    if (error) {
      RCTLogWarn(@&amp;quot;Failed to load source: %@&amp;quot;, error);
      dispatch_async(dispatch_get_main_queue(), ^{
        [weakSelf stopLoadingWithError:error];
      });
    }

    sourceCode = source;
    dispatch_group_leave(initModulesAndLoadSource);
  } onProgress:^(RCTLoadingProgress *progressData) {
#if RCT_DEV &amp;amp;&amp;amp; __has_include(&amp;quot;RCTDevLoadingView.h&amp;quot;)
    RCTDevLoadingView *loadingView = [weakSelf moduleForClass:[RCTDevLoadingView class]];
    [loadingView updateProgress:progressData];
#endif
  }];

  // Synchronously initialize all native modules that cannot be loaded lazily
  [self initModulesWithDispatchGroup:initModulesAndLoadSource];

  RCTPerformanceLogger *performanceLogger = self-&amp;gt;_performanceLogger;
  __block NSString *config;
  dispatch_group_enter(initModulesAndLoadSource);
  dispatch_async(bridgeQueue, ^{
    dispatch_group_t setupJSExecutorAndModuleConfig = dispatch_group_create();

    // Asynchronously initialize the JS executor
    dispatch_group_async(setupJSExecutorAndModuleConfig, bridgeQueue, ^{
      [performanceLogger markStartForTag:RCTPLJSCExecutorSetup];
      [weakSelf setUpExecutor];
      [performanceLogger markStopForTag:RCTPLJSCExecutorSetup];
    });

    // Asynchronously gather the module config
    dispatch_group_async(setupJSExecutorAndModuleConfig, bridgeQueue, ^{
      if (weakSelf.valid) {
        RCT_PROFILE_BEGIN_EVENT(0, @&amp;quot;-[RCTBatchedBridge moduleConfig&amp;quot;, nil);
        [performanceLogger markStartForTag:RCTPLNativeModulePrepareConfig];
        config = [weakSelf moduleConfig];
        [performanceLogger markStopForTag:RCTPLNativeModulePrepareConfig];
        RCT_PROFILE_END_EVENT(RCTProfileTagAlways, @&amp;quot;&amp;quot;);
      }
    });

    dispatch_group_notify(setupJSExecutorAndModuleConfig, bridgeQueue, ^{
      // We&#39;re not waiting for this to complete to leave dispatch group, since
      // injectJSONConfiguration and executeSourceCode will schedule operations
      // on the same queue anyway.
      [performanceLogger markStartForTag:RCTPLNativeModuleInjectConfig];
      [weakSelf injectJSONConfiguration:config onComplete:^(NSError *error) {
        [performanceLogger markStopForTag:RCTPLNativeModuleInjectConfig];
        if (error) {
          RCTLogWarn(@&amp;quot;Failed to inject config: %@&amp;quot;, error);
          dispatch_async(dispatch_get_main_queue(), ^{
            [weakSelf stopLoadingWithError:error];
          });
        }
      }];
      dispatch_group_leave(initModulesAndLoadSource);
    });
  });

  dispatch_group_notify(initModulesAndLoadSource, bridgeQueue, ^{
    RCTBatchedBridge *strongSelf = weakSelf;
    if (sourceCode &amp;amp;&amp;amp; strongSelf.loading) {
      [strongSelf executeSourceCode:sourceCode];
    }
  });

  RCT_PROFILE_END_EVENT(RCTProfileTagAlways, @&amp;quot;&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;参考文档&#34;&gt;参考文档&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.cnbang.net/tech/2698/&#34;&gt;React Native通信机制详解&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://awhisper.github.io/2016/06/24/ReactNative%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/&#34;&gt;ReactNative iOS源码解析&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>RCTRootView、RCTBridge做了什么</title>
      <link>https://linkrober.github.io/bookshelf/2017/10/rctrootviewrctbridge%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88/</link>
      <pubDate>Sat, 28 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>https://linkrober.github.io/bookshelf/2017/10/rctrootviewrctbridge%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88/</guid>
      <description>&lt;p&gt;本系列文章作为学习RN期间的总结&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://linkrober.github.io/bookshelf/2017/10/react-native%E5%A6%82%E4%BD%95%E9%9B%86%E6%88%90%E5%88%B0%E7%8E%B0%E6%9C%89%E9%A1%B9%E7%9B%AE%E4%B8%AD/&#34;&gt;React Native如何集成到现有项目中&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://linkrober.github.io/bookshelf/2017/10/react-native%E5%92%8Cnative%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1/&#34;&gt;React Native和Native间的通信实践&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;RCTRootView、RCTBridge做了什么&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://linkrober.github.io/bookshelf/2017/12/native%E5%92%8Cjs%E9%80%9A%E4%BF%A1%E6%A6%82%E8%BF%B0/&#34;&gt;Object-C和JS通信概述&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;本章主要讨论，RCTRootView、RCTBridge彼此之间的关系，以及它们做了什么。先放上类图&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../../../相关类图.png&#34; alt=&#34;相关类图&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;rctrootview&#34;&gt;RCTRootView&lt;/h4&gt;

&lt;p&gt;它是RN在Native上展示的容器，&lt;code&gt;RCTJavaScriptWillStartLoadingNotification&lt;/code&gt;、&lt;code&gt;RCTJavaScriptDidLoadNotification&lt;/code&gt;、&lt;code&gt;RCTContentDidAppearNotification&lt;/code&gt;这些通知注册都在里面。同时也是运行js的入口。&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;highlight-text blue&#34;&gt;RCTJavaScriptWillStartLoadingNotification&lt;/span&gt;&lt;/br&gt;
当你在Debug模式下，选择&lt;strong&gt;Live Reload&lt;/strong&gt;每次保存js文件的时候就会重新加载js。之前的&lt;code&gt;reactTag&lt;/code&gt;会清空，等待重新赋值，但第一次初始化并不会触发这个通知。因为通知这时候还没注册。&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;highlight-text blue&#34;&gt;RCTJavaScriptDidLoadNotification&lt;/span&gt;&lt;/br&gt;
同样的在&lt;strong&gt;Live Reload&lt;/strong&gt;模式下，每次保存，才会正真的重新加载js，完毕之后，开始视图view的重新初始化即，&lt;code&gt;RCTRootContentView&lt;/code&gt;，然后&lt;code&gt;RCTRootView&lt;/code&gt;会通过bridge发送消息&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (void)enqueueJSCall:(NSString *)module 
			   method:(NSString *)method 
			     args:(NSArray *)args 
		   completion:(dispatch_block_t)completion;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它把模块名称，方法名和在native中定义的属性（上一节提到的properies）发送到js端，让js端完整的逻辑渲染&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;它们是如何控制在第一次初始化rootview的时候不执行&lt;code&gt;RCTJavaScriptDidLoadNotification&lt;/code&gt;这个通知定义的事件的呢？是通过下面的判断&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt; RCTBridge *bridge = notification.userInfo[@&amp;quot;bridge&amp;quot;];
  if (bridge != _contentView.bridge) {
    [self bundleFinishedLoading:bridge];
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;alert danger &#34;&gt;
  &lt;p&gt;&lt;code&gt;RCTBatchedBridge.mm&lt;/code&gt;是&lt;code&gt;RCTBridge.m&lt;/code&gt;的子类，但是在后面可能会废弃。&lt;code&gt;RCTBridge&lt;/code&gt;通过一种向下转型的方式，让其拥有了子类的能力。&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span class=&#34;highlight-text blue&#34;&gt;RCTContentDidAppearNotification&lt;/span&gt;&lt;/br&gt;
在视图出来的时候RN会通过这个通知隐藏loading页面，loading页面也是可以自定义的，通过重新它的&lt;code&gt;setLoadingView:&lt;/code&gt;方法。&lt;/p&gt;

&lt;span class=&#34;highlight-text yellow&#34;&gt;总结：&lt;/span&gt;

&lt;ul&gt;
&lt;li&gt;负责RN和Native通信的&lt;code&gt;RCTBridge&lt;/code&gt;实例的初始化。&lt;/li&gt;
&lt;li&gt;正真用来展示视图的&lt;code&gt;RCTRootContentView&lt;/code&gt;的初始化，完事后通过&lt;code&gt;[self insertSubview:_contentView atIndex:0];&lt;/code&gt;的方式加到rootview上。&lt;/li&gt;
&lt;li&gt;负责loading视图的展示和隐藏。&lt;/li&gt;
&lt;li&gt;负责在刷新视图时清空reactTag，它是也是区分js中每个view的identifier。&lt;/li&gt;
&lt;li&gt;负责通知&lt;code&gt;RCTBridge&lt;/code&gt;在合适的时候向JS发送已经准备好的信息，模块名，方法名、参数一起传递过去。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;rctbridge&#34;&gt;RCTBridge&lt;/h4&gt;

&lt;p&gt;所有的模块都保存在内存的静态常量区域，这个内存空间是在&lt;code&gt;RCTBridge&lt;/code&gt;中被初始化的。因此这些模块属于全局的变量，可以在不同的bridge之间共享。可以通过&lt;code&gt;NSString *RCTBridgeModuleNameForClass(Class cls)&lt;/code&gt;拿到每个模块的名称。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NSString *RCTBridgeModuleNameForClass(Class cls)
{
#if RCT_DEBUG
  RCTAssert([cls conformsToProtocol:@protocol(RCTBridgeModule)],
            @&amp;quot;Bridge module `%@` does not conform to RCTBridgeModule&amp;quot;, cls);
#endif

  NSString *name = [cls moduleName];
  if (name.length == 0) {
    name = NSStringFromClass(cls);
  }

  if ([name hasPrefix:@&amp;quot;RK&amp;quot;]) {
    name = [name substringFromIndex:2];
  } else if ([name hasPrefix:@&amp;quot;RCT&amp;quot;]) {
    name = [name substringFromIndex:3];
  }

  return name;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从上面的代码可以看出，在native中定义的模块在被传递到js的时候会加上&lt;code&gt;RK&lt;/code&gt;或者&lt;code&gt;RCT&lt;/code&gt;前缀。&lt;/p&gt;

&lt;div class=&#34;alert info no-icon &#34;&gt;
  &lt;p&gt;模块都是遵循&lt;code&gt;RCTBridgeModule&lt;/code&gt;协议的，用宏&lt;code&gt;RCT_EXPORT_MODULE();&lt;/code&gt;进行声明；&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;JS队列的初始化会在&lt;code&gt;RCTBridge&lt;/code&gt;被调用到的时候通过&lt;code&gt;+ (void)initialize&lt;/code&gt;进行初始化，而且它是一个单列对象。通过C的&lt;code&gt;extern __attribute__((visibility(&amp;quot;default&amp;quot;)))&lt;/code&gt;暴露出来，让该队列变量暴露在动态链接库之外&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dispatch_queue_t RCTJSThread;

+ (void)initialize
{
  static dispatch_once_t onceToken;
  dispatch_once(&amp;amp;onceToken, ^{

    // Set up JS thread
    RCTJSThread = (id)kCFNull;
  });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每一个当前视图正在使用的bridge也会放在静态常量区，每次视图切换的时候都会重新赋值。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static RCTBridge *RCTCurrentBridgeInstance = nil;

/**
 * The last current active bridge instance. This is set automatically whenever
 * the bridge is accessed. It can be useful for static functions or singletons
 * that need to access the bridge for purposes such as logging, but should not
 * be relied upon to return any particular instance, due to race conditions.
 */
+ (instancetype)currentBridge
{
  return RCTCurrentBridgeInstance;
}

+ (void)setCurrentBridge:(RCTBridge *)currentBridge
{
  RCTCurrentBridgeInstance = currentBridge;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在&lt;code&gt;RCTBridge&lt;/code&gt;的初始化方法中同时还会对&lt;code&gt;RCTBatchedBridge&lt;/code&gt;进行初始化，由其发送消息开始加载js。其中分为两步：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;初始化modul和load资源&lt;/li&gt;
&lt;li&gt;设置JS的Executor和modul的配置&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;它们在同一个队列&lt;code&gt;dispatch_queue_t bridgeQueue = dispatch_queue_create(&amp;quot;com.facebook.react.RCTBridgeQueue&amp;quot;, DISPATCH_QUEUE_CONCURRENT);&lt;/code&gt;里的两个不同的group中异步执行：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;dispatch_group_t initModulesAndLoadSource = dispatch_group_create();&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dispatch_group_t setupJSExecutorAndModuleConfig = dispatch_group_create();&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因为在第一个group中的异步方法中也存在异步操作所有作者使用的&lt;code&gt;dispatch_group_enter()&lt;/code&gt; 和 &lt;code&gt;dispatch_group_leave()&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;第二个group直接用的&lt;code&gt;dispatch_group_async(dispatch_group_t  _Nonnull group, dispatch_queue_t  _Nonnull queue, ^(void)block)&lt;/code&gt;
当第二group的异步任务完成之后（&lt;code&gt;initModulesAndLoadSource&lt;/code&gt;依赖&lt;code&gt;setupJSExecutorAndModuleConfig&lt;/code&gt;），就开始执行对应的notify闭包向js注入json字符串&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dispatch_group_notify(setupJSExecutorAndModuleConfig, bridgeQueue, ^{
      // We&#39;re not waiting for this to complete to leave dispatch group, since
      // injectJSONConfiguration and executeSourceCode will schedule operations
      // on the same queue anyway.
      [performanceLogger markStartForTag:RCTPLNativeModuleInjectConfig];
      [weakSelf injectJSONConfiguration:config onComplete:^(NSError *error) {
        [performanceLogger markStopForTag:RCTPLNativeModuleInjectConfig];
        if (error) {
          RCTLogWarn(@&amp;quot;Failed to inject config: %@&amp;quot;, error);
          dispatch_async(dispatch_get_main_queue(), ^{
            [weakSelf stopLoadingWithError:error];
          });
        }
      }];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;待第二个group结束，开始执行第一个group对应的notify闭包,开始加载js，加载结束之后发出&lt;code&gt;RCTJavaScriptDidLoadNotification&lt;/code&gt;通知。&lt;/p&gt;

&lt;div class=&#34;alert info no-icon &#34;&gt;
  &lt;p&gt;执行JS所有相关的内容都是&lt;code&gt;@protocol RCTJavaScriptExecutor&lt;/code&gt;这个协议负责，定义在bridge中&lt;code&gt;@property (nonatomic, weak, readonly) id&amp;lt;RCTJavaScriptExecutor&amp;gt; javaScriptExecutor;&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;当你在Debug模式下save或者退出当前页面的时候收到reload命令，该类会在主线程中将当前的bridge置空，如果没有成功会调用其所遵循的协议&lt;code&gt;@protocol RCTInvalidating&lt;/code&gt;中的&lt;code&gt;invalidate&lt;/code&gt;方法进行一系列的局部变量释放操作&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (void)invalidate
{
  RCTBridge *batchedBridge = self.batchedBridge;
  self.batchedBridge = nil;

  if (batchedBridge) {
    RCTExecuteOnMainQueue(^{
      [batchedBridge invalidate];
    });
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;span class=&#34;highlight-text yellow&#34;&gt;总结：&lt;/span&gt;

&lt;ul&gt;
&lt;li&gt;保存模块的集合 &amp;ndash;&lt;code&gt;RCTModuleClasses&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;定义了JS队列 &amp;ndash; &lt;code&gt;dispatch_queue_t RCTJSThread&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;定义当前正在使用的bridge，并负责切换&lt;/li&gt;
&lt;li&gt;负责&lt;code&gt;RCTBatchedBridge&lt;/code&gt;的初始化，调用子类bridge，开始执行加载js的一系列操作&lt;/li&gt;
&lt;li&gt;负责在view消失或者重新加载的时候释放之前的一些对象（eg. currentbridge,遵循&lt;code&gt;RCTBridgeModule&lt;/code&gt;协议的对象）。&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>React Native和Native间的通信实践</title>
      <link>https://linkrober.github.io/bookshelf/2017/10/react-native%E5%92%8Cnative%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E5%AE%9E%E8%B7%B5/</link>
      <pubDate>Wed, 25 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>https://linkrober.github.io/bookshelf/2017/10/react-native%E5%92%8Cnative%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E5%AE%9E%E8%B7%B5/</guid>
      <description>&lt;!-- thumbnailImage = &#39;rn_image.jpeg&#39;
thumbnailImagePosition = &#39;bottom&#39; --&gt;

&lt;p&gt;本系列文章作为学习RN期间的总结&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://linkrober.github.io/bookshelf/2017/10/react-native%E5%A6%82%E4%BD%95%E9%9B%86%E6%88%90%E5%88%B0%E7%8E%B0%E6%9C%89%E9%A1%B9%E7%9B%AE%E4%B8%AD/&#34;&gt;React Native如何集成到现有项目中&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;React Native和Native间的通信实践&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://linkrober.github.io/bookshelf/2017/10/rctrootviewrctbridge%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88/&#34;&gt;RCTRootView、RCTBridge做了什么&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://linkrober.github.io/bookshelf/2017/12/native%E5%92%8Cjs%E9%80%9A%E4%BF%A1%E6%A6%82%E8%BF%B0/&#34;&gt;Object-C和JS通信概述&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;刚开始接触RN，有几点大家都想弄清楚：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;如何从Native向RN传递参数，这里也分为几小点&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;在初始化RN的时候如何从Native传递初始化的参数&lt;/li&gt;
&lt;li&gt;在RN视图已经渲染完成之后，如果从Native那参数&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如何从RN向Native传递参数：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;如何向Native发送消息（能否使用闭包）&lt;/li&gt;
&lt;li&gt;如何让RN接受naitve的异步回调&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;native-rn&#34;&gt;Native -&amp;gt; RN&lt;/h4&gt;

&lt;h6 id=&#34;properties&#34;&gt;Properties&lt;/h6&gt;

&lt;p&gt;&lt;code&gt;properties&lt;/code&gt;是RN和Native间通信最简单的方式。我们只需要在初始化&lt;code&gt;RCTRootView&lt;/code&gt;的时候，将需要的数据通过方法入参的形式传入，它是一个字典类型。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (instancetype)initWithBundleURL:(NSURL *)bundleURL
                       moduleName:(NSString *)moduleName
                initialProperties:&lt;span class=&#34;highlight-text red&#34;&gt;(NSDictionary *)initialProperties&lt;/span&gt;
                    launchOptions:(NSDictionary *)launchOptions
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在RN中我们用来承接&lt;code&gt;initialProperties&lt;/code&gt;参数的就是每个js类的&lt;code&gt;props&lt;/code&gt;。如果我们需要在Native中修改&lt;code&gt;props&lt;/code&gt;属性，就要对&lt;code&gt;RCTRootView&lt;/code&gt;的&lt;code&gt;appProperties&lt;/code&gt;进行重新赋值，然后RN会对视图进行重新渲染，当且仅当两次赋值不一样的时候才会重新渲染。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rootView.appProperties = @{@&amp;quot;content&amp;quot; : imageList};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们也可以使用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (instancetype)initWithBridge:(RCTBridge *)bridge
                    moduleName:(NSString *)moduleName
             initialProperties:(NSDictionary *)initialProperties NS_DESIGNATED_INITIALIZER;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在初始化bridge时以代理的方式将bundleURL传入：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (instancetype)initWithDelegate:(id&amp;lt;RCTBridgeDelegate&amp;gt;)delegate
                   launchOptions:(NSDictionary *)launchOptions;


 @protocol RCTBridgeDelegate &amp;lt;NSObject&amp;gt;

/**
 * The location of the JavaScript source file. When running from the packager
 * this should be an absolute URL, e.g. `http://localhost:8081/index.ios.bundle`.
 * When running from a locally bundled JS file, this should be a `file://` url
 * pointing to a path inside the app resources, e.g. `file://.../main.jsbundle`.
 */
- (NSURL *)sourceURLForBridge:(RCTBridge *)bridge;

@optional 
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;alert warning &#34;&gt;
  &lt;p&gt;需要注意的是，赋值操作必需要放在Native的主线程。而且js中的&lt;code&gt;componentWillReceiveProps&lt;/code&gt;和&lt;code&gt;componentWillUpdateProps&lt;/code&gt;并不会因为重新渲染而被再次调用，你只能在&lt;code&gt;componentWillMount&lt;/code&gt;方法中访问新的&lt;code&gt;props&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;h6 id=&#34;rcteventemitter&#34;&gt;RCTEventEmitter&lt;/h6&gt;

&lt;p&gt;我们可以使用&lt;code&gt;RCTEventEmitter&lt;/code&gt;类来让js监听native的事件，facebook的文档中是这样描述&lt;code&gt;RCTEventEmitter&lt;/code&gt;的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * RCTEventEmitter is an abstract base class to be used for modules that emit
 * events to be observed by JS.
 */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它是一个模块的抽象基类，用来发送被JS监听的事件。我们通过&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (void)sendEventWithName:(NSString *)name body:(id)body
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;方法来完成事件的发送。入参是事件名称和需要携带的参数（Dictionary）。
每一个&lt;code&gt;RCTRootView&lt;/code&gt;都有一个&lt;code&gt;RCTBridge&lt;/code&gt;属性，它是RN中非常重要的一个类，负责Native和JS之间的通信。通过&lt;code&gt;RCTBridge&lt;/code&gt;的:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * Retrieve a bridge module instance by name or class. Note that modules are
 * lazily instantiated, so calling these methods for the first time with a given
 * module name/class may cause the class to be sychronously instantiated,
 * potentially blocking both the calling thread and main thread for a short time.
 */
- (id)moduleForName:(NSString *)moduleName;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;方法，我们可以拿到每个&lt;code&gt;RCTRootView&lt;/code&gt;对应的&lt;code&gt;RCTEventEmitter&lt;/code&gt;实例（它是通过lazy load的方式初始化的），因为这里的&lt;code&gt;moduleName&lt;/code&gt;参数可以是类名也可以是自定义的模块名称，所以在项目中如果出现多个实例，需要在初始化通过view的&lt;code&gt;reactTag&lt;/code&gt;属性来区分。该属性声明在分类&lt;code&gt;UIView+React.h&lt;/code&gt;中。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;RCT_EXPORT_MODULE();

+ (EventEmitterManger *)mangerWithRootView:(RCTRootView *)rootView {
    return [rootView.bridge moduleForName:NSStringFromClass(self)];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样我们就拿到目标RootView对应的&lt;code&gt;RCTEventEmitter&lt;/code&gt;对象。接下来我们需要为事件定义一个identifier，重写&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * Override this method to return an array of supported event names. Attempting
 * to observe or send an event that isn&#39;t included in this list will result in
 * an error.
 */
- (NSArray&amp;lt;NSString *&amp;gt; *)supportedEvents;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;方法，把你方法的identifer作为数组的一个元素返回。这样就可以使用上面所说的方法进行消息的发送了。
到这里Native端的代码已经完成了，下面看在js中如何设置。
我们需要在对应的js中引入一个&lt;code&gt;NativeModules&lt;/code&gt;、&lt;code&gt;NativeEventEmitter&lt;/code&gt;模块，然后获取监听模块的manger&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var raToRnManger = NativeModules.EventEmitterManger
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在js对象的声明周期方法&lt;code&gt;componentWillMount&lt;/code&gt;中设置监听，接下来就等native发送消息了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;componentWillMount(){
         var raToRnMangerEmitter = new NativeEventEmitter(raToRnManger)
          const subscription = raToRnMangerEmitter.addListener(&amp;quot;EventReminder&amp;quot;,
              (reminder) =&amp;gt; {
                  console.log(&amp;quot;test&amp;quot;)
                    this.setState({
                        name:&amp;quot;B&amp;quot;
                    })
              }
          );
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;rn-native&#34;&gt;RN -&amp;gt; Native&lt;/h4&gt;

&lt;h6 id=&#34;rctbridgemodule&#34;&gt;RCTBridgeModule&lt;/h6&gt;

&lt;p&gt;在Native端定义RN模块的时候，让其遵循&lt;code&gt;&amp;lt;RCTBridgeModule&amp;gt;&lt;/code&gt;协议，在实现文件中暴露出你想要从RN向Native发送的消息&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;RCT_EXPORT_METHOD(exampleMethod:(NSString *)name)
{
    NSLog(@&amp;quot;%@&amp;quot;,name);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你想要该方法参数支持闭包，可以使用RN内置的闭包类型&lt;code&gt;RCTResponseSenderBlock&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;RCT_EXPORT_METHOD(exampleCallbackMethod:(RCTResponseSenderBlock)callback)
{
    NSDictionary *param = @{@&amp;quot;letter&amp;quot;:@&amp;quot;B&amp;quot;};
    callback(@[[NSNull null], param]);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在js端，通过&lt;code&gt;NativeModules&lt;/code&gt;模块拿到Native中对应的模块&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var manger = NativeModules.ExportMethodManger
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果RN中某个事件被触发了，直接通过manger向Native发送消息，消息名称正如你在Native中声明的那样&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;onPressLearnMore(){
        manger.exampleMethod(&amp;quot;##############Learn More############&amp;quot;)
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在Native项目中嵌入RN，你绝对不想要在js中再写一套网络请求吧。这时候就会遇到用RN展示UI，而数据请求放在在Native中做的情况。我们可以使用&lt;code&gt;XMLHttpRequest&lt;/code&gt;这类js网络框架，但是这里想说的是&lt;code&gt;async/await&lt;/code&gt;语法，它在ES6中被提供。从命名上一眼就能看出其目的，异步方法等待消息返回。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;async updateEvents(){
        try {
            var events = await manger.findEvents();
            this.setState({
                letter:events[0].letter
            });
          } catch (e) {
            console.error(e);
          }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，如果Native中&lt;code&gt;findEvents&lt;/code&gt;是一个异步的方法就可以在js中等待Native的回调了。&lt;/p&gt;

&lt;div class=&#34;alert info &#34;&gt;
  &lt;p&gt;从JS到Naitve所有的消息都是由&lt;code&gt;NSInvocation&lt;/code&gt;负责转发，后面打算专门开一章讨论这个类在RN中的使用。&lt;/p&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>React Native如何集成到现有项目中</title>
      <link>https://linkrober.github.io/bookshelf/2017/10/react-native%E5%A6%82%E4%BD%95%E9%9B%86%E6%88%90%E5%88%B0%E7%8E%B0%E6%9C%89%E9%A1%B9%E7%9B%AE%E4%B8%AD/</link>
      <pubDate>Mon, 23 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>https://linkrober.github.io/bookshelf/2017/10/react-native%E5%A6%82%E4%BD%95%E9%9B%86%E6%88%90%E5%88%B0%E7%8E%B0%E6%9C%89%E9%A1%B9%E7%9B%AE%E4%B8%AD/</guid>
      <description>&lt;!-- thumbnailImage = &#39;rn_thumbnailImage.jpeg&#39;
thumbnailImagePosition = &#39;bottom&#39; --&gt;

&lt;p&gt;本系列文章作为学习RN期间的总结&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;React Native如何集成到现有项目中&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://linkrober.github.io/bookshelf/2017/10/react-native%E5%92%8Cnative%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1/&#34;&gt;React Native和Native间的通信实践&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://linkrober.github.io/bookshelf/2017/10/rctrootviewrctbridge%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88/&#34;&gt;RCTRootView、RCTBridge做了什么&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://linkrober.github.io/bookshelf/2017/12/native%E5%92%8Cjs%E9%80%9A%E4%BF%A1%E6%A6%82%E8%BF%B0/&#34;&gt;Object-C和JS通信概述&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;虽然ReactNative能做到iOS和Android的大部分逻辑共享一套代码，节约开发成本；拥有像JSPatch那样的热修复功能，为线上问题提供非常灵活的解决方案。但是为什么大部分公司还是持观望态度，或者只在产品的某些部分用RN进行开发呢？&lt;/p&gt;

&lt;p&gt;首先，React Native官方的某些组件仍然存在性能瓶颈，开发复杂场景的时候可能会遇到性能问题，像ListView，动不动就渲染整个视图，虽然推出了FlatList但是也存在着一些其他的Bug。其次，RN的周边生态并不完善，很多OC或Swift上已有的Library在NR上需要通过RN提供的方法重新用JS实现或者需要把这些库桥接到RN。因此大部分公司会选择交互不多，页面不太复杂的场景来尝试。本章，主要介绍如果在已有的App中集成React Native。&lt;/p&gt;

&lt;h4 id=&#34;关键步骤&#34;&gt;关键步骤&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;设置RN的依赖和目录结构&lt;/li&gt;
&lt;li&gt;搞清楚你要在你的项目中使用的RN组件&lt;/li&gt;
&lt;li&gt;使用CocoaPods添加你要使用的RN组件的依赖&lt;/li&gt;
&lt;li&gt;使用npm安装JS组件&lt;/li&gt;
&lt;li&gt;在JavaScript环境下，开发你的RN模块&lt;/li&gt;
&lt;li&gt;添加一个&lt;code&gt;RCTRootView&lt;/code&gt;到你的app。它将会作为容器展示你的RN模块。&lt;/li&gt;
&lt;li&gt;启动RN服务，Run你的App。&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&#34;alert info &#34;&gt;
  &lt;p&gt;前置条件：安装Node、npm最新版本(npm是基于Node实现的包管理工具和iOS的CocoaPod地位相当)&lt;/p&gt;
&lt;/div&gt;

&lt;h6 id=&#34;设置rn的依赖和目录结构&#34;&gt;设置RN的依赖和目录结构&lt;/h6&gt;

&lt;p&gt;为React Native项目创建一个新的文件夹，在文件夹中新建&lt;code&gt;/ios&lt;/code&gt;目录，拷贝所有原项目的内容到&lt;code&gt;/ios&lt;/code&gt;目录下。&lt;/p&gt;

&lt;h6 id=&#34;安装javascript依赖&#34;&gt;安装JavaScript依赖&lt;/h6&gt;

&lt;p&gt;在刚刚新建的文件夹中（即根目录中）创建一个&lt;code&gt;package.json&lt;/code&gt;文件，并添加一下内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;name&amp;quot;: &amp;quot;Snapvote&amp;quot;,
  &amp;quot;version&amp;quot;: &amp;quot;0.0.1&amp;quot;,
  &amp;quot;private&amp;quot;: true,
  &amp;quot;scripts&amp;quot;: {
    &amp;quot;start&amp;quot;: &amp;quot;node node_modules/react-native/local-cli/cli.js start&amp;quot;,
    &amp;quot;test&amp;quot;: &amp;quot;jest&amp;quot;
  },
  &amp;quot;dependencies&amp;quot;: {
    &amp;quot;react&amp;quot;: &amp;quot;16.0.0-alpha.12&amp;quot;,
    &amp;quot;react-native&amp;quot;: &amp;quot;0.48.4&amp;quot;,
    &amp;quot;react-native-vector-icons&amp;quot;: &amp;quot;^4.4.2&amp;quot;,
    &amp;quot;whatwg-fetch&amp;quot;: &amp;quot;^2.0.3&amp;quot;
  },
  &amp;quot;devDependencies&amp;quot;: {
    &amp;quot;babel-jest&amp;quot;: &amp;quot;21.2.0&amp;quot;,
    &amp;quot;babel-preset-react-native&amp;quot;: &amp;quot;4.0.0&amp;quot;,
    &amp;quot;jest&amp;quot;: &amp;quot;21.2.0&amp;quot;,
    &amp;quot;react-test-renderer&amp;quot;: &amp;quot;16.0.0-alpha.12&amp;quot;
  },
  &amp;quot;jest&amp;quot;: {
    &amp;quot;preset&amp;quot;: &amp;quot;react-native&amp;quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下去，安装react和react-native包。打开Terminal，在你项目的根目录下面执行下面命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install --save r16.0.0-alpha.12 react-native
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;alert warning &#34;&gt;
  &lt;p&gt;要确保这里安装的版本和package.json里说明的版本一致&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;执行这个命令之后，将会在项目的根目录下创建一个&lt;code&gt;/node_modules&lt;/code&gt;的目录，这里保存着所有你项目中所需的JavaScript依赖。&lt;/p&gt;

&lt;h6 id=&#34;安装cocoapods&#34;&gt;安装CocoaPods&lt;/h6&gt;

&lt;p&gt;这里就不说了&lt;/p&gt;

&lt;h6 id=&#34;配置cocoapods依赖&#34;&gt;配置CocoaPods依赖&lt;/h6&gt;

&lt;p&gt;在你集成RN到你项目中之前，你需要选择你要使用的React Native库。你将通过CocoaPod库的开发模式将其集成进去。
&lt;img src=&#34;../../../pod_develop.png&#34; alt=&#34;pod_develop&#34; /&gt;
这些库的&lt;code&gt;subspec&lt;/code&gt;文件都会在&lt;code&gt;/node_modules&lt;/code&gt;目录下被说明,最后执行&lt;code&gt;pod install&lt;/code&gt;命令，所有的React Native库依赖到这里就都准备好了。
&lt;img src=&#34;../../../pod_file.png&#34; alt=&#34;pod_file&#34; /&gt;&lt;/p&gt;

&lt;h6 id=&#34;业务代码&#34;&gt;业务代码&lt;/h6&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;创建 &lt;code&gt;index.js&lt;/code&gt; 文件
在项目的根目录下创建&lt;code&gt;index.js&lt;/code&gt;文件，这个文件是你RN项目的
&lt;span class=&#34;highlight-text danger&#34;&gt;
入口
&lt;/span&gt;，所有在Native中要用到的RN模块都在这里面进行注册。例如项目中的投票列表、设置页面等。各个模块的名称要和Native中的模块名称对应。
&lt;img src=&#34;../../../rn_modul.png&#34; alt=&#34;rn_modul&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;添加React Native 代码（JavaScript和CSS）&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;&#39;use strict&#39;;

import React from &#39;react&#39;;
import {
  AppRegistry,
  StyleSheet,
  Text,
  View,
  FlatList,
  NativeModules,
  Image,
  ActivityIndicator,
  TouchableOpacity,
  ScrollView,
  Switch,
  TouchableWithoutFeedback,
  Alert,
  NativeEventEmitter,
  
} from &#39;react-native&#39;;

import StarRatingView from &#39;./starRating.view.js&#39;

var { width, height } = require(&#39;Dimensions&#39;).get(&#39;window&#39;);
var nativeModuleManager = NativeModules.XYRCTBrigeModule;

class SettingsView extends React.PureComponent{

    constructor(props){
        super(props);
    }
    .....
    .....
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在Native中使用&lt;code&gt;RCTRootView&lt;/code&gt;作为RN模块的容器。所有通过RN渲染出来的视图都会展示在该View上。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#import &amp;lt;React/RCTBundleURLProvider.h&amp;gt;
#import &amp;lt;React/RCTRootView.h&amp;gt;

@implementation AppDelegate

- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{
  NSURL *jsCodeLocation;
  &lt;span class=&#34;highlight-text green&#34;&gt;//设置获取JavaScript文件的路径，从服务器或者本地文件获取&lt;/span&gt;
#if DEBUG
  jsCodeLocation = [NSURL URLWithString:@&amp;quot;http://10.0.30.119:8081/index.ios.bundle?platform=ios&amp;quot;];
#else
  jsCodeLocation = [[RCTBundleURLProvider sharedSettings] jsBundleURLForBundleRoot:@&amp;quot;index.ios&amp;quot; fallbackResource:nil];
#endif
  
  &lt;span class=&#34;highlight-text green&#34;&gt;//通过URL、模块名称加载对应的RN视图，生成一个OC对象`RCTRootView`，最后将该View添加到controller的View上&lt;/span&gt;
  RCTRootView *rootView = [[RCTRootView alloc] initWithBundleURL:jsCodeLocation
                                                      moduleName:@&amp;quot;TabberView&amp;quot;
                                               initialProperties:nil
                                                   launchOptions:launchOptions];
  rootView.backgroundColor = [[UIColor alloc] initWithRed:1.0f green:1.0f blue:1.0f alpha:1];
  
  self.window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds];
  UIViewController *rootViewController = [UIViewController new];
  rootViewController.view = rootView;
  self.window.rootViewController = rootViewController;
  [self.window makeKeyAndVisible];
  return YES;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;到这里就完成了一个简单React Native App的集成。&lt;/p&gt;

&lt;h4 id=&#34;测试&#34;&gt;测试&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;因为HTTPS的限制，请将Domain添加到&lt;code&gt;Info.plist&lt;/code&gt;的白名单
&lt;code&gt;
&amp;lt;key&amp;gt;NSAppTransportSecurity&amp;lt;/key&amp;gt;
&amp;lt;dict&amp;gt;
&amp;lt;key&amp;gt;NSExceptionDomains&amp;lt;/key&amp;gt;
&amp;lt;dict&amp;gt;
    &amp;lt;key&amp;gt;localhost&amp;lt;/key&amp;gt;
    &amp;lt;dict&amp;gt;
        &amp;lt;key&amp;gt;NSTemporaryExceptionAllowsInsecureHTTPLoads&amp;lt;/key&amp;gt;
        &amp;lt;true/&amp;gt;
    &amp;lt;/dict&amp;gt;
&amp;lt;/dict&amp;gt;
&amp;lt;/dict&amp;gt;
&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;执行&lt;code&gt;npm start&lt;/code&gt;开启本地服务&lt;/li&gt;
&lt;li&gt;Xcode run.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;相关链接&#34;&gt;相关链接&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;https://facebook.github.io/react-native/docs/integration-with-existing-apps.html&#34;&gt;Integration with Existing Apps&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>