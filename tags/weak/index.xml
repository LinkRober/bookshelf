<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>董二千</title>
    <link>https://LinkRober.github.io/bookshelf/tags/weak/index.xml</link>
    <description>Recent content on 董二千</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <atom:link href="https://LinkRober.github.io/bookshelf/tags/weak/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Weak的实现-&amp;SideTables()[oldObj]</title>
      <link>https://linkrober.github.io/bookshelf/2020/12/weak%E7%9A%84%E5%AE%9E%E7%8E%B0-sidetablesoldobj/</link>
      <pubDate>Tue, 08 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linkrober.github.io/bookshelf/2020/12/weak%E7%9A%84%E5%AE%9E%E7%8E%B0-sidetablesoldobj/</guid>
      <description>&lt;p&gt;&lt;code&gt;&amp;amp;SideTables()[oldObj]&lt;/code&gt;这是什么？很多人看到这里都被这操作搞蒙了，下面分三步来理解，分别是&lt;code&gt;SideTables()&lt;/code&gt;、&lt;code&gt;[oldObj]&lt;/code&gt;、&lt;code&gt;&amp;amp;&lt;/code&gt;。先贴上入口的代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;id oldObj;
SideTable *oldTable;

oldObj = *location;
oldTable = &amp;amp;SideTables()[oldObj];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h4 id=&#34;1-理解-sidetables&#34;&gt;1. 理解&lt;code&gt;SideTables()&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;首先&lt;code&gt;SideTables()&lt;/code&gt;是一个静态函数，完全体是这样的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static StripedMap&amp;lt;SideTable&amp;gt;&amp;amp; SideTables() {
    return SideTablesMap.get();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;函数体里面调用了一个全局的静态变量&lt;code&gt;SideTablesMap&lt;/code&gt;的&lt;code&gt;get()&lt;/code&gt;方法，
静态变量里面保存了所有的&lt;code&gt;SideTable&lt;/code&gt;。的声明如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static objc::ExplicitInit&amp;lt;StripedMap&amp;lt;SideTable&amp;gt;&amp;gt; SideTablesMap;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出&lt;code&gt;SideTablesMap&lt;/code&gt;是在命名空间objc下面的一个&lt;code&gt;ExplicitInit&lt;/code&gt;类，它里面实现了&lt;code&gt;get()&lt;/code&gt;方法，如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Type &amp;amp;get() {
    return *reinterpret_cast&amp;lt;Type *&amp;gt;(_storage);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于不熟悉c++的理解下面这几点基本就能看懂：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;c++ 中的引用&lt;code&gt;&amp;amp;&lt;/code&gt;，在c++中&lt;code&gt;&amp;amp;&lt;/code&gt;除了有&lt;code&gt;取地址&lt;/code&gt;的作用还可以作为&lt;code&gt;引用&lt;/code&gt;。方法返回的是一个引用，如果没有c++基础的很容易误认为返回了一个指针。&lt;/li&gt;
&lt;li&gt;c++中的模板&lt;code&gt;template&lt;/code&gt;，泛型&lt;code&gt;Type&lt;/code&gt;是通过模板传入的，即&lt;code&gt;StripedMap&lt;/code&gt;。
从上面声明&lt;code&gt;SideTablesMap&lt;/code&gt;的地方可以看到，这里是个模板的嵌套，&lt;code&gt;StripedMap&lt;/code&gt;是&lt;code&gt;ExplicitInit&lt;/code&gt;模板的泛型；&lt;code&gt;SideTable&lt;/code&gt;是&lt;code&gt;StripedMap&lt;/code&gt;模板的泛型。&lt;/li&gt;
&lt;li&gt;c++中的&lt;code&gt;reinterpret_cast&amp;lt;new_type&amp;gt;(expression)
&lt;/code&gt;，它可以将两种任何类型进行转换，新值和旧值（expression）有相同的比特位。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;最后用&lt;code&gt;*&lt;/code&gt;取转换后得到的地址的所保存的值，返回，所以说这里返回的不是指针。
&lt;code&gt;Type *&lt;/code&gt;就相当于&lt;code&gt;StripedMap *&lt;/code&gt;，所以&lt;code&gt;get()&lt;/code&gt;方法返回的就是&lt;code&gt;StripedMap&lt;/code&gt;结构体实例。&lt;/p&gt;

&lt;h4 id=&#34;2-理解-oldobj&#34;&gt;2. 理解&lt;code&gt;[oldObj]&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;这里的&lt;code&gt;[]&lt;/code&gt;其实是对&lt;code&gt;[]&lt;/code&gt;进行了重载&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;T&amp;amp; operator[] (const void *p) { 
        return array[indexForPointer(p)].value; 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在&lt;code&gt;indexForPointer()&lt;/code&gt;方法里，先将结构体指针&lt;code&gt;oldObj&lt;/code&gt;转化成和其有相同比特位的地址，再进行位移、异或、去模操作得到一个从0-63位之间的&lt;code&gt;index&lt;/code&gt;，通过&lt;code&gt;index&lt;/code&gt;，拿到数组里面的&lt;code&gt;PaddedT&lt;/code&gt;结构体，返回该结构体的&lt;code&gt;value&lt;/code&gt;成员即结构体&lt;code&gt;SideTable&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static unsigned int indexForPointer(const void *p) {
        uintptr_t addr = reinterpret_cast&amp;lt;uintptr_t&amp;gt;(p);
        return ((addr &amp;gt;&amp;gt; 4) ^ (addr &amp;gt;&amp;gt; 9)) % StripeCount;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt; struct PaddedT {
        T value alignas(CacheLineSize);
    };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其实&lt;code&gt;StripedMap&lt;/code&gt;是一个以&lt;code&gt;void *p&lt;/code&gt;为&lt;code&gt;key&lt;/code&gt;，&lt;code&gt;PaddedT&lt;/code&gt;为&lt;code&gt;value&lt;/code&gt;的的表。&lt;/p&gt;

&lt;h4 id=&#34;3&#34;&gt;3. &lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;最后对&lt;code&gt;SideTables()[oldObj]&lt;/code&gt;即&lt;code&gt;SideTable&lt;/code&gt;取地址，这样就和&lt;code&gt;SideTable *newTable;&lt;/code&gt;对上了。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Weak的实现（一）</title>
      <link>https://linkrober.github.io/bookshelf/2020/12/weak%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%80/</link>
      <pubDate>Tue, 08 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linkrober.github.io/bookshelf/2020/12/weak%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%80/</guid>
      <description>&lt;p&gt;本文较长分三篇按序阅读体验更佳，第四篇为辅助阅读按需看&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://linkrober.github.io/bookshelf/2020/12/weak%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%80/&#34;&gt;Weak的实现（一）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://linkrober.github.io/bookshelf/2020/12/weak%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%BA%8C/&#34;&gt;Weak的实现（二）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://linkrober.github.io/bookshelf/2020/12/weak%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%89/&#34;&gt;Weak的实现（三）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://linkrober.github.io/bookshelf/2020/12/weak%E7%9A%84%E5%AE%9E%E7%8E%B0-sidetablesoldobj/&#34;&gt;Weak的实现-&amp;amp;SideTables()[oldObj]&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;带着问题看源码：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;大家都知道weak的底层实现是一个散列表，那么散列表的结构是什么样的？&lt;/li&gt;
&lt;li&gt;散列表的key是什么，value是什么，散列函数是怎样的？&lt;/li&gt;
&lt;li&gt;通过几次查找才能找到对应的弱引用？&lt;/li&gt;
&lt;li&gt;如何查找弱引用对象的引用计数？&lt;/li&gt;
&lt;li&gt;一个对象对应一个&lt;code&gt;SideTable&lt;/code&gt;表而一个&lt;code&gt;SideTable&lt;/code&gt;对应多个对象，为什么这样设计&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;散列表：散列表（Hash table），根据键直接方法在内存存储位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做散列表。&lt;/p&gt;

&lt;p&gt;散列函数：它是一个函数，如果把它定义成hash(key)，其中key表示元素的键值，在hash(key)的值表示经过散列函数计算得到的散列值&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;从代码开始&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    NSObject *obj = [[NSObject alloc] init];
    id __weak obj1 = obj;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建&lt;code&gt;weak&lt;/code&gt;引用的时候会走到&lt;code&gt;runtime&lt;/code&gt;的&lt;code&gt;objc_initWeak&lt;/code&gt;这个方法里面。通过符号断点可以验证。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;runtime&lt;/code&gt;里的入口&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;id objc_initWeak(id *location, id newObj)
{
    if (!newObj) {
        *location = nil;
        return nil;
    }

    return storeWeak&amp;lt;DontHaveOld, DoHaveNew, DoCrashIfDeallocating&amp;gt;
        (location, (objc_object*)newObj);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到是走到了&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/*
@param `*location`:weak的指针地址
@param `objc_object`:被引用的对象
*/
template &amp;lt;HaveOld haveOld, HaveNew haveNew,
          CrashIfDeallocating crashIfDeallocating&amp;gt; 
storeWeak(id *location, objc_object *newObj)

{
    //校验旧对象和新对象必须存其一
    ASSERT(haveOld  ||  haveNew);
    //校验如果haveNew=true，newObj不能为nil
    if (!haveNew) ASSERT(newObj == nil);

    Class previouslyInitializedClass = nil;
    id oldObj;
    SideTable *oldTable;
    SideTable *newTable;

    // Acquire locks for old and new values.
    // Order by lock address to prevent lock ordering problems. 
    // Retry if the old value changes underneath us.
 retry:
    if (haveOld) {
    //如果weak ptr存在旧值，就取出旧值
        oldObj = *location;
        //以旧对象为析构函数的入参取出旧的SideTable
        oldTable = &amp;amp;SideTables()[oldObj];
    } else {
        oldTable = nil;
    }
    if (haveNew) {
     //如果weak ptr是新值，以新对象为析构函数的入参取出对应的SideTable
        newTable = &amp;amp;SideTables()[newObj];
    } else {
        newTable = nil;
    }
    
    //将oldTable和newTable都上锁
    SideTable::lockTwo&amp;lt;haveOld, haveNew&amp;gt;(oldTable, newTable);
    //校验，如果旧值对不上 goto retry
    if (haveOld  &amp;amp;&amp;amp;  *location != oldObj) {
        SideTable::unlockTwo&amp;lt;haveOld, haveNew&amp;gt;(oldTable, newTable);
        goto retry;
    }

    // Prevent a deadlock between the weak reference machinery
    // and the +initialize machinery by ensuring that no 
    // weakly-referenced object has an un-+initialized isa.
    //保证弱引用对象的isa非空，防止弱引用机制和+initialize 发生死锁
    if (haveNew  &amp;amp;&amp;amp;  newObj) {
        Class cls = newObj-&amp;gt;getIsa();
        if (cls != previouslyInitializedClass  &amp;amp;&amp;amp;  
            !((objc_class *)cls)-&amp;gt;isInitialized()) 
        {
            SideTable::unlockTwo&amp;lt;haveOld, haveNew&amp;gt;(oldTable, newTable);
            //如果class没有初始化发送+initialized消息
            class_initialize(cls, (id)newObj);

            // If this class is finished with +initialize then we&#39;re good.
            // If this class is still running +initialize on this thread 
            // (i.e. +initialize called storeWeak on an instance of itself)
            // then we may proceed but it will appear initializing and 
            // not yet initialized to the check above.
            // Instead set previouslyInitializedClass to recognize it on retry.
            previouslyInitializedClass = cls;
            //到这里class肯定已经初始化了，在走一遍
            goto retry;
        }
    }

    // Clean up old value, if any.
    // 如果weak ptr之前引用了其他对象，在这里清空
    if (haveOld) {
    //&amp;lt;&amp;lt;1&amp;gt;&amp;gt;
        weak_unregister_no_lock(&amp;amp;oldTable-&amp;gt;weak_table, oldObj, location);
    }

    // Assign new value, if any.
    if (haveNew) {
    //通过newObj和location生成一个新的weak_entry_t并插入到newObj的弱引用数组中（weak_entries）
    //&amp;lt;&amp;lt;2&amp;gt;&amp;gt;
        newObj = (objc_object *)
            weak_register_no_lock(&amp;amp;newTable-&amp;gt;weak_table, (id)newObj, location, 
                                  crashIfDeallocating);
        // weak_register_no_lock returns nil if weak store should be rejected

        // Set is-weakly-referenced bit in refcount table.
        if (newObj  &amp;amp;&amp;amp;  !newObj-&amp;gt;isTaggedPointer()) {
           //&amp;lt;&amp;lt;3&amp;gt;&amp;gt; 
           newObj-&amp;gt;setWeaklyReferenced_nolock();
        }

        // Do not set *location anywhere else. That would introduce a race.
        *location = (id)newObj;
    }
    else {
        // No new value. The storage is not changed.
    }
    
    SideTable::unlockTwo&amp;lt;haveOld, haveNew&amp;gt;(oldTable, newTable);

    return (id)newObj;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;获取对象所在的&lt;code&gt;SideTable&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;isa&lt;/code&gt;非空校验，如果&lt;code&gt;isa&lt;/code&gt;没有初始化执行&lt;code&gt;class_initialize(cls, (id)newObj);&lt;/code&gt;方法&lt;/li&gt;
&lt;li&gt;如果地址&lt;code&gt;location&lt;/code&gt;的引用对象已经存在，删除其在&lt;code&gt;weak_table_t&lt;/code&gt;表中的所有引用&lt;/li&gt;
&lt;li&gt;注册新对象的弱引用到&lt;code&gt;weak_table_t&lt;/code&gt;表中&lt;/li&gt;
&lt;li&gt;设置新对象的弱引用标志符为&lt;code&gt;YES&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果对&lt;code&gt;&amp;amp;SideTables()[oldObj]&lt;/code&gt;不太理解的可以先移步&lt;a href=&#34;http://note.youdao.com/s/dIRTiheA&#34;&gt;这篇文章&lt;/a&gt;
&amp;gt;阅读提醒：每一个&amp;lt;&amp;lt;&amp;gt;&amp;gt;中的序号后面都会扩展开讲&lt;/p&gt;

&lt;h4 id=&#34;1-清除老对象的弱引表&#34;&gt;1.清除老对象的弱引表&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;/** 
 * @param weak_table 某个对象的全局weak_table.
 * @param referent 当前对象
 * @param referrer 当前对象的弱引用地址
 */
void
weak_unregister_no_lock(weak_table_t *weak_table, id referent_id, 
                        id *referrer_id)
    objc_object *referent = (objc_object *)referent_id;
    objc_object **referrer = (objc_object **)referrer_id;//二级指针 weak_ptr的地址

    weak_entry_t *entry;

    if (!referent) return;
    //&amp;lt;&amp;lt;1.1&amp;gt;&amp;gt;查找referent对应的weak_entry_t
    if ((entry = weak_entry_for_referent(weak_table, referent))) {
        //&amp;lt;&amp;lt;1.2&amp;gt;&amp;gt;如果entry存在，删除entry
        remove_referrer(entry, referrer);
        bool empty = true;
        //判断entry的动态数组referrers中是否有值
        if (entry-&amp;gt;out_of_line()  &amp;amp;&amp;amp;  entry-&amp;gt;num_refs != 0) {
            empty = false;
        }
        else {
            //判断entry的定长数组inline_referrers中是否有值
            for (size_t i = 0; i &amp;lt; WEAK_INLINE_COUNT; i++) {
                if (entry-&amp;gt;inline_referrers[i]) {
                    empty = false; 
                    break;
                }
            }
        }
        //如果都是空的将entry从weak_table移除
        if (empty) {
            //&amp;lt;&amp;lt;1.3&amp;gt;&amp;gt;
            weak_entry_remove(weak_table, entry);
        }
    }

    // Do not set *referrer = nil. objc_storeWeak() requires that the 
    // value not change.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该方法的主要目的是清除存储在&lt;code&gt;entry&lt;/code&gt;中的&lt;code&gt;weak_referrer_t&lt;/code&gt;，如果发现&lt;code&gt;entry&lt;/code&gt;中一个&lt;code&gt;weak_referrer_t&lt;/code&gt;也没有，就将整个&lt;code&gt;entry&lt;/code&gt;从&lt;code&gt;weak_table&lt;/code&gt;中移除。&lt;/p&gt;

&lt;h5 id=&#34;1-1查找-referent-对应的-entry&#34;&gt;1.1查找&lt;code&gt;referent&lt;/code&gt;对应的&lt;code&gt;entry&lt;/code&gt;&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;* @param weak_table 对象的weak_table 
* @param referent 当前对象
static weak_entry_t *
weak_entry_for_referent(weak_table_t *weak_table, objc_object *referent)
{
    ASSERT(referent);

    weak_entry_t *weak_entries = weak_table-&amp;gt;weak_entries;

    if (!weak_entries) return nil;

    size_t begin = hash_pointer(referent) &amp;amp; weak_table-&amp;gt;mask;
    size_t index = begin;
    size_t hash_displacement = 0;
    while (weak_table-&amp;gt;weak_entries[index].referent != referent) {
        index = (index+1) &amp;amp; weak_table-&amp;gt;mask;
        if (index == begin) bad_weak_table(weak_table-&amp;gt;weak_entries);
        hash_displacement++;
        if (hash_displacement &amp;gt; weak_table-&amp;gt;max_hash_displacement) {
            return nil;
        }
    }
    
    return &amp;amp;weak_table-&amp;gt;weak_entries[index];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;size_t begin = hash_pointer(referent) &amp;amp; weak_table-&amp;gt;mask;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;通过指针的哈希方法生成的值与&lt;code&gt;weak_table-&amp;gt;mask&lt;/code&gt;进行&lt;a href=&#34;https://en.wikipedia.org/wiki/Mask_(computing)&#34;&gt;BITMASK&lt;/a&gt;操作得到一个起始值，这个等下会提一下。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;#if __LP64__
static inline uint32_t ptr_hash(uint64_t key)
{
    key ^= key &amp;gt;&amp;gt; 4;
    key *= 0x8a970be7488fda55;
    key ^= __builtin_bswap64(key);
    return (uint32_t)key;
}
#else
static inline uint32_t ptr_hash(uint32_t key)
{
    key ^= key &amp;gt;&amp;gt; 4;
    key *= 0x5052acdb;
    key ^= __builtin_bswap32(key);
    return key;
}
#endif

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;每次遍历如果没在&lt;code&gt;weak_entries&lt;/code&gt;中找到&lt;code&gt;referent&lt;/code&gt;就对index加1再进行BITMASK操作。遍历一次就认为是哈希冲突一次并记录在遍历&lt;code&gt;hash_displacement&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果哈希冲突超过了最大值返回nil，当前对象在&lt;code&gt;weak_table&lt;/code&gt;中不存在弱引用&lt;/li&gt;
&lt;li&gt;成功找到对应的&lt;code&gt;referent&lt;/code&gt;就返回相应的&lt;code&gt;weak_entry_t&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;简单说一下&lt;strong&gt;BITMASK&lt;/strong&gt;技术:&lt;/br&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;weak&lt;/code&gt;的实现中在对&lt;code&gt;weak_entry_t&lt;/code&gt;和&lt;code&gt;weak_referrer_t&lt;/code&gt;的遍历查找都是通过&lt;code&gt;BITMASK&lt;/code&gt;来实现的。个人猜测先经过一系列运算得到底位是表示数量的二进制数，在进行BITMASK操作。&lt;/p&gt;

&lt;p&gt;在日常开发中用的不多，主要是用于对二进制位进行操作。能快速的得到我们只关心位的值。&lt;/p&gt;

&lt;p&gt;|value|位操作|mask|结果|
|-|:-:|-|:-:|
|0x00000000|&amp;amp;|0x000000011|0|
|0x00000001|&amp;amp;|0x000000011|1|
|0x00000010|&amp;amp;|0x000000011|2|
|0x00000011|&amp;amp;|0x000000011|3|
|0x00000100|&amp;amp;|0x000000011|0|&lt;/p&gt;

&lt;p&gt;可以看到如果我们只关心低两位地址，进行BITMASK就能屏蔽其他位。所以上文中的&lt;code&gt;weak_table-&amp;gt;mask&lt;/code&gt;就是&lt;code&gt;weak_table_t&lt;/code&gt;中&lt;code&gt;weak_entry_t&lt;/code&gt;的最大容量减1（从0开始算）。从&lt;code&gt;static void weak_resize(weak_table_t *weak_table, size_t new_size)&lt;/code&gt;方法中可以看出&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...
weak_table-&amp;gt;mask = new_size - 1;
...
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;理解结构体-weak-entry-t&#34;&gt;理解结构体&lt;code&gt;weak_entry_t&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;在继续下去之前先看下这个结构体，要注意的是它里面有个联合体，联合体里面的两个结构体共享内存。而他们的区别在于，如果弱引用的数量不大于4个就有定长数组&lt;code&gt;inline_referrers&lt;/code&gt;，否则使用动态数组&lt;code&gt;referrers&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct weak_entry_t {
    DisguisedPtr&amp;lt;objc_object&amp;gt; referent;//弱引用对象
    union {//联合体，两种结构体共占有一块内存
        //弱引用数量大于4个用到的结构体
        struct {
            weak_referrer_t *referrers;
            uintptr_t        out_of_line_ness : 2;
            uintptr_t        num_refs : PTR_MINUS_2;
            uintptr_t        mask;
            uintptr_t        max_hash_displacement;
        };
        //弱引用数量不大于4个用到的结构体
        struct {
            // out_of_line_ness field is low bits of inline_referrers[1]
            weak_referrer_t  inline_referrers[WEAK_INLINE_COUNT];
        };
    };
    
    //判断是否是用的referrers来存储弱引用指针
    bool out_of_line() {
        return (out_of_line_ness == REFERRERS_OUT_OF_LINE);
    }
    //覆盖老数据
    weak_entry_t&amp;amp; operator=(const weak_entry_t&amp;amp; other) {
        memcpy(this, &amp;amp;other, sizeof(other));
        return *this;
    }
    //构造方法
    weak_entry_t(objc_object *newReferent, objc_object **newReferrer)
        : referent(newReferent)
    {
        inline_referrers[0] = newReferrer;
        for (int i = 1; i &amp;lt; WEAK_INLINE_COUNT; i++) {
            inline_referrers[i] = nil;
        }
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个里面存放了某个对象的所有弱引用指针，如果弱引用对象数量不超过四个就报错在结构体数组&lt;code&gt;inline_referrers&lt;/code&gt;，否则保存在&lt;code&gt;referrers&lt;/code&gt;&lt;/p&gt;

&lt;h5 id=&#34;1-2删除-entry-中的-referrer&#34;&gt;1.2删除 &lt;code&gt;entry&lt;/code&gt;中的&lt;code&gt;referrer&lt;/code&gt;&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;/** 
 * @param entry 当前对象对应的weak_entry_t
 * @param old_referrer 弱引用指针地址
 */
static void remove_referrer(weak_entry_t *entry, objc_object **old_referrer)
{
    if (! entry-&amp;gt;out_of_line()) {
        for (size_t i = 0; i &amp;lt; WEAK_INLINE_COUNT; i++) {
            if (entry-&amp;gt;inline_referrers[i] == old_referrer) {
                entry-&amp;gt;inline_referrers[i] = nil;
                return;
            }
        }
        _objc_inform(&amp;quot;Attempted to unregister unknown __weak variable &amp;quot;
                     &amp;quot;at %p. This is probably incorrect use of &amp;quot;
                     &amp;quot;objc_storeWeak() and objc_loadWeak(). &amp;quot;
                     &amp;quot;Break on objc_weak_error to debug.\n&amp;quot;, 
                     old_referrer);
        objc_weak_error();
        return;
    }

    size_t begin = w_hash_pointer(old_referrer) &amp;amp; (entry-&amp;gt;mask);
    size_t index = begin;
    size_t hash_displacement = 0;
    while (entry-&amp;gt;referrers[index] != old_referrer) {
        index = (index+1) &amp;amp; entry-&amp;gt;mask;
        if (index == begin) bad_weak_table(entry);
        hash_displacement++;
        if (hash_displacement &amp;gt; entry-&amp;gt;max_hash_displacement) {
            _objc_inform(&amp;quot;Attempted to unregister unknown __weak variable &amp;quot;
                         &amp;quot;at %p. This is probably incorrect use of &amp;quot;
                         &amp;quot;objc_storeWeak() and objc_loadWeak(). &amp;quot;
                         &amp;quot;Break on objc_weak_error to debug.\n&amp;quot;, 
                         old_referrer);
            objc_weak_error();
            return;
        }
    }
    entry-&amp;gt;referrers[index] = nil;
    entry-&amp;gt;num_refs--;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;如果定长数组&lt;code&gt;inline_referrers&lt;/code&gt;中有值且存在弱引用指针&lt;code&gt;old_referrer&lt;/code&gt;，设为nil&lt;/li&gt;
&lt;li&gt;如果动态数组&lt;code&gt;referrers&lt;/code&gt;中有值且存在弱引用指针&lt;code&gt;old_referrer&lt;/code&gt;，设为nil,并将引用数量-1&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;1-3-如果有必要删除对象的整个弱引用表&#34;&gt;1.3 如果有必要删除对象的整个弱引用表&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;**
 * Remove entry from the zone&#39;s table of weak references.
 */
static void weak_entry_remove(weak_table_t *weak_table, weak_entry_t *entry)
{
    // remove entry
    if (entry-&amp;gt;out_of_line()) free(entry-&amp;gt;referrers);
    bzero(entry, sizeof(*entry));

    weak_table-&amp;gt;num_entries--;

    weak_compact_maybe(weak_table);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;如果使用的是动态数组，释放动态数组的内存&lt;/li&gt;
&lt;li&gt;以&lt;code&gt;entry&lt;/code&gt;为起始地址的前&lt;code&gt;sizeof(*entry)&lt;/code&gt;个字节区域清零&lt;/li&gt;
&lt;li&gt;全局&lt;code&gt;weak_table&lt;/code&gt;中，弱引用对象数量-1&lt;/li&gt;

&lt;li&gt;&lt;p&gt;收缩表大小&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Shrink the table if it is mostly empty.
static void weak_compact_maybe(weak_table_t *weak_table)
{
size_t old_size = TABLE_SIZE(weak_table);

// Shrink if larger than 1024 buckets and at most 1/16 full.
if (old_size &amp;gt;= 1024  &amp;amp;&amp;amp; old_size / 16 &amp;gt;= weak_table-&amp;gt;num_entries) {
    weak_resize(weak_table, old_size / 8);
    // leaves new table no more than 1/2 full
}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果&lt;code&gt;weak_table&lt;/code&gt;内存占用超过&lt;strong&gt;1024&lt;/strong&gt;字节且内存的1/16比弱引用对象的数量还多就收缩表大小，使其不大于原来的&lt;strong&gt;&lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2&lt;/sub&gt;&lt;/strong&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Weak的实现（三）</title>
      <link>https://linkrober.github.io/bookshelf/2020/12/weak%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%89/</link>
      <pubDate>Tue, 08 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linkrober.github.io/bookshelf/2020/12/weak%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%89/</guid>
      <description>&lt;p&gt;本文较长分三篇按序阅读体验更佳，第四篇为辅助阅读按需看&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://linkrober.github.io/bookshelf/2020/12/weak%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%80/&#34;&gt;Weak的实现（一）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://linkrober.github.io/bookshelf/2020/12/weak%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%BA%8C/&#34;&gt;Weak的实现（二）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://linkrober.github.io/bookshelf/2020/12/weak%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%89/&#34;&gt;Weak的实现（三）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://linkrober.github.io/bookshelf/2020/12/weak%E7%9A%84%E5%AE%9E%E7%8E%B0-sidetablesoldobj/&#34;&gt;Weak的实现-&amp;amp;SideTables()[oldObj]&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&#34;正文-接-weak的实现-二&#34;&gt;正文 接 Weak的实现（二）&lt;/h5&gt;

&lt;h4 id=&#34;3-设置弱引用标志位&#34;&gt;3 设置弱引用标志位&lt;/h4&gt;

&lt;p&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;inline void
objc_object::setWeaklyReferenced_nolock()
{
 retry:
    //去对象的isa指针
    isa_t oldisa = LoadExclusive(&amp;amp;isa.bits);
    isa_t newisa = oldisa;
    //如果不是non-pointer
    if (slowpath(!newisa.nonpointer)) {
        ClearExclusive(&amp;amp;isa.bits);
        //&amp;lt;&amp;lt;3.1&amp;gt;&amp;gt;
        sidetable_setWeaklyReferenced_nolock();
        return;
    }
    if (newisa.weakly_referenced) {
        ClearExclusive(&amp;amp;isa.bits);
        return;
    }
    //弱引用标志位设为1
    newisa.weakly_referenced = true;
    //如果oldisa.bits和newisa.bits不相等返回NO，继续tery里面的内容，这时候newisa.weakly_referenced已经是true了，所以return
    if (!StoreExclusive(&amp;amp;isa.bits, oldisa.bits, newisa.bits)) goto retry;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;设置nonpointer类型的isa和非nonpointer类型的isa的弱引用位为1&lt;/p&gt;

&lt;h5 id=&#34;3-1-设置nonpointer的isa指针的弱引用标志位&#34;&gt;3.1 设置nonpointer的isa指针的弱引用标志位&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;void 
objc_object::sidetable_setWeaklyReferenced_nolock()
{
#if SUPPORT_NONPOINTER_ISA
    ASSERT(!isa.nonpointer);
#endif

    SideTable&amp;amp; table = SideTables()[this];
    table.refcnts[this] |= SIDE_TABLE_WEAKLY_REFERENCED;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;RefcountMap&lt;/code&gt;，也是哈希表&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typedef objc::DenseMap&amp;lt;DisguisedPtr&amp;lt;objc_object&amp;gt;,size_t,RefcountMapValuePurgeable&amp;gt; RefcountMap;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;key是&lt;code&gt;DisguisedPtr&amp;lt;objc_object&amp;gt;&lt;/code&gt;即&lt;code&gt;weak_referrer_t&lt;/code&gt;，弱引用对象，value是&lt;code&gt;size_t&lt;/code&gt;，弱引用数量&lt;/p&gt;

&lt;p&gt;这里将&lt;code&gt;table.refcnts[this]&lt;/code&gt;即最后一位与SIDE_TABLE_WEAKLY_REFERENCED进行位或操作，这时候弱引用标志位变成&lt;strong&gt;1&lt;/strong&gt;。&lt;/p&gt;

&lt;h4 id=&#34;答题&#34;&gt;答题&lt;/h4&gt;

&lt;p&gt;问题1、2、3、5我们放在一起回答&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;大家都知道weak的底层实现是一个散列表，那么散列表的结构是什么样的？&lt;/li&gt;
&lt;li&gt;散列表的key是什么，value是什么，散列函数是怎样的？&lt;/li&gt;
&lt;li&gt;通过几次查找才能找到对应的弱引用？&lt;/li&gt;
&lt;li&gt;一个对象对应一个&lt;code&gt;SideTable&lt;/code&gt;表而一个&lt;code&gt;SideTable&lt;/code&gt;对应多个对象，为什么这样设计&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;大概的讲是一个散列表&lt;code&gt;SideTablesMap&lt;/code&gt;，以对象为&lt;code&gt;key&lt;/code&gt;,&lt;code&gt;SideTable&lt;/code&gt;为&lt;code&gt;value&lt;/code&gt;。散列函数是&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static unsigned int indexForPointer(const void *p) {
        uintptr_t addr = reinterpret_cast&amp;lt;uintptr_t&amp;gt;(p);
        return ((addr &amp;gt;&amp;gt; 4) ^ (addr &amp;gt;&amp;gt; 9)) % StripeCount;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但这只是开始，它取到的是很多对象弱引用表的集合。要想准确的找到某个对象的弱引位置用还要经过两步。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;以对象为key，经过一系列运算（位运算，算数运算），最后通过BITMASK找到&lt;code&gt;weak_entries&lt;/code&gt;的入口&lt;code&gt;index&lt;/code&gt;开始变量，判断对象是否相等。最后才能找到对象所在的&lt;code&gt;weak_entry_t&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;因为&lt;code&gt;weak_entry_t&lt;/code&gt;这里面保存了对象的所有有弱引用，要找到指定的，还要经历和上述类似的操作对比&lt;code&gt;old_referrer&lt;/code&gt;才能找到正真的弱引用&lt;code&gt;weak_referrer_t&lt;/code&gt;位置。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以经过3次查找才能找到正真的弱引用。&lt;/p&gt;

&lt;p&gt;为什么苹果要创建64个&lt;code&gt;SideTable&lt;/code&gt;（在iphone上是8个，其他上面是64个），而不是用一个SideTable解决呢。简单的类比，大家都在火车站或者飞机场打过出租车吧，当你前面的队伍黑压压的一片看不到头你是不是希望多开几个出租车上车点。使用多个&lt;code&gt;SideTable&lt;/code&gt;也是这个原理提高弱引用的索引速度。&lt;/p&gt;

&lt;p&gt;还有一点，我想提下，在整个过程中有两次扩容，一次收缩容量。它们都是动态的。分别是在
- &lt;code&gt;weak_unregister_no_lock&lt;/code&gt;的时候，收缩&lt;code&gt;weak_table_t&lt;/code&gt;的容量&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Shrink the table if it is mostly empty.
static void weak_compact_maybe(weak_table_t *weak_table)
{
    size_t old_size = TABLE_SIZE(weak_table);

    // Shrink if larger than 1024 buckets and at most 1/16 full.
    if (old_size &amp;gt;= 1024  &amp;amp;&amp;amp; old_size / 16 &amp;gt;= weak_table-&amp;gt;num_entries) {
        weak_resize(weak_table, old_size / 8);
        // leaves new table no more than 1/2 full
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;append_referrer&lt;/code&gt;的时候增加&lt;code&gt;weak_entry_t&lt;/code&gt;中动态数组&lt;code&gt;*referrers&lt;/code&gt;的容量&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;__attribute__((noinline, used))
static void grow_refs_and_insert(weak_entry_t *entry, 
                             objc_object **new_referrer)
{
ASSERT(entry-&amp;gt;out_of_line());

size_t old_size = TABLE_SIZE(entry);
size_t new_size = old_size ? old_size * 2 : 8;

size_t num_refs = entry-&amp;gt;num_refs;
weak_referrer_t *old_refs = entry-&amp;gt;referrers;
entry-&amp;gt;mask = new_size - 1;
    
entry-&amp;gt;referrers = (weak_referrer_t *)
    calloc(TABLE_SIZE(entry), sizeof(weak_referrer_t));
entry-&amp;gt;num_refs = 0;
entry-&amp;gt;max_hash_displacement = 0;
    
for (size_t i = 0; i &amp;lt; old_size &amp;amp;&amp;amp; num_refs &amp;gt; 0; i++) {
    if (old_refs[i] != nil) {
        append_referrer(entry, old_refs[i]);
        num_refs--;
    }
}
// Insert
append_referrer(entry, new_referrer);
if (old_refs) free(old_refs);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;weak_grow_maybe&lt;/code&gt;的时候,增加&lt;code&gt;weak_table_t&lt;/code&gt;的容量&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static void weak_grow_maybe(weak_table_t *weak_table)
{
size_t old_size = TABLE_SIZE(weak_table);

// Grow if at least 3/4 full.
if (weak_table-&amp;gt;num_entries &amp;gt;= old_size * 3 / 4) {
    weak_resize(weak_table, old_size ? old_size*2 : 64);
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;问题4&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;如何查找弱引用对象的引用计数？&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;uintptr_t
_objc_rootRetainCount(id obj)
{
    ASSERT(obj);

    return obj-&amp;gt;rootRetainCount();
}

inline uintptr_t 
objc_object::rootRetainCount()
{
    if (isTaggedPointer()) return (uintptr_t)this;

    sidetable_lock();
    //获取isa的比特位
    isa_t bits = LoadExclusive(&amp;amp;isa.bits);
    ClearExclusive(&amp;amp;isa.bits);
    //是不是non-pointer
    if (bits.nonpointer) {
        //引用比特位上的引用数加1
        uintptr_t rc = 1 + bits.extra_rc;
        if (bits.has_sidetable_rc) {
            //判断sidetable是否存在引用计数，如果存在继续相加
            rc += sidetable_getExtraRC_nolock();
        }
        sidetable_unlock();
        return rc;
    }

    sidetable_unlock();
    return sidetable_retainCount();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从&lt;code&gt;rootRetainCount&lt;/code&gt;源码可以看出，弱引用的引用计数分布在两个地方，一个是&lt;code&gt;isa&lt;/code&gt;的比特位中，还有一个在&lt;code&gt;SideTable&lt;/code&gt;中。它们相加才是对象的引用计数的数量。&lt;/p&gt;

&lt;p&gt;最后祭上Weak的类图和四层存储结构图，结构图中有获取对应层级所用到的算法
&lt;img src=&#34;https://note.youdao.com/yws/api/personal/file/WEBe05b83f81e4040473f0385979441c881?method=download&amp;amp;shareKey=028270cc018dcad1590865e61eb2624c&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;https://note.youdao.com/yws/api/personal/file/WEB97fdb40aae006524c1682b57022200cd?method=download&amp;amp;shareKey=ec82da0a1b701817110cc4a24494437a&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.jianshu.com/p/ef6d9bf8fe59&#34;&gt;iOS管理对象内存的数据结构以及操作算法&amp;ndash;SideTables、RefcountMap、weak_table_t-一
&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.leewong.cn/2020/08/16/sidetablestructure/&#34;&gt;SideTable结构
&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Weak的实现（二）</title>
      <link>https://linkrober.github.io/bookshelf/2020/12/weak%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%BA%8C/</link>
      <pubDate>Tue, 08 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linkrober.github.io/bookshelf/2020/12/weak%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%BA%8C/</guid>
      <description>&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://linkrober.github.io/bookshelf/2020/12/weak%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%80/&#34;&gt;Weak的实现（一）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://linkrober.github.io/bookshelf/2020/12/weak%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%BA%8C/&#34;&gt;Weak的实现（二）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://linkrober.github.io/bookshelf/2020/12/weak%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%89/&#34;&gt;Weak的实现（三）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://linkrober.github.io/bookshelf/2020/12/weak%E7%9A%84%E5%AE%9E%E7%8E%B0-sidetablesoldobj/&#34;&gt;Weak的实现-&amp;amp;SideTables()[oldObj]&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&#34;正文-接-weak的实现-一&#34;&gt;正文 接 Weak的实现（一）&lt;/h5&gt;

&lt;h4 id=&#34;2-生成新的-weak-entry-t-插入到-weak-entries-中&#34;&gt;2 生成新的&lt;code&gt;weak_entry_t&lt;/code&gt;插入到&lt;code&gt;weak_entries&lt;/code&gt;中&lt;/h4&gt;

&lt;p&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/** 
 * Registers a new (object, weak pointer) pair. Creates a new weak
 * object entry if it does not exist.
 * 
 * @param weak_table The global weak table.弱引用全局表
 * @param referent The object pointed to by the weak reference. 弱引用对象
 * @param referrer The weak pointer address. 弱引用指针地址
 */
id 
weak_register_no_lock(weak_table_t *weak_table, id referent_id, 
                      id *referrer_id, bool crashIfDeallocating)
{
    objc_object *referent = (objc_object *)referent_id;
    objc_object **referrer = (objc_object **)referrer_id;

    if (!referent  ||  referent-&amp;gt;isTaggedPointer()) return referent_id;

    // ensure that the referenced object is viable
    // 判断对象是否正在释放或者是否支持弱引用
    bool deallocating;
    if (!referent-&amp;gt;ISA()-&amp;gt;hasCustomRR()) {
        deallocating = referent-&amp;gt;rootIsDeallocating();
    }
    else {
        BOOL (*allowsWeakReference)(objc_object *, SEL) = 
            (BOOL(*)(objc_object *, SEL))
            object_getMethodImplementation((id)referent, 
                                           @selector(allowsWeakReference));
        if ((IMP)allowsWeakReference == _objc_msgForward) {
            return nil;
        }
        deallocating =
            ! (*allowsWeakReference)(referent, @selector(allowsWeakReference));
    }

    if (deallocating) {
        if (crashIfDeallocating) {
            _objc_fatal(&amp;quot;Cannot form weak reference to instance (%p) of &amp;quot;
                        &amp;quot;class %s. It is possible that this object was &amp;quot;
                        &amp;quot;over-released, or is in the process of deallocation.&amp;quot;,
                        (void*)referent, object_getClassName((id)referent));
        } else {
            return nil;
        }
    }

    // now remember it and where it is being stored
    // 如果对象已经在weak_table中存在弱引用记录，就原来的entry上面追加
    weak_entry_t *entry;
    //&amp;lt;&amp;lt;1.1&amp;gt;&amp;gt;
    if ((entry = weak_entry_for_referent(weak_table, referent))) {
    //&amp;lt;&amp;lt;2.1&amp;gt;&amp;gt;
        append_referrer(entry, referrer);
    } 
    else {
        //创建新的entry，添加到weak_table中
        //&amp;lt;&amp;lt;2.2&amp;gt;&amp;gt;
        weak_entry_t new_entry(referent, referrer);
        //&amp;lt;&amp;lt;2.3&amp;gt;&amp;gt;
        weak_grow_maybe(weak_table);
        //&amp;lt;&amp;lt;2.4&amp;gt;&amp;gt;
        weak_entry_insert(weak_table, &amp;amp;new_entry);
    }

    // Do not set *referrer. objc_storeWeak() requires that the 
    // value not change.

    return referent_id;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;2-1-在-weak-entry-t-添加新的弱引用-weak-referrer-t&#34;&gt;2.1 在&lt;code&gt;weak_entry_t&lt;/code&gt;添加新的弱引用&lt;code&gt;weak_referrer_t&lt;/code&gt;&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;/** 
 * Add the given referrer to set of weak pointers in this entry.
 * Does not perform duplicate checking (b/c weak pointers are never
 * added to a set twice). 
 *
 * @param entry The entry holding the set of weak pointers. 某个类的弱引用表
 * @param new_referrer The new weak pointer to be added.新的弱引用
 */
static void append_referrer(weak_entry_t *entry, objc_object **new_referrer)
{
    //如果inline_referrers中还能存放weak_referrer_t就放在inline_referrers里面
    if (! entry-&amp;gt;out_of_line()) {
        // Try to insert inline.
        for (size_t i = 0; i &amp;lt; WEAK_INLINE_COUNT; i++) {
            if (entry-&amp;gt;inline_referrers[i] == nil) {
                entry-&amp;gt;inline_referrers[i] = new_referrer;
                return;
            }
        }

        // Couldn&#39;t insert inline. Allocate out of line.
        // 如果放不下了，就创建把所有的weak_referrer_t挪到referrers中
        weak_referrer_t *new_referrers = (weak_referrer_t *)
            calloc(WEAK_INLINE_COUNT, sizeof(weak_referrer_t));
        // This constructed table is invalid, but grow_refs_and_insert
        // will fix it and rehash it.
        for (size_t i = 0; i &amp;lt; WEAK_INLINE_COUNT; i++) {
            new_referrers[i] = entry-&amp;gt;inline_referrers[i];
        }
        entry-&amp;gt;referrers = new_referrers;
        entry-&amp;gt;num_refs = WEAK_INLINE_COUNT;
        entry-&amp;gt;out_of_line_ness = REFERRERS_OUT_OF_LINE;
        entry-&amp;gt;mask = WEAK_INLINE_COUNT-1;
        entry-&amp;gt;max_hash_displacement = 0;
    }

    ASSERT(entry-&amp;gt;out_of_line());
    // 如果引用数量超过表内存的3/4就自动扩容
    if (entry-&amp;gt;num_refs &amp;gt;= TABLE_SIZE(entry) * 3/4) {
        //&amp;lt;&amp;lt;2.1.1&amp;gt;&amp;gt;
        return grow_refs_and_insert(entry, new_referrer);
    }
    //在referrers中找到一个值为nil的weak_referrer_t对象，用新的弱引用对其赋值，并自增数量
    size_t begin = w_hash_pointer(new_referrer) &amp;amp; (entry-&amp;gt;mask);
    size_t index = begin;
    size_t hash_displacement = 0;
    while (entry-&amp;gt;referrers[index] != nil) {
        hash_displacement++;
        index = (index+1) &amp;amp; entry-&amp;gt;mask;
        if (index == begin) bad_weak_table(entry);
    }
    if (hash_displacement &amp;gt; entry-&amp;gt;max_hash_displacement) {
        entry-&amp;gt;max_hash_displacement = hash_displacement;
    }
    weak_referrer_t &amp;amp;ref = entry-&amp;gt;referrers[index];
    ref = new_referrer;
    entry-&amp;gt;num_refs++;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果&lt;code&gt;weak_table_t&lt;/code&gt;中存在当前对象的弱引用记录&lt;code&gt;weak_entry_t&lt;/code&gt;，使用该方法在&lt;code&gt;weak_entry_t&lt;/code&gt;添加新的&lt;code&gt;weak_referrer_t&lt;/code&gt;。
- 如果&lt;code&gt;weak_entry_t&lt;/code&gt;中的&lt;code&gt;weak_referrer_t&lt;/code&gt;数量不超过4个，即&lt;code&gt;weak_referrer_t&lt;/code&gt;用还保存在&lt;code&gt;inline_referrers&lt;/code&gt;中，就将其添加到&lt;code&gt;inline_referrers&lt;/code&gt;中；
- 如果刚好满4个，就将所有的&lt;code&gt;weak_referrer_t&lt;/code&gt;从定长数组&lt;code&gt;inline_referrers&lt;/code&gt;中取出，开辟新的空间，存储到动态数组&lt;code&gt;referrers&lt;/code&gt;中来记录引用
- 如果&lt;code&gt;weak_referrer_t&lt;/code&gt;的数量大于表内存大小的3/4，自动扩容&amp;lt;&lt;2.2.1&gt;&amp;gt;
- 在&lt;code&gt;referrers&lt;/code&gt;找到第一个为nil的&lt;code&gt;weak_referrer_t&lt;/code&gt;指针，新的&lt;code&gt;weak_referrer_t&lt;/code&gt;赋值给它，引用计数自增。&lt;/p&gt;

&lt;h5 id=&#34;2-1-1-增加某个对象弱引用表的容量&#34;&gt;2.1.1 增加某个对象弱引用表的容量&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;/** 
 * Grow the entry&#39;s hash table of referrers. Rehashes each
 * of the referrers.
 * 
 * @param entry Weak pointer hash set for a particular object.某个对象的弱引用表
 */
__attribute__((noinline, used))
static void grow_refs_and_insert(weak_entry_t *entry, 
                                 objc_object **new_referrer)
{
    ASSERT(entry-&amp;gt;out_of_line());
    //原来表大小
    size_t old_size = TABLE_SIZE(entry);
    //新表大小，old_size大于0，新size就变成原来大小的两倍，否则就8个字节大小
    size_t new_size = old_size ? old_size * 2 : 8;

    //原来的弱引用数量
    size_t num_refs = entry-&amp;gt;num_refs;
    //原来的弱引用数组
    weak_referrer_t *old_refs = entry-&amp;gt;referrers;
    //新的mask
    entry-&amp;gt;mask = new_size - 1;
    
    //重新分配entry的内存
    entry-&amp;gt;referrers = (weak_referrer_t *)
        calloc(TABLE_SIZE(entry), sizeof(weak_referrer_t));
    entry-&amp;gt;num_refs = 0;
    entry-&amp;gt;max_hash_displacement = 0;
    
    //先将老的引用全部插入到新的数组里面
    for (size_t i = 0; i &amp;lt; old_size &amp;amp;&amp;amp; num_refs &amp;gt; 0; i++) {
        if (old_refs[i] != nil) {
            //递归调用 插入weak_referrer_t
            append_referrer(entry, old_refs[i]);
            num_refs--;
        }
    }
    // Insert
    // 最后插入新加入的弱引用
    append_referrer(entry, new_referrer);
    if (old_refs) free(old_refs);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此方法重新定义了对象弱引用表&lt;code&gt;weak_entry_t&lt;/code&gt;的大小
1. 原来的表大小等于0，就分配8个字节
2. 如果原来表大小大于0，就分配原来大小2倍的字节
3. 然后为&lt;code&gt;referrers&lt;/code&gt;重新分配内存，先将老的&lt;code&gt;weak_entry_t&lt;/code&gt;迁移过去，再插入新的&lt;code&gt;weak_entry_t&lt;/code&gt;。通过递归调用&lt;code&gt;append_referrer&lt;/code&gt;实现插入数据&lt;/p&gt;

&lt;h5 id=&#34;2-2-创建新的-weak-entry-t&#34;&gt;2.2 创建新的&lt;code&gt;weak_entry_t&lt;/code&gt;&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;    weak_entry_t(objc_object *newReferent, objc_object **newReferrer)
        : referent(newReferent)
    {
        inline_referrers[0] = newReferrer;
        for (int i = 1; i &amp;lt; WEAK_INLINE_COUNT; i++) {
            inline_referrers[i] = nil;
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果对象还没有弱引用表&lt;code&gt;weak_entry_t&lt;/code&gt;就该对象建一个新的，从源码可看出&lt;code&gt;newReferrer&lt;/code&gt;先保存在&lt;code&gt;inline_referrers&lt;/code&gt;中&lt;/p&gt;

&lt;h5 id=&#34;2-3-weak-table-t-的扩容&#34;&gt;2.3 &lt;code&gt;weak_table_t&lt;/code&gt;的扩容&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;// Grow the given zone&#39;s table of weak references if it is full.
static void weak_grow_maybe(weak_table_t *weak_table)
{
    size_t old_size = TABLE_SIZE(weak_table);

    // Grow if at least 3/4 full.
    if (weak_table-&amp;gt;num_entries &amp;gt;= old_size * 3 / 4) {
        //&amp;lt;&amp;lt;2.3.1&amp;gt;&amp;gt;
        weak_resize(weak_table, old_size ? old_size*2 : 64);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果&lt;code&gt;weak_table&lt;/code&gt;中&lt;code&gt;num_entries&lt;/code&gt;数组的数量大于其内存大小的3/4就开始为&lt;code&gt;weak_table&lt;/code&gt;扩容
 - oldsize大于0，扩容为原来大小的两倍
 - 否则分配64字节&lt;/p&gt;

&lt;h5 id=&#34;2-3-1-weak-resize&#34;&gt;2.3.1 weak_resize&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;static void weak_resize(weak_table_t *weak_table, size_t new_size)
{
    size_t old_size = TABLE_SIZE(weak_table);

    weak_entry_t *old_entries = weak_table-&amp;gt;weak_entries;
    weak_entry_t *new_entries = (weak_entry_t *)
        calloc(new_size, sizeof(weak_entry_t));

    weak_table-&amp;gt;mask = new_size - 1;
    weak_table-&amp;gt;weak_entries = new_entries;
    weak_table-&amp;gt;max_hash_displacement = 0;
    weak_table-&amp;gt;num_entries = 0;  // restored by weak_entry_insert below
    
    if (old_entries) {
        weak_entry_t *entry;
        weak_entry_t *end = old_entries + old_size;
        for (entry = old_entries; entry &amp;lt; end; entry++) {
            if (entry-&amp;gt;referent) {
                //&amp;lt;&amp;lt;2.3.1.1&amp;gt;&amp;gt;
                weak_entry_insert(weak_table, entry);
            }
        }
        free(old_entries);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;创建新的指针数组&lt;code&gt;new_entries&lt;/code&gt;，分配新的大小&lt;/li&gt;
&lt;li&gt;遍历将老的数据迁移到新的数组中&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;2-3-1-1-向-weak-table-t-中插入-weak-entry-t&#34;&gt;2.3.1.1 向&lt;code&gt;weak_table_t&lt;/code&gt;中插入&lt;code&gt;weak_entry_t&lt;/code&gt;&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;/** 
 * Add new_entry to the object&#39;s table of weak references.
 * Does not check whether the referent is already in the table.
 */
static void weak_entry_insert(weak_table_t *weak_table, weak_entry_t *new_entry)
{
    weak_entry_t *weak_entries = weak_table-&amp;gt;weak_entries;
    ASSERT(weak_entries != nil);

    size_t begin = hash_pointer(new_entry-&amp;gt;referent) &amp;amp; (weak_table-&amp;gt;mask);
    size_t index = begin;
    size_t hash_displacement = 0;
    while (weak_entries[index].referent != nil) {
        index = (index+1) &amp;amp; weak_table-&amp;gt;mask;
        if (index == begin) bad_weak_table(weak_entries);
        hash_displacement++;
    }

    weak_entries[index] = *new_entry;
    weak_table-&amp;gt;num_entries++;

    if (hash_displacement &amp;gt; weak_table-&amp;gt;max_hash_displacement) {
        weak_table-&amp;gt;max_hash_displacement = hash_displacement;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还是通过BITMASK来遍历所有的&lt;code&gt;weak_entry_t&lt;/code&gt;，直到有一个&lt;code&gt;referent&lt;/code&gt;为nil,就将新的&lt;code&gt;weak_entry_t&lt;/code&gt;赋值给它。&lt;/p&gt;

&lt;h5 id=&#34;2-4-将对象的新-weak-entry-t-插入到-weak-table-t-中&#34;&gt;2.4 将对象的新&lt;code&gt;weak_entry_t&lt;/code&gt;插入到&lt;code&gt;weak_table_t&lt;/code&gt;中&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;/** 
 * Add new_entry to the object&#39;s table of weak references.
 * Does not check whether the referent is already in the table.
 */
static void weak_entry_insert(weak_table_t *weak_table, weak_entry_t *new_entry)
{
    weak_entry_t *weak_entries = weak_table-&amp;gt;weak_entries;
    ASSERT(weak_entries != nil);
    //遍历weak_entries，直到weak_entries[index].referent为nil
    size_t begin = hash_pointer(new_entry-&amp;gt;referent) &amp;amp; (weak_table-&amp;gt;mask);
    size_t index = begin;
    size_t hash_displacement = 0;
    while (weak_entries[index].referent != nil) {
        index = (index+1) &amp;amp; weak_table-&amp;gt;mask;
        if (index == begin) bad_weak_table(weak_entries);
        hash_displacement++;
    }
    //将新的数据赋值给referent为nil的指针
    weak_entries[index] = *new_entry;
    //weak_entry_t数量+1
    weak_table-&amp;gt;num_entries++;
    //更新max_hash_displacement
    if (hash_displacement &amp;gt; weak_table-&amp;gt;max_hash_displacement) {
        weak_table-&amp;gt;max_hash_displacement = hash_displacement;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;遍历&lt;code&gt;weak_table_t&lt;/code&gt;中的&lt;code&gt;weak_entries&lt;/code&gt;，直到有一个&lt;code&gt;weak_entry_t&lt;/code&gt;的为&lt;code&gt;referent&lt;/code&gt;为&lt;code&gt;nil&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;将新的&lt;code&gt;weak_entry_t&lt;/code&gt;赋值给&lt;code&gt;referent&lt;/code&gt;为&lt;code&gt;nil&lt;/code&gt;的&lt;code&gt;weak_entry_t&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;更新&lt;code&gt;num_entries&lt;/code&gt;和&lt;code&gt;max_hash_displacement&lt;/code&gt;的数量&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
  </channel>
</rss>