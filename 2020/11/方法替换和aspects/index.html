

  
    
  


  





  

<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Hugo 0.17 with theme Tranquilpeak 0.4.1-BETA">
    <title>方法替换和Aspects</title>
    <meta name="author" content="董二千">
    <meta name="keywords" content="">

    <link rel="icon" href="https://LinkRober.github.io/bookshelf/favicon.png">
    

    
    <meta name="description" content="带着问题看文章：

1.常规姿势的方法替换原理是什么

2.Aspects的方法替换原理是什么

3.为什么这样下面的代码这样hook之后，所有的实例的viewWillAppear:也被hook了

[[UIViewController class] aspect_hookSelector:@selector(viewWillAppear:) withOptions:AspectPositionBefore usingBlock:^(){
        
} error:nil];


4.为什么Aspect不能hook静态方法

5.如果用先用Aspects hook了方法A，接着又用MethodSwizzle方法（下文有）对A进行了hook，两个hook都能执行吗？
">
    <meta property="og:description" content="带着问题看文章：

1.常规姿势的方法替换原理是什么

2.Aspects的方法替换原理是什么

3.为什么这样下面的代码这样hook之后，所有的实例的viewWillAppear:也被hook了

[[UIViewController class] aspect_hookSelector:@selector(viewWillAppear:) withOptions:AspectPositionBefore usingBlock:^(){
        
} error:nil];


4.为什么Aspect不能hook静态方法

5.如果用先用Aspects hook了方法A，接着又用MethodSwizzle方法（下文有）对A进行了hook，两个hook都能执行吗？
">
    <meta property="og:type" content="blog">
    <meta property="og:title" content="方法替换和Aspects">
    <meta property="og:url" content="/2020/11/%E6%96%B9%E6%B3%95%E6%9B%BF%E6%8D%A2%E5%92%8Caspects/">
    <meta property="og:site_name" content="董二千">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="董二千">
    <meta name="twitter:description" content="带着问题看文章：

1.常规姿势的方法替换原理是什么

2.Aspects的方法替换原理是什么

3.为什么这样下面的代码这样hook之后，所有的实例的viewWillAppear:也被hook了

[[UIViewController class] aspect_hookSelector:@selector(viewWillAppear:) withOptions:AspectPositionBefore usingBlock:^(){
        
} error:nil];


4.为什么Aspect不能hook静态方法

5.如果用先用Aspects hook了方法A，接着又用MethodSwizzle方法（下文有）对A进行了hook，两个hook都能执行吗？
">
    
    

    
    

    
      <meta property="og:image" content="https://avatars1.githubusercontent.com/u/7357189?v=3&s=460.png">
    

    
    
    

    

    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha256-eZrrJcwDc/3uDhsdt61sL2oOBY362qM3lon1gyExkL0=" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/jquery.fancybox.min.css" integrity="sha256-vuXZ9LGmmwtjqFX1F+EKin1ThZMub58gKULUyf0qECk=" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/helpers/jquery.fancybox-thumbs.min.css" integrity="sha256-SEa4XYAHihTcEP1f5gARTB2K26Uk8PsndQYHQC1f4jU=" crossorigin="anonymous" />
    
    
    <link rel="stylesheet" href="https://LinkRober.github.io/bookshelf/css/style-fpbzgxsy0kgmdvyrj5ykkg6ratccrk3gocmaqn4xpcjywmv5dteilzucro4f.min.css" />
    
    

    
      
    
    
  </head>

  <body>
    <div id="blog">
      <header id="header" data-behavior="4">
  <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
  <div class="header-title">
    <a class="header-title-link" href="https://LinkRober.github.io/bookshelf/">董二千</a>
  </div>
  
    
      <a class="header-right-picture "
         href="https://LinkRober.github.io/bookshelf/#about">
    
    
    
      
        <img class="header-picture" src="https://avatars1.githubusercontent.com/u/7357189?v=3&amp;s=460.png" alt="作者的图片" />
      
    
    </a>
  
</header>

      <nav id="sidebar" data-behavior="4">
  <div class="sidebar-container">
    
      <div class="sidebar-profile">
        <a href="https://LinkRober.github.io/bookshelf/#about">
          <img class="sidebar-profile-picture" src="https://avatars1.githubusercontent.com/u/7357189?v=3&amp;s=460.png" alt="作者的图片" />
        </a>
        <h4 class="sidebar-profile-name">董二千</h4>
        
          <h5 class="sidebar-profile-bio">愿你走出半生 归来仍是少年</h5>
        
      </div>
    
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://LinkRober.github.io/bookshelf/categories">
    
      <i class="sidebar-button-icon fa fa-lg fa-bookmark"></i>
      
      <span class="sidebar-button-desc">分类</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://LinkRober.github.io/bookshelf/">
    
      <i class="sidebar-button-icon fa fa-lg fa-home"></i>
      
      <span class="sidebar-button-desc">首页</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://LinkRober.github.io/bookshelf/tags">
    
      <i class="sidebar-button-icon fa fa-lg fa-tags"></i>
      
      <span class="sidebar-button-desc">标签</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://LinkRober.github.io/bookshelf/#about">
    
      <i class="sidebar-button-icon fa fa-lg fa-question"></i>
      
      <span class="sidebar-button-desc">关于</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://LinkRober.github.io/bookshelf/archives">
    
      <i class="sidebar-button-icon fa fa-lg fa-archive"></i>
      
      <span class="sidebar-button-desc">归档</span>
    </a>
  </li>


    </ul>
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://github.com/LinkRober" target="_blank" rel="noopener">
    
      <i class="sidebar-button-icon fa fa-lg fa-github"></i>
      
      <span class="sidebar-button-desc">GitHub</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://stackoverflow.com/users/4878280/buer" target="_blank" rel="noopener">
    
      <i class="sidebar-button-icon fa fa-lg fa-stack-overflow"></i>
      
      <span class="sidebar-button-desc">Stack Overflow</span>
    </a>
  </li>


    </ul>
    <ul class="sidebar-buttons">
      

    </ul>
  </div>
</nav>

      

      <div id="main" data-behavior="4"
        class="
               hasCoverMetaIn
               ">
        <article class="post" itemscope itemType="http://schema.org/BlogPosting">
          
          
            <div class="post-header main-content-wrap text-left">
  
    <h1 class="post-title" itemprop="headline">
      方法替换和Aspects
    </h1>
  
  
  <div class="postShorten-meta post-meta">
    
      <time itemprop="datePublished" datetime="2020-11-26T00:00:00Z">
        
  十一月 26, 2020

      </time>
    
    
  
  
    <span>发布在</span>
    
      <a class="category-link" href="https://LinkRober.github.io/bookshelf/categories/ios">ios</a>
    
  


  </div>

</div>
          
          <div class="post-content markdown" itemprop="articleBody">
            <div class="main-content-wrap">
              <h4 id="带着问题看文章">带着问题看文章：</h4>

<p>1.常规姿势的方法替换原理是什么</p>

<p>2.<code>Aspects</code>的方法替换原理是什么</p>

<p>3.为什么这样下面的代码这样hook之后，所有的实例的<code>viewWillAppear:</code>也被hook了</p>

<pre><code>[[UIViewController class] aspect_hookSelector:@selector(viewWillAppear:) withOptions:AspectPositionBefore usingBlock:^(){
        
} error:nil];
</code></pre>

<p>4.为什么<code>Aspect</code>不能hook静态方法</p>

<p>5.如果用先用Aspects hook了方法A，接着又用MethodSwizzle方法（下文有）对A进行了hook，两个hook都能执行吗？
</p>

<blockquote>
<h3 id="正文">正文</h3>
</blockquote>

<h4 id="runtime"><code>Runtime</code></h4>

<pre><code>void MethodSwizzle(Class c,SEL origSEL,SEL overrideSEL)
   {
       Method origMethod = class_getInstanceMethod(c, origSEL);
       Method overrideMethod= class_getInstanceMethod(c, overrideSEL);
       if(class_addMethod(c, origSEL, method_getImplementation(overrideMethod),method_getTypeEncoding(overrideMethod)))
       {
            //当前类不存在`origSEL`
            class_replaceMethod(c,overrideSEL, method_getImplementation(origMethod), method_getTypeEncoding(origMethod));
       } else  {
            method_exchangeImplementations(origMethod,overrideMethod);
       }
}
</code></pre>

<h5 id="1-method-class-getinstancemethod-class-cls-sel-sel">1. <code>Method class_getInstanceMethod(Class cls, SEL sel)</code></h5>

<p>从子类往父类递归查找Method</p>

<pre><code>static method_t *
getMethod_nolock(Class cls, SEL sel)
{
    method_t *m = nil;

    runtimeLock.assertLocked();

    // fixme nil cls?
    // fixme nil sel?

    assert(cls-&gt;isRealized());

    while (cls  &amp;&amp;  ((m = getMethodNoSuper_nolock(cls, sel))) == nil) {
        cls = cls-&gt;superclass;
    }

    return m;
}
</code></pre>

<h5 id="2-bool-class-addmethod-class-cls-sel-name-imp-imp-const-char-types">2. <code>BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types)</code></h5>

<p>为类添加新方法</p>

<p>如果当前类已经有这个<code>selector</code>，拿到该<code>selector</code>的<code>IMP</code>返回False；如果没有，或父类存在，会将这个方法的IMP指向新的IMP，返回True。</p>

<pre><code>BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types)
{
    if (!cls) return NO;

    mutex_locker_t lock(runtimeLock);
    return ! addMethod(cls, name, imp, types ?: &quot;&quot;, NO);
}
</code></pre>

<pre><code>static IMP 
addMethod(Class cls, SEL name, IMP imp, const char *types, bool replace)
{
    IMP result = nil;

    runtimeLock.assertLocked();

    checkIsKnownClass(cls);
    
    assert(types);
    assert(cls-&gt;isRealized());

    method_t *m;
    if ((m = getMethodNoSuper_nolock(cls, name))) {
        // already exists
        if (!replace) {
            result = m-&gt;imp;
        } else {
            result = _method_setImplementation(cls, m, imp);
        }
    } else {
        // fixme optimize
        method_list_t *newlist;
        newlist = (method_list_t *)calloc(sizeof(*newlist), 1);
        newlist-&gt;entsizeAndFlags = 
            (uint32_t)sizeof(method_t) | fixed_up_method_list;
        newlist-&gt;count = 1;
        newlist-&gt;first.name = name;
        newlist-&gt;first.types = strdupIfMutable(types);
        newlist-&gt;first.imp = imp;

        prepareMethodLists(cls, &amp;newlist, 1, NO, NO);
        cls-&gt;data()-&gt;methods.attachLists(&amp;newlist, 1);
        flushCaches(cls);

        result = nil;
    }

    return result;
}

</code></pre>

<h4 id="3-imp-class-replacemethod-class-cls-sel-name-imp-imp-const-char-types">3. <code>IMP class_replaceMethod(Class cls, SEL name, IMP imp, const char *types)</code></h4>

<p>改变当前类中某个<code>selector</code>的<code>IMP</code></p>

<pre><code>IMP 
class_replaceMethod(Class cls, SEL name, IMP imp, const char *types)
{
    if (!cls) return nil;

    mutex_locker_t lock(runtimeLock);
    return addMethod(cls, name, imp, types ?: &quot;&quot;, YES);
}
</code></pre>

<pre><code>static IMP _method_setImplementation(Class cls, method_t *m, IMP imp)
{
    runtimeLock.assertLocked();

    if (!m) return nil;
    if (!imp) return nil;

    IMP old = m-&gt;imp;
    m-&gt;imp = imp;

    // Cache updates are slow if cls is nil (i.e. unknown)
    // RR/AWZ updates are slow if cls is nil (i.e. unknown)
    // fixme build list of classes whose Methods are known externally?

    flushCaches(cls);

    updateCustomRR_AWZ(cls, m);

    return old;
}
</code></pre>

<h4 id="4-void-method-exchangeimplementations-method-m1-method-m2">4. <code>void method_exchangeImplementations(Method m1, Method m2)</code></h4>

<p>交换两个<code>Method</code>的<code>IMP</code></p>

<pre><code>void method_exchangeImplementations(Method m1, Method m2)
{
    if (!m1  ||  !m2) return;

    mutex_locker_t lock(runtimeLock);

    IMP m1_imp = m1-&gt;imp;
    m1-&gt;imp = m2-&gt;imp;
    m2-&gt;imp = m1_imp;


    // RR/AWZ updates are slow because class is unknown
    // Cache updates are slow because class is unknown
    // fixme build list of classes whose Methods are known externally?

    flushCaches(nil);

    updateCustomRR_AWZ(nil, m1);
    updateCustomRR_AWZ(nil, m2);
}

</code></pre>

<p>总结：</br>
上面包含了方法交互的两种方式：
- 已经存在的要交换的方法，直接交换方法的<code>IMP</code>指针
- 要交换的方法不存在，动态创建方法再交换方法的<code>IMP</code></p>

<blockquote>
<p>Tips:交换<code>Method</code></p>

<pre><code>method_exchangeImplementations(class_getInstanceMethod(self, @selector(viewDidAppear:)),
                                   class_getInstanceMethod(self, @selector(ex_viewDidAppear:
</code></pre>
</blockquote>

<h4 id="aspects"><code>Aspects</code></h4>

<h5 id="一-消息转发">（一）消息转发</h5>

<p>消息转发有3个阶段：
1. 当前对象动态添加方法来响应
2. 有备用对象能够响应该方法
3. 通过forwardInvocation方法来处理该方法</p>

<p>阶段3最灵活，和原来的类耦合最少。<code>Aspects</code>就是在这个阶段来做方法替换。它替换的是什么呢，就是<code>forwardInvocation</code>的<code>IMP</code>。</p>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEB95b6876b75aa452319fef5a997016d55?method=download&amp;shareKey=809104bf2daedc6e202304bd2e45d2e8" alt="" />
经过讨论应该是下面这样的流程
<img src="https://note.youdao.com/yws/api/personal/file/WEB84716c5dcfa90f82f31dca71e6baf268?method=download&amp;shareKey=476d1e7dc88416af4d492f8d9e541243" alt="" /></p>

<p>Aspects会强制将你要hook的方法的<code>IMP</code>指向<code>_objc_msgForward</code>的<code>IMP</code>，也就意味着你<strong>直接</strong>走到了消息转发的最后一步。接着在新的<code>IMP</code>： <code>__ASPECTS_ARE_BEING_CALLED__</code> 里面做各种切面的hook，before、instead、after。</p>

<pre><code>typedef NS_OPTIONS(NSUInteger, AspectOptions) {
    AspectPositionAfter   = 0,            /// Called after the original implementation (default)
    AspectPositionInstead = 1,            /// Will replace the original implementation.
    AspectPositionBefore  = 2,            /// Called before the original implementation.
    
    AspectOptionAutomaticRemoval = 1 &lt;&lt; 3 /// Will remove the hook after the first execution.
};
</code></pre>

<h5 id="二-实例对象和类对象的hook">（二）实例对象和类对象的Hook</h5>

<p>类对象：<br>
直接将当前类对象<code>forwardInvocation</code>的<code>IMP</code>替换。</p>

<pre><code>static void aspect_swizzleForwardInvocation(Class klass) {
    NSCParameterAssert(klass);
    // If there is no method, replace will act like class_addMethod.
    IMP originalImplementation = class_replaceMethod(klass, @selector(forwardInvocation:), (IMP)__ASPECTS_ARE_BEING_CALLED__, &quot;v@:@&quot;);
    ...
}
</code></pre>

<p>实例对象：</br></p>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEBaab254928096c6f3850e8c5d74175e90?method=download&amp;shareKey=f9ddd204eb6c299ad61feb797005dca4" alt="" /></p>

<p>1.动态创建当前类的子类，2.再将子类的<code>forwardInvocation</code>进行替换，3.最后将类对象和原类<code>class</code>方法的<code>IMP</code>指向当前类的<code>class</code>方法的<code>IMP</code>,4.将当前类的<code>isa</code>指向动态创建的类</p>

<pre><code>const char *subclassName = [className stringByAppendingString:AspectsSubclassSuffix].UTF8String;
Class subclass = objc_getClass(subclassName);
if (subclass == nil) {
		subclass = objc_allocateClassPair(baseClass, subclassName, 0);
		if (subclass == nil) {
            NSString *errrorDesc = [NSString stringWithFormat:@&quot;objc_allocateClassPair failed to allocate class %s.&quot;, subclassName];
            AspectError(AspectErrorFailedToAllocateClassPair, errrorDesc);
            return nil;
        }

		aspect_swizzleForwardInvocation(subclass);
		aspect_hookedGetClass(subclass, statedClass);
		aspect_hookedGetClass(object_getClass(subclass), statedClass);
		objc_registerClassPair(subclass);
	}
	//将self的isa指向动态创建的类
object_setClass(self, subclass);
</code></pre>

<p>这样做能保证现有的方法能正常执行；对当前类结构的改动最小。在<code>remove</code>的时候<code>isa</code>指针指回来就好了。</p>

<pre><code>...
NSString *className = NSStringFromClass(klass);
        if ([className hasSuffix:AspectsSubclassSuffix]) {
            Class originalClass = NSClassFromString([className stringByReplacingOccurrencesOfString:AspectsSubclassSuffix withString:@&quot;&quot;]);
            NSCAssert(originalClass != nil, @&quot;Original class must exist&quot;);
            //将self的isa指向原来的类
            object_setClass(self, originalClass);
            AspectLog(@&quot;Aspects: %@ has been restored.&quot;, NSStringFromClass(originalClass));
            ...
        }
...
</code></pre>

<h5 id="三-源码">（三）源码</h5>

<h6 id="配置">配置</h6>

<pre><code>static id aspect_add(id self, SEL selector, AspectOptions options, id block, NSError **error) {
    NSCParameterAssert(self);
    NSCParameterAssert(selector);
    NSCParameterAssert(block);

    __block AspectIdentifier *identifier = nil;
    
    ①aspect_performLocked(^{
        if (②aspect_isSelectorAllowedAndTrack(self, selector, options, error)) {
            ③AspectsContainer *aspectContainer = aspect_getContainerForObject(self, selector);
            identifier = [AspectIdentifier identifierWithSelector:selector object:self options:options block:block error:error];
            if (identifier) {
                ④[aspectContainer addAspect:identifier withOptions:options];

                // Modify the class to allow message interception.
                ⑤aspect_prepareClassAndHookSelector(self, selector, error);
            }
        }
    });
    return identifier;
}

</code></pre>

<h3 id="①-br">①</br></h3>

<p>对代码块加自旋锁</p>

<pre><code>static void aspect_performLocked(dispatch_block_t block) {
    static OSSpinLock aspect_lock = OS_SPINLOCK_INIT;
    OSSpinLockLock(&amp;aspect_lock);
    block();
    OSSpinLockUnlock(&amp;aspect_lock);
}
</code></pre>

<h3 id="②-br">②</br></h3>

<p>selector校验和tracker设置</p>

<ol>
<li><p>黑名单校验，这些方法是无法被hook的，有<code>retain</code>、<code>release</code>、<code>autorelease</code>、<code>forwardInvocation:</code>、</p>

<pre><code>// Check against the blacklist.
NSString *selectorName = NSStringFromSelector(selector);
if ([disallowedSelectorList containsObject:selectorName]) {
    NSString *errorDescription = [NSString stringWithFormat:@&quot;Selector %@ is blacklisted.&quot;, selectorName];
    AspectError(AspectErrorSelectorBlacklisted, errorDescription);
    return NO;
}
</code></pre></li>

<li><p><code>dealloc</code>无法在<code>AspectPositionBefore</code>情况下被hook；当前实例和类必须要都能响应要hook的方法</p>

<pre><code>AspectOptions position = options&amp;AspectPositionFilter;
if ([selectorName isEqualToString:@&quot;dealloc&quot;] &amp;&amp; position != AspectPositionBefore) {
    NSString *errorDesc = @&quot;AspectPositionBefore is the only valid position when hooking dealloc.&quot;;
    AspectError(AspectErrorSelectorDeallocPosition, errorDesc);
    return NO;
}
if (![self respondsToSelector:selector] &amp;&amp; ![self.class instancesRespondToSelector:selector]) {
    NSString *errorDesc = [NSString stringWithFormat:@&quot;Unable to find selector -[%@ %@].&quot;, NSStringFromClass(self.class), selectorName];
    AspectError(AspectErrorDoesNotRespondToSelector, errorDesc);
    return NO;
}
</code></pre></li>

<li><p>如果是类对象，为该类及其继承体系上的所有类创建一个<code>AspectTracker</code>，并保存到一个全局单例的可变字典中。</p>

<pre><code>    currentClass = klass;
    AspectTracker *parentTracker = nil;
    do {
        AspectTracker *tracker = swizzledClassesDict[currentClass];
        if (!tracker) {
            tracker = [[AspectTracker alloc] initWithTrackedClass:currentClass parent:parentTracker];
            swizzledClassesDict[(id&lt;NSCopying&gt;)currentClass] = tracker;
        }
        [tracker.selectorNames addObject:selectorName];
        // All superclasses get marked as having a subclass that is modified.
        parentTracker = tracker;
    }while ((currentClass = class_getSuperclass(currentClass)));
</code></pre>

<p><code>AspectTracker结构</code>
<img src="https://note.youdao.com/yws/api/personal/file/WEB715024449547b00293407b3d99066c57?method=download&amp;shareKey=d84e9dd7fe1949030441cea5e1156e96" alt="" /></p></li>
</ol>

<h3 id="③-br">③</br></h3>

<p>通过runtime为当前类关联一个<code>AspectsContainer</code>类型的属性。命名方式是</p>

<pre><code>//aspects__ + 方法名
eg:aspects__eat:andWater:
</code></pre>

<p><code>AspectsContainer</code>保存了被hook方法的三种切面数组
<img src="https://note.youdao.com/yws/api/personal/file/WEB970471b0e4303ce3e0f095a4a2c92d93?method=download&amp;shareKey=014892c4716701c7a5ed9026b33e33d1" alt="" /></p>

<p>数组里面的对象<code>AspectIdentifier</code>包含了在进行所有切面操作所需的信息，原方法、切面block、切面block的签名、如何切以及原方法所属的类。
<img src="https://note.youdao.com/yws/api/personal/file/WEB78a33ecad4ae519b1113d730103d4def?method=download&amp;shareKey=49e5bfc2a4f7297a29964987ea9fa873" alt="" /></p>

<p>在创建<code>AspectIdentifier</code>对象的初始化方法里有两个校验逻辑，1. 方法签名的校验 2. 方法签名兼容性判断。</p>

<p><code>Aspects</code>定义了一个结构和<code>NSGlobalBlock</code>类似的结构体<code>_AspectBlock</code>。我们的切面block(<code>NSGlobalBlock</code>)会被强转为<code>_AspectBlock</code>。</p>

<pre><code>// Block internals.
typedef NS_OPTIONS(int, AspectBlockFlags) {
	AspectBlockFlagsHasCopyDisposeHelpers = (1 &lt;&lt; 25),
	AspectBlockFlagsHasSignature          = (1 &lt;&lt; 30)
};
typedef struct _AspectBlock {
	__unused Class isa;
	AspectBlockFlags flags;
	__unused int reserved;
	void (__unused *invoke)(struct _AspectBlock *block, ...);
	struct {
		unsigned long int reserved;
		unsigned long int size;
		// requires AspectBlockFlagsHasCopyDisposeHelpers
		void (*copy)(void *dst, const void *src);
		void (*dispose)(const void *);
		// requires AspectBlockFlagsHasSignature
		const char *signature;
		const char *layout;
	} *descriptor;
	// imported variables
} *AspectBlockRef;
</code></pre>

<p>Block方法签名的校验有两步：
1. <code>!(layout-&gt;flags &amp; AspectBlockFlagsHasSignature)</code>(这应该是flags的一个规则)，如果<code>layout-&gt;flags</code>的值是0，返回nil</p>

<pre><code>AspectBlockRef layout = (__bridge void *)block;
	if (!(layout-&gt;flags &amp; AspectBlockFlagsHasSignature)) {
        NSString *description = [NSString stringWithFormat:@&quot;The block %@ doesn't contain a type signature.&quot;, block];
        AspectError(AspectErrorMissingBlockSignature, description);
        return nil;
}

</code></pre>

<ol>
<li>在<code>layout-&gt;descriptor</code>中是否存在<code>signature</code>。<code>desc</code>先向下偏移2个<code>unsigned long int</code>大小，如果存在copy和dispose函数继续向下偏移2个<code>unsigned long int</code>大小。这时候检查签名是否为空。
<code>
void *desc = layout-&gt;descriptor;
	desc += 2 * sizeof(unsigned long int);
	if (layout-&gt;flags &amp; AspectBlockFlagsHasCopyDisposeHelpers) {
		desc += 2 * sizeof(void *);
}
	if (!desc) {
    NSString *description = [NSString stringWithFormat:@&quot;The block %@ doesn't has a type signature.&quot;, block];
    AspectError(AspectErrorMissingBlockSignature, description);
    return nil;
}
	const char *signature = (*(const char **)desc);
	return [NSMethodSignature signatureWithObjCTypes:signature];
</code>
<img src="https://lc-api-gold-cdn.xitu.io/3293f66aeb756e10eba7" alt="" /></li>
</ol>

<p>方法签名兼容性判断，通过对比方法签名来实现。</p>

<pre><code>static BOOL aspect_isCompatibleBlockSignature(NSMethodSignature *blockSignature, id object, SEL selector, NSError **error) {
    NSCParameterAssert(blockSignature);
    NSCParameterAssert(object);
    NSCParameterAssert(selector);

    BOOL signaturesMatch = YES;
    NSMethodSignature *methodSignature = [[object class] instanceMethodSignatureForSelector:selector];
    if (blockSignature.numberOfArguments &gt; methodSignature.numberOfArguments) {
        signaturesMatch = NO;
    }else {
        if (blockSignature.numberOfArguments &gt; 1) {
            const char *blockType = [blockSignature getArgumentTypeAtIndex:1];
            if (blockType[0] != '@') {
                signaturesMatch = NO;
            }
        }
        // Argument 0 is self/block, argument 1 is SEL or id&lt;AspectInfo&gt;. We start comparing at argument 2.
        // The block can have less arguments than the method, that's ok.
        if (signaturesMatch) {
            for (NSUInteger idx = 2; idx &lt; blockSignature.numberOfArguments; idx++) {
                const char *methodType = [methodSignature getArgumentTypeAtIndex:idx];
                const char *blockType = [blockSignature getArgumentTypeAtIndex:idx];
                // Only compare parameter, not the optional type data.
                if (!methodType || !blockType || methodType[0] != blockType[0]) {
                    signaturesMatch = NO; break;
                }
            }
        }
    }

    if (!signaturesMatch) {
        NSString *description = [NSString stringWithFormat:@&quot;Blog signature %@ doesn't match %@.&quot;, blockSignature, methodSignature];
        AspectError(AspectErrorIncompatibleBlockSignature, description);
        return NO;
    }
    return YES;
}

</code></pre>

<p>如果方法签名个数不等返回NO；如果切面block的方法签名第1个参数（从第0个开始）的字符不是<code>@</code>返回NO；如果切面block的方法签名和要替换方法的方法签名从第2个开始不能一一匹配返回NO。</p>

<h3 id="④-br">④</br></h3>

<p>将构建好的<code>AspectIdentifier</code>，添加到类对应的<code>AspectsContainer</code>中，调用Hook方法时要用。</p>

<h3 id="⑤-br">⑤</br></h3>

<pre><code>static void aspect_prepareClassAndHookSelector(NSObject *self, SEL selector, NSError **error) {
    NSCParameterAssert(selector);
    Class klass = aspect_hookClass(self, error);
    Method targetMethod = class_getInstanceMethod(klass, selector);
    IMP targetMethodIMP = method_getImplementation(targetMethod);
    if (!aspect_isMsgForwardIMP(targetMethodIMP)) {
        // Make a method alias for the existing method implementation, it not already copied.
        const char *typeEncoding = method_getTypeEncoding(targetMethod);
        SEL aliasSelector = aspect_aliasForSelector(selector);
        if (![klass instancesRespondToSelector:aliasSelector]) {
            __unused BOOL addedAlias = class_addMethod(klass, aliasSelector, method_getImplementation(targetMethod), typeEncoding);
            NSCAssert(addedAlias, @&quot;Original implementation for %@ is already copied to %@ on %@&quot;, NSStringFromSelector(selector), NSStringFromSelector(aliasSelector), klass);
        }

        // We use forwardInvocation to hook in.
        class_replaceMethod(klass, selector, aspect_getMsgForwardIMP(self, selector), typeEncoding);
        AspectLog(@&quot;Aspects: Installed hook for -[%@ %@].&quot;, klass, NSStringFromSelector(selector));
    }
}
</code></pre>

<p>这里就是调整<code>IMP</code>指针。下面这段代码主要有两个功能。
1. 将类的<code>forwardInvocation</code>的<code>IMP</code>指向自定义的<code>IMP</code>。这里分四种情况，（一）已经hook过的类，指实例对象，当前类的前缀是<code>_Aspects_</code>，直接返回。（二）类对象，上文已讨论过。（三）类对象和元类不是同一个类。（四）动态添加方法，上文也已讨论过。</p>

<pre><code>//交换forwardInvocation IMP的代码
static NSString *const AspectsForwardInvocationSelectorName = @&quot;__aspects_forwardInvocation:&quot;;
static void aspect_swizzleForwardInvocation(Class klass) {
    NSCParameterAssert(klass);
    // If there is no method, replace will act like class_addMethod.
    IMP originalImplementation = class_replaceMethod(klass, @selector(forwardInvocation:), (IMP)__ASPECTS_ARE_BEING_CALLED__, &quot;v@:@&quot;);
    if (originalImplementation) {
        class_addMethod(klass, NSSelectorFromString(AspectsForwardInvocationSelectorName), originalImplementation, &quot;v@:@&quot;);
    }
    AspectLog(@&quot;Aspects: %@ is now aspect aware.&quot;, NSStringFromClass(klass));
}
</code></pre>

<p>2.将要hook方法的<code>IMP</code>指向<code>_objc_msgForward</code>。</p>

<p>到这里完成了所有的配置工作</p>

<h6 id="运行时">运行时</h6>

<p>直接上源码。</br>
先拿实例对象和类对象的<code>AspectsContainer</code>，可以为空。组装<code>AspectInfo</code>。先执行所有的<code>beforeAspects</code>切;接着如果存在<code>insteadAspects</code>，执行install切面，否则执行原方法；最后执行<code>afterAspects</code>切面。在每个切面执行的时候，实例对象和类对象的都要执行。如果有需要remove的切面都会加到<code>aspectsToRemove</code>这个数组里面，最后以remove掉。</p>

<pre><code>#pragma mark - Aspect Invoke Point

// This is a macro so we get a cleaner stack trace.
#define aspect_invoke(aspects, info) \
for (AspectIdentifier *aspect in aspects) {\
    [aspect invokeWithInfo:info];\
    if (aspect.options &amp; AspectOptionAutomaticRemoval) { \
        aspectsToRemove = [aspectsToRemove?:@[] arrayByAddingObject:aspect]; \
    } \
}

// This is the swizzled forwardInvocation: method.
static void __ASPECTS_ARE_BEING_CALLED__(__unsafe_unretained NSObject *self, SEL selector, NSInvocation *invocation) {
    NSCParameterAssert(self);
    NSCParameterAssert(invocation);
    SEL originalSelector = invocation.selector;
	SEL aliasSelector = aspect_aliasForSelector(invocation.selector);
    invocation.selector = aliasSelector;
    AspectsContainer *objectContainer = objc_getAssociatedObject(self, aliasSelector);
    AspectsContainer *classContainer = aspect_getContainerForClass(object_getClass(self), aliasSelector);
    AspectInfo *info = [[AspectInfo alloc] initWithInstance:self invocation:invocation];
    NSArray *aspectsToRemove = nil;

    // Before hooks.
    aspect_invoke(classContainer.beforeAspects, info);
    aspect_invoke(objectContainer.beforeAspects, info);

    // Instead hooks.
    BOOL respondsToAlias = YES;
    if (objectContainer.insteadAspects.count || classContainer.insteadAspects.count) {
        aspect_invoke(classContainer.insteadAspects, info);
        aspect_invoke(objectContainer.insteadAspects, info);
    }else {
        Class klass = object_getClass(invocation.target);
        do {
            if ((respondsToAlias = [klass instancesRespondToSelector:aliasSelector])) {
                [invocation invoke];
                break;
            }
        }while (!respondsToAlias &amp;&amp; (klass = class_getSuperclass(klass)));
    }

    // After hooks.
    aspect_invoke(classContainer.afterAspects, info);
    aspect_invoke(objectContainer.afterAspects, info);

    // If no hooks are installed, call original implementation (usually to throw an exception)
    if (!respondsToAlias) {
        invocation.selector = originalSelector;
        SEL originalForwardInvocationSEL = NSSelectorFromString(AspectsForwardInvocationSelectorName);
        if ([self respondsToSelector:originalForwardInvocationSEL]) {
            ((void( *)(id, SEL, NSInvocation *))objc_msgSend)(self, originalForwardInvocationSEL, invocation);
        }else {
            [self doesNotRecognizeSelector:invocation.selector];
        }
    }

    // Remove any hooks that are queued for deregistration.
    [aspectsToRemove makeObjectsPerformSelector:@selector(remove)];
}
</code></pre>

<p>到这里基本差不多了，还有两个地方没讲，切面Block调用实现<code>[aspect invokeWithInfo:info]</code>和移除切面，有兴趣的可以看看。</p>

<p>最后附上一张整体流程图
<img src="https://note.youdao.com/yws/api/personal/file/WEB24a1a6c4e7c65ed963c9c65099042c69?method=download&amp;shareKey=c4ea75a79f085b53d9d848ebd1b8543b" alt="" /></p>

<h5 id="四-答题">（四）答题</h5>

<p>1、2上面基本都已经说清楚了，我们从3看起：</p>

<p>3.为什么这样hook之后所有的实例方法也被hook了</p>

<pre><code>[[UIViewController class] aspect_hookSelector:@selector(viewWillAppear:) withOptions:AspectPositionBefore usingBlock:^(){
        
} error:nil];
</code></pre>

<p>答：这里考察的是<code>isa</code>的概念。实例对象调用方法的时候是在<strong>isa指针指向的对象</strong>里的方法列表去找，而<strong>isa指针指向的对象</strong>就是类对象，<code>Aspects</code>改变的是类对象方法列表里方法的<code>IMP</code>，所以无论那是实例调用了<code>viewWillAppear:</code>都会被hook</p>

<p>4.为什么<code>Aspect</code>不能hook静态方法
答：这里考察的也是<code>isa</code>的概念，可见<code>isa</code>在runtime中的地位非常重要。因为类对象调用方法的时候是到元类中去查找，而我们并没有对元类的方法进行hook。</p>

<p>5.如果用先用Aspects hook了方法A，接着又用MethodSwizzle对A进行了hook，两个hook都能执行吗？
答：先看这张图，以<code>viewDidAppear:</code>为列</p>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEBbd552a8d0fd08c81bddf036c20023229?method=download&amp;shareKey=c8ab8006d377bd96f97cd3bc38ca9d1b" alt="" /></p>

<p><code>viewDidAppear:</code>的IMP先被指向了<code>forwardInvocatoin:</code>，当用MethodSwizzle进行第二次hook的时候，原来想指向<code>viewDidAppear:</code>正真的<code>IMP</code>的指针其实指向了<code>forwardInvocatoin:</code>，而<code>forwardInvocatoin:</code>被<code>Aspects</code>指向了自定义的<code>__ASPECTS_ARE_BEING_CALLED__</code>。这时候当调用<code>km_viewDidAppear:</code>的时候调用了<code>Aspects</code>的消息转发。在执行原方法的时候执行的是<code>aspects__t_viewDidAppear:</code>而不是当初动态添加的<code>aspects__viewDidAppear:</code></p>

<pre><code>[self doesNotRecognizeSelector:invocation.selector];
</code></pre>

<p>所以答案是用<code>MethodSwizzle</code>hook的方法可以执行。<code>Aspects</code>Hook的方法无法执行，已经无法拿到正确的<code>AspectsContainer</code>，动态添加的属性名称class_getSuperclass不对（是基于<code>viewDidAppear</code>创建的属性，而不是<code>km_viewDidAppear</code>）了，最后崩溃了。</p>

<p>但是<code>Aspects</code>还给了你最后一次机会如果被hook的类里面实现了方法<code>__aspects_forwardInvocation</code>还能挽救下崩溃的局面。</p>

<pre><code>...
invocation.selector = originalSelector;
SEL originalForwardInvocationSEL = NSSelectorFromString(AspectsForwardInvocationSelectorName);
if ([self respondsToSelector:originalForwardInvocationSEL]) {
    ((void( *)(id, SEL, NSInvocation *))objc_msgSend)(self, originalForwardInvocationSEL, invocation);
}else {
    [self doesNotRecognizeSelector:invocation.selector];
}
...
</code></pre>

<p>以上的推断建立在当前类没有实现<code>viewDidAppear:</code>的前提下。如果当前类实现了<code>viewDidAppear:</code>MethodSwizzle拿到的就不是被交换过的IMP。这时候就可以形成闭环：<code>km_viewDidAppear:</code>-&gt;<code>viewDidAppear:(调用了[super viewDidAppear])</code>-&gt;<code>__ASPECTS_ARE_BEING_CALLED__</code>-&gt;<code>Aspects的hook方法</code></br>
<img src="https://note.youdao.com/yws/api/personal/file/WEBb7863bbb0e16ab705af8d7443bfead85?method=download&amp;shareKey=3b736c680f87c3c52f724c4845dca10b" alt="" /></p>

<h5 id="四-知识点">（四）知识点：</h5>

<ul>
<li>消息转发</li>
<li>runtime的各种方法</li>
<li><code>object_getClass(id _Nullable obj)</code></li>
<li><code>class_isMetaClass(Class _Nullable cls)</code></li>
<li><code>class_getSuperclass(Class _Nullable cls)</code></li>
<li><code>class_getInstanceMethod(Class _Nullable cls, SEL _Nonnull name)</code></li>
<li><code>class_addMethod(Class _Nullable cls, SEL _Nonnull name, IMP _Nonnull imp, const char * _Nullable types)</code></li>
<li><code>method_getImplementation(Method _Nonnull m)</code></li>
<li><code>method_getTypeEncoding(Method _Nonnull m)</code></li>
<li><code>class_replaceMethod(Class _Nullable cls, SEL _Nonnull name, IMP _Nonnull imp, const char * _Nullable types)</code></li>
<li><code>method_exchangeImplementations(Method _Nonnull m1, Method _Nonnull m2)</code></li>
<li><code>object_setClass(id _Nullable obj, Class _Nonnull cls)</code></li>
<li>isa指针</li>
<li>block结构</li>
<li>NSMethodSignature方法签名</li>
</ul>
              
            </div>
          </div>
          <div id="post-footer" class="post-footer main-content-wrap">
            
              
                
                
                  <div class="post-footer-tags">
                    <span class="text-color-light text-small">标签</span><br/>
                    
  <a class="tag tag--primary tag--small" href="https://linkrober.github.io/bookshelf//tags/aspect/">Aspect</a>

  <a class="tag tag--primary tag--small" href="https://linkrober.github.io/bookshelf//tags/method-swizzle/">method swizzle</a>

  <a class="tag tag--primary tag--small" href="https://linkrober.github.io/bookshelf//tags/runtime/">runtime</a>

                  </div>
                
              
            
            
  <div class="post-actions-wrap">
      <nav >
        <ul class="post-actions post-action-nav">
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://LinkRober.github.io/bookshelf/2020/11/%E5%86%B7%E4%BF%A1%E5%8F%B7%E5%92%8C%E7%83%AD%E4%BF%A1%E5%8F%B7%E6%9E%84%E5%BB%BA%E8%A7%A6%E5%8F%91%E6%B5%81%E7%A8%8B/" data-tooltip="冷信号和热信号构建触发流程">
              
                <i class="fa fa-angle-left"></i>
                <span class="hide-xs hide-sm text-small icon-ml">下一篇</span>
              </a>
            </li>
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://LinkRober.github.io/bookshelf/2018/05/object-c%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93/" data-tooltip="Object-C多线程总结">
              
                <span class="hide-xs hide-sm text-small icon-mr">上一篇</span>
                <i class="fa fa-angle-right"></i>
              </a>
            </li>
        </ul>
      </nav>
    <ul class="post-actions post-action-share" >
      
        <li class="post-action hide-lg hide-md hide-sm">
          <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions">
            <i class="fa fa-share-alt"></i>
          </a>
        </li>
        
      
      
        <li class="post-action">
          <a class="post-action-btn btn btn--default" href="#disqus_thread">
            <i class="fa fa-comment-o"></i>
          </a>
        </li>
      
      <li class="post-action">
        
          <a class="post-action-btn btn btn--default" href="#">
        
          <i class="fa fa-list"></i>
        </a>
      </li>
    </ul>
  </div>


            
              
                <div id="disqus_thread">
  <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
              
            
          </div>
        </article>
        
      </div>
      <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
        
  <div class="post-actions-wrap">
      <nav >
        <ul class="post-actions post-action-nav">
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://LinkRober.github.io/bookshelf/2020/11/%E5%86%B7%E4%BF%A1%E5%8F%B7%E5%92%8C%E7%83%AD%E4%BF%A1%E5%8F%B7%E6%9E%84%E5%BB%BA%E8%A7%A6%E5%8F%91%E6%B5%81%E7%A8%8B/" data-tooltip="冷信号和热信号构建触发流程">
              
                <i class="fa fa-angle-left"></i>
                <span class="hide-xs hide-sm text-small icon-ml">下一篇</span>
              </a>
            </li>
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://LinkRober.github.io/bookshelf/2018/05/object-c%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93/" data-tooltip="Object-C多线程总结">
              
                <span class="hide-xs hide-sm text-small icon-mr">上一篇</span>
                <i class="fa fa-angle-right"></i>
              </a>
            </li>
        </ul>
      </nav>
    <ul class="post-actions post-action-share" >
      
        <li class="post-action hide-lg hide-md hide-sm">
          <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions">
            <i class="fa fa-share-alt"></i>
          </a>
        </li>
        
      
      
        <li class="post-action">
          <a class="post-action-btn btn btn--default" href="#disqus_thread">
            <i class="fa fa-comment-o"></i>
          </a>
        </li>
      
      <li class="post-action">
        
          <a class="post-action-btn btn btn--default" href="#">
        
          <i class="fa fa-list"></i>
        </a>
      </li>
    </ul>
  </div>


      </div>
      <div id="share-options-bar" class="share-options-bar" data-behavior="4">
  <i id="btn-close-shareoptions" class="fa fa-close"></i>
  <ul class="share-options">
    
  </ul>
</div>
<div id="share-options-mask" class="share-options-mask"></div>
    </div>
    
    <div id="about">
  <div id="about-card">
    <div id="about-btn-close">
      <i class="fa fa-remove"></i>
    </div>
    
      <img id="about-card-picture" src="https://avatars1.githubusercontent.com/u/7357189?v=3&amp;s=460.png" alt="作者的图片" />
    
    <h4 id="about-card-name">董二千</h4>
    
      <div id="about-card-bio">愿你走出半生 归来仍是少年</div>
    
    
      <div id="about-card-job">
        <i class="fa fa-briefcase"></i>
        <br/>
        iOS Developer
      </div>
    
    
      <div id="about-card-location">
        <i class="fa fa-map-marker"></i>
        <br/>
        China
      </div>
    
  </div>
</div>

    <div id="algolia-search-modal" class="modal-container">
  <div class="modal">
    <div class="modal-header">
      <span class="close-button"><i class="fa fa-close"></i></span>
      <a href="https://algolia.com" target="_blank" rel="noopener" class="searchby-algolia text-color-light link-unstyled">
        <span class="searchby-algolia-text text-color-light text-small">by</span>
        <img class="searchby-algolia-logo" src="https://www.algolia.com/static_assets/images/press/downloads/algolia-light.svg">
      </a>
      <i class="search-icon fa fa-search"></i>
      <form id="algolia-search-form">
        <input type="text" id="algolia-search-input" name="search"
          class="form-control input--large search-input" placeholder="搜索" />
      </form>
    </div>
    <div class="modal-body">
      <div class="no-result text-color-light text-center"></div>
      <div class="results">
        
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://linkrober.github.io/bookshelf/2020/12/weak%E7%9A%84%E5%AE%9E%E7%8E%B0-sidetablesoldobj/">
                <h3 class="media-heading">Weak的实现-&amp;SideTables()[oldObj]</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Dec 12, 2020
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather"><p><code>&amp;SideTables()[oldObj]</code>这是什么？很多人看到这里都被这操作搞蒙了，下面分三步来理解，分别是<code>SideTables()</code>、<code>[oldObj]</code>、<code>&amp;</code>。先贴上入口的代码</p>

<pre><code>id oldObj;
SideTable *oldTable;

oldObj = *location;
oldTable = &amp;SideTables()[oldObj];
</code></pre>

<p></p></div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://linkrober.github.io/bookshelf/2020/12/weak%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%80/">
                <h3 class="media-heading">Weak的实现（一）</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Dec 12, 2020
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather"><p>本文较长分三篇按序阅读体验更佳，第四篇为辅助阅读按需看</p>

<ol>
<li><a href="https://linkrober.github.io/bookshelf/2020/12/weak%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%80/">Weak的实现（一）</a></li>
<li><a href="https://linkrober.github.io/bookshelf/2020/12/weak%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%BA%8C/">Weak的实现（二）</a></li>
<li><a href="https://linkrober.github.io/bookshelf/2020/12/weak%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%89/">Weak的实现（三）</a></li>
<li><a href="https://linkrober.github.io/bookshelf/2020/12/weak%E7%9A%84%E5%AE%9E%E7%8E%B0-sidetablesoldobj/">Weak的实现-&amp;SideTables()[oldObj]</a></li>
</ol>

<p>带着问题看源码：</p>

<ol>
<li>大家都知道weak的底层实现是一个散列表，那么散列表的结构是什么样的？</li>
<li>散列表的key是什么，value是什么，散列函数是怎样的？</li>
<li>通过几次查找才能找到对应的弱引用？</li>
<li>如何查找弱引用对象的引用计数？</li>
<li>一个对象对应一个<code>SideTable</code>表而一个<code>SideTable</code>对应多个对象，为什么这样设计</li>
</ol>

<p></p></div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://linkrober.github.io/bookshelf/2020/12/weak%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%89/">
                <h3 class="media-heading">Weak的实现（三）</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Dec 12, 2020
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather"><p>本文较长分三篇按序阅读体验更佳，第四篇为辅助阅读按需看</p>

<ol>
<li><a href="https://linkrober.github.io/bookshelf/2020/12/weak%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%80/">Weak的实现（一）</a></li>
<li><a href="https://linkrober.github.io/bookshelf/2020/12/weak%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%BA%8C/">Weak的实现（二）</a></li>
<li><a href="https://linkrober.github.io/bookshelf/2020/12/weak%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%89/">Weak的实现（三）</a></li>
<li><a href="https://linkrober.github.io/bookshelf/2020/12/weak%E7%9A%84%E5%AE%9E%E7%8E%B0-sidetablesoldobj/">Weak的实现-&amp;SideTables()[oldObj]</a></li>
</ol>

<h5 id="正文-接-weak的实现-二">正文 接 Weak的实现（二）</h5>

<h4 id="3-设置弱引用标志位">3 设置弱引用标志位</h4>

<p></p></div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://linkrober.github.io/bookshelf/2020/12/weak%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%BA%8C/">
                <h3 class="media-heading">Weak的实现（二）</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Dec 12, 2020
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather"><ol>
<li><a href="https://linkrober.github.io/bookshelf/2020/12/weak%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%80/">Weak的实现（一）</a></li>
<li><a href="https://linkrober.github.io/bookshelf/2020/12/weak%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%BA%8C/">Weak的实现（二）</a></li>
<li><a href="https://linkrober.github.io/bookshelf/2020/12/weak%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%89/">Weak的实现（三）</a></li>
<li><a href="https://linkrober.github.io/bookshelf/2020/12/weak%E7%9A%84%E5%AE%9E%E7%8E%B0-sidetablesoldobj/">Weak的实现-&amp;SideTables()[oldObj]</a></li>
</ol>

<h5 id="正文-接-weak的实现-一">正文 接 Weak的实现（一）</h5>

<h4 id="2-生成新的-weak-entry-t-插入到-weak-entries-中">2 生成新的<code>weak_entry_t</code>插入到<code>weak_entries</code>中</h4>

<p></p></div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://linkrober.github.io/bookshelf/2020/11/combinelatestzip%E5%92%8Cmerge%E7%9A%84%E5%8C%BA%E5%88%AB/">
                <h3 class="media-heading">CombineLatest、Zip和Merge的区别</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Nov 11, 2020
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather"><h4 id="信号触发方式">信号触发方式</h4>

<h5 id="merge">merge</h5>

<p>只要<code>merge</code>之后生成的信号被订阅就会<strong>自动</strong>触发所有压缩信号的订阅回调，如果靠前的信号出现了<code>error</code>后面的信号不再发送。</p>

<p>核心方法：<code>- (instancetype)flatten</code></br>
值：多次收到，分开的</p>

<pre><code> 1
 2
</code></pre>

<pre><code>RACSignal *s1 = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {
  [subscriber sendNext:@&quot;1&quot;];
    return nil;
}];

RACSignal *s2 = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {
    [subscriber sendNext:@&quot;2&quot;];
    return nil;
}];

[[RACSignal merge:@[s1,s2]] subscribeNext:^(id x) {
    NSLog(@&quot;%@&quot;,x);
}];

</code></pre>

<p></p></div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://linkrober.github.io/bookshelf/2020/11/connectautoconnectracreplaysubjectreplay/">
                <h3 class="media-heading">Connect、AutoConnect、RACReplaySubject、Replay</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Nov 11, 2020
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather"><h4 id="connect">Connect</h4>

<p>将冷信号包装成热信号，初始化冷信号，调用<code>publish</code>方法会自动生成一个<code>RACMulticastConnection</code>，该对象持有了原始信号和一个热信号。</p>

<pre><code>- (RACMulticastConnection *)publish {
	RACSubject *subject = [[RACSubject subject] setNameWithFormat:@&quot;[%@] -publish&quot;, self.name];
	RACMulticastConnection *connection = [self multicast:subject];
	return connection;
}
- (RACMulticastConnection *)multicast:(RACSubject *)subject {
	[subject setNameWithFormat:@&quot;[%@] -multicast: %@&quot;, self.name, subject.name];
	RACMulticastConnection *connection = [[RACMulticastConnection alloc] initWithSourceSignal:self subject:subject];
	return connection;
}
</code></pre>

<p>调用<code>connect</code>方法来触发订阅，注意调用一次触发一次。</p>

<p></p></div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://linkrober.github.io/bookshelf/2020/11/racsignal/">
                <h3 class="media-heading">RACSignal</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Nov 11, 2020
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather"><h4 id="创建信号">创建信号</h4>

<pre><code>
RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {
        [subscriber sendNext:@&quot;1&quot;];
        return nil;
    }];

</code></pre>

<p>分析</p>

<pre><code>//RACSignal.m
+ (RACSignal *)createSignal:(RACDisposable * (^)(id&lt;RACSubscriber&gt; subscriber))didSubscribe {
	return [RACDynamicSignal createSignal:didSubscribe];
}
</code></pre>

<p></p></div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://linkrober.github.io/bookshelf/2020/11/switchtolatest/">
                <h3 class="media-heading">SwitchToLatest</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Nov 11, 2020
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather"><p><code>- (RACSignal *)switchToLatest</code>和<code>- (RACSignal *)flatten</code>的功能类似，都可以将信号中的信号的值取出来。不同的是，前者如果订阅者处理多个信号，只有最后一个信号的值能收到，之前的信号会被销毁。而后者则都能收到所有值。</p>

<p></p></div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://linkrober.github.io/bookshelf/2020/11/concatcatchtonevertakeuntil/">
                <h3 class="media-heading">concat、catchTo、never、takeUntil</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Nov 11, 2020
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather"><ol>
<li><code>- (RACSignal *)concat:(RACSignal *)signal</code></li>
</ol>

<pre><code>//源码
- (RACSignal *)concat:(RACSignal *)signal {
	return [[RACSignal createSignal:^(id&lt;RACSubscriber&gt; subscriber) {
		RACSerialDisposable *serialDisposable = [[RACSerialDisposable alloc] init];

		RACDisposable *sourceDisposable = [self subscribeNext:^(id x) {
			[subscriber sendNext:x];
		} error:^(NSError *error) {
			[subscriber sendError:error];
		} completed:^{
			RACDisposable *concattedDisposable = [signal subscribe:subscriber];
			serialDisposable.disposable = concattedDisposable;
		}];

		serialDisposable.disposable = sourceDisposable;
		return serialDisposable;
	}] setNameWithFormat:@&quot;[%@] -concat: %@&quot;, self.name, signal];
}
</code></pre>

<p></p></div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://linkrober.github.io/bookshelf/2020/11/zip/">
                <h3 class="media-heading">zip</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Nov 11, 2020
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather"><pre><code>RACSignal *s1 = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {
       [subscriber sendNext:@&quot;1&quot;];
    return nil;
}];
RACSignal *s2 = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {
    [subscriber sendNext:@&quot;2&quot;];
    return nil;
}];
RACSignal *s3 = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {
    [subscriber sendNext:@&quot;3&quot;];
    return nil;
}];

RACSignal *zs = [RACSignal zip:@[s1,s2,s3]];

[zs subscribeNext:^(id x) {
    NSLog(@&quot;%@&quot;,x);
}];

</code></pre>

<p>同<code>zip</code>压缩的信号只有等所有的自信号都<code>sendNext</code>之后才会执行订阅回调。</p>

<p>问题：
1. 如何确保每个信号都发送完，才执行后压缩信号的订阅回调</p>

<p></p></div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
      </div>
    </div>
    <div class="modal-footer">
      <p class="results-count text-medium"
         data-message-zero=""
         data-message-one=""
         data-message-other="">
         31 posts found
      </p>
    </div>
  </div>
</div>
    
  
    
    <div id="cover" style="background-image:url('https://LinkRober.github.io/bookshelf/images/cover.jpg');"></div>
  


    
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js" integrity="sha256-IFHWFEbU2/+wNycDECKgjIRSirRNIDp2acEB5fvdVRU=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.8.0/highlight.min.js" integrity="sha256-+mpyNVJsNt4rVXCw0F+pAOiB3YxmHgrbJsx4ecPuUaI=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/jquery.fancybox.min.js" integrity="sha256-vMxgR/7FtLovVA+IPrR7+xTgIgARH7y9VZQnmmi0HDI=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/helpers/jquery.fancybox-thumbs.min.js" integrity="sha256-N0qFUh7/9vLvia87dDndewmsgsyYoNkdA212tPc+2NI=" crossorigin="anonymous"></script>


<script src="https://LinkRober.github.io/bookshelf/js/script-qi9wbxp2ya2j6p7wx1i6tgavftewndznf4v0hy2gvivk1rxgc3lm7njqb6bz.min.js"></script>


<script>
$(document).ready(function() {
  hljs.configure({ classPrefix: '', useBR: false });
  $('pre.code-highlight, pre > code').each(function(i, block) {
    if (!$(this).hasClass('codeblock')) {
      $(this).addClass('codeblock');
    }
    hljs.highlightBlock(block);
  });
});
</script>

  
    
      <script>
        var disqus_config = function () {
          this.page.url = 'https:\/\/linkrober.github.io\/bookshelf\/2020\/11\/%E6%96%B9%E6%B3%95%E6%9B%BF%E6%8D%A2%E5%92%8Caspects\/';
          
            this.page.identifier = '\/2020\/11\/%E6%96%B9%E6%B3%95%E6%9B%BF%E6%8D%A2%E5%92%8Caspects\/'
          
        };
        (function() {
          
          
          if (window.location.hostname == "localhost") {
            return;
          }
          var d = document, s = d.createElement('script');
          var disqus_shortname = 'dongerqian';
          s.src = '//' + disqus_shortname + '.disqus.com/embed.js';

          s.setAttribute('data-timestamp', +new Date());
          (d.head || d.body).appendChild(s);
        })();
      </script>
    
  



    
  </body>
</html>

